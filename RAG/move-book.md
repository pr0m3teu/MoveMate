The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# The Move Book

This is The Move Book - a comprehensive guide to the Move programming language and the Sui
blockchain. The book is intended for developers who are interested in learning about Move and
building on Sui.

The book is in active development and a work in progress. If you have any feedback or suggestions,
feel free to open an issue or a pull request on the
[GitHub repository](https://github.com/MystenLabs/move-book).

> If you're looking for The Move Reference, you can find it [here](/reference).
The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# The Move Book

This is The Move Book - a comprehensive guide to the Move programming language and the Sui
blockchain. The book is intended for developers who are interested in learning about Move and
building on Sui.

The book is in active development and a work in progress. If you have any feedback or suggestions,
feel free to open an issue or a pull request on the
[GitHub repository](https://github.com/MystenLabs/move-book).

> If you're looking for The Move Reference, you can find it [here](/reference).
The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# The Move Book

This is The Move Book - a comprehensive guide to the Move programming language and the Sui
blockchain. The book is intended for developers who are interested in learning about Move and
building on Sui.

The book is in active development and a work in progress. If you have any feedback or suggestions,
feel free to open an issue or a pull request on the
[GitHub repository](https://github.com/MystenLabs/move-book).

> If you're looking for The Move Reference, you can find it [here](/reference).
The Move Reference | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# The Move Reference

Welcome to Move, a next generation language for secure asset programming. Its primary use case is in
blockchain environments, where Move programs are used to construct state changes. Move allows
developers to write programs that flexibly manage and transfer assets, while providing the security
and protections against attacks on those assets. However, Move has been developed with use cases in
mind outside a blockchain context as well.

Move takes its cue from [Rust](https://www.rust-lang.org/) by using resource types with move (hence
the name) semantics as an explicit representation of digital assets, such as currency.
GitHub - MystenLabs/move-book: The Move Book and The Move Reference



[Skip to content](#start-of-content)








## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FMystenLabs%2Fmove-book)

Appearance settings

Search or jump to...


# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.


Include my email address so I can be contacted

Cancel
 Submit feedback





# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

Cancel
 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FMystenLabs%2Fmove-book)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=MystenLabs%2Fmove-book)

Appearance settings

Resetting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.
 


Dismiss alert

{{ message }}

[MystenLabs](/MystenLabs) 
/
**[move-book](/MystenLabs/move-book)**
Public

* [Notifications](/login?return_to=%2FMystenLabs%2Fmove-book) You must be signed in to change notification settings
* [Fork
  146](/login?return_to=%2FMystenLabs%2Fmove-book)
* [Star
   255](/login?return_to=%2FMystenLabs%2Fmove-book)

The Move Book and The Move Reference

[move-book.com](https://move-book.com "https://move-book.com")

### License

[Apache-2.0 license](/MystenLabs/move-book/blob/main/LICENSE)

[255
stars](/MystenLabs/move-book/stargazers) [146
forks](/MystenLabs/move-book/forks) [Branches](/MystenLabs/move-book/branches) [Tags](/MystenLabs/move-book/tags) [Activity](/MystenLabs/move-book/activity)

[Star](/login?return_to=%2FMystenLabs%2Fmove-book)

[Notifications](/login?return_to=%2FMystenLabs%2Fmove-book) You must be signed in to change notification settings

# MystenLabs/move-book

main

[Branches](/MystenLabs/move-book/branches)[Tags](/MystenLabs/move-book/tags)

Go to file

Code

Open more actions menu

## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit   History[147 Commits](/MystenLabs/move-book/commits/main/) | | |
| [.github](/MystenLabs/move-book/tree/main/.github ".github") | | [.github](/MystenLabs/move-book/tree/main/.github ".github") |  |  |
| [book](/MystenLabs/move-book/tree/main/book "book") | | [book](/MystenLabs/move-book/tree/main/book "book") |  |  |
| [packages](/MystenLabs/move-book/tree/main/packages "packages") | | [packages](/MystenLabs/move-book/tree/main/packages "packages") |  |  |
| [reference](/MystenLabs/move-book/tree/main/reference "reference") | | [reference](/MystenLabs/move-book/tree/main/reference "reference") |  |  |
| [site](/MystenLabs/move-book/tree/main/site "site") | | [site](/MystenLabs/move-book/tree/main/site "site") |  |  |
| [.gitignore](/MystenLabs/move-book/blob/main/.gitignore ".gitignore") | | [.gitignore](/MystenLabs/move-book/blob/main/.gitignore ".gitignore") |  |  |
| [.prettierrc](/MystenLabs/move-book/blob/main/.prettierrc ".prettierrc") | | [.prettierrc](/MystenLabs/move-book/blob/main/.prettierrc ".prettierrc") |  |  |
| [CNAME](/MystenLabs/move-book/blob/main/CNAME "CNAME") | | [CNAME](/MystenLabs/move-book/blob/main/CNAME "CNAME") |  |  |
| [LICENSE](/MystenLabs/move-book/blob/main/LICENSE "LICENSE") | | [LICENSE](/MystenLabs/move-book/blob/main/LICENSE "LICENSE") |  |  |
| [README.md](/MystenLabs/move-book/blob/main/README.md "README.md") | | [README.md](/MystenLabs/move-book/blob/main/README.md "README.md") |  |  |
| [package.json](/MystenLabs/move-book/blob/main/package.json "package.json") | | [package.json](/MystenLabs/move-book/blob/main/package.json "package.json") |  |  |
| View all files | | |

## Repository files navigation

# The Move Book

This is the repository for [the Move Book](https://move-book.com) and
[Move Language Reference](https://move-book.com/reference).

## Structure

* Two books are placed in the `book` and `reference` directories. The `book` directory contains the
  main book, and the `reference` directory contains the reference book.
* The `packages` directory contains the code samples used in both books.
* The `site` directory contains [docusaurus](/MystenLabs/move-book/blob/main/docusaurus.io) configuration and custom plugins for it.

## Running the Books Locally

### Prerequisites

* NodeJS
* `pnpm` (installation is: `npm i -g pnpm`)

### Local Server

> All commands can be run from the root.

```move
pnpm start
```

*The book will be available at `http://localhost:3000`.*

### Production Build Test

```move
pnpm build
pnpm serve
```

## Archive

For the archive of the old version of the book, see the `archive` branch.

## About

The Move Book and The Move Reference

[move-book.com](https://move-book.com "https://move-book.com")

### Topics

[move](/topics/move "Topic: move")
[sui](/topics/sui "Topic: sui")

### Resources

[Readme](#readme-ov-file)

### License

[Apache-2.0 license](#Apache-2.0-1-ov-file)

### Uh oh!

There was an error while loading. Please reload this page.

[Activity](/MystenLabs/move-book/activity)

[Custom properties](/MystenLabs/move-book/custom-properties)

### Stars

[**255**
stars](/MystenLabs/move-book/stargazers)

### Watchers

[**8**
watching](/MystenLabs/move-book/watchers)

### Forks

[**146**
forks](/MystenLabs/move-book/forks)

[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2FMystenLabs%2Fmove-book&report=MystenLabs+%28user%29)

### Uh oh!

There was an error while loading. Please reload this page.

## [Contributors 49](/MystenLabs/move-book/graphs/contributors)

### Uh oh!

There was an error while loading. Please reload this page.

[+ 35 contributors](/MystenLabs/move-book/graphs/contributors)

## Languages

* [Move
  45.5%](/MystenLabs/move-book/search?l=move)
* [JavaScript
  32.0%](/MystenLabs/move-book/search?l=javascript)
* [TypeScript
  16.4%](/MystenLabs/move-book/search?l=typescript)
* [CSS
  6.1%](/MystenLabs/move-book/search?l=css)

You can’t perform that action at this time.
The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# The Move Book

This is The Move Book - a comprehensive guide to the Move programming language and the Sui
blockchain. The book is intended for developers who are interested in learning about Move and
building on Sui.

The book is in active development and a work in progress. If you have any feedback or suggestions,
feel free to open an issue or a pull request on the
[GitHub repository](https://github.com/MystenLabs/move-book).

> If you're looking for The Move Reference, you can find it [here](/reference).
Foreword | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Foreword

This book is dedicated to Move, a smart contract language that captures the essence of safe
programming with digital assets. Move is designed around the following values:

1. **Secure by default:** Insecure languages are a serious barrier both to accessible smart contract
   development and to mainstream adoption of digital assets. The first duty of a smart contract
   language is to prevent as many potential safety issues as possible (e.g. re-entrancy, missing
   access control checks, arithmetic overflow, ...) by construction. Any changes to Move should
   preserve or enhance its existing security guarantees.
2. **Expressive by nature:** Move must enable programmers to write any smart contract they can
   imagine. But we care as much about the way it *feels* to write Move as we do about what Move
   allows you to do - the language should be rich enough that the features needed for a task are
   available, and minimal enough that the choice is obvious. The Move toolchain should be a
   productivity enhancer and a thought partner.
3. **Intuitive for all:** Smart contracts are only one part of a useful application. Move should
   understand the broader context of its usage and design with both the smart contract developer and
   the application developer in mind. It should be easy for developers to learn how to read
   Move-managed state, build Move powered transactions, and write new Move code.

The core technical elements of Move are:

* Safe, familiar, and flexible abstractions for digital assets via programmable *objects*.
* A rich *ability* system (inspired by linear types) that gives programmers extreme control of how
  values are created, destroyed, stored, copied, and transferred.
* A *module* system with strong encapsulation features to enable code reuse while maintaining this
  control.
* *Dynamic fields* for creating hierarchical relationships between objects.
* *Programmable transaction blocks* (PTBs) to enable atomic client-side composition of Move-powered
  APIs.

Move was born in 2018 as part of Facebook's Libra project. It was publicly revealed in 2019, the
first Move-powered network launched in 2020. As of April 2024, there are numerous Move-powered
chains in production with several more in the works. Move is an embedded language with a
platform-agnostic core, which means it takes on a slightly different personality in each chain that
uses it.

Creating a new programming language and bootstrapping a community around it is an ambitious, long
term project. A language has to be an order of magnitude better than alternatives in relevant ways
to have a chance, but even then the quality of the community matters more than the technical
fundamentals. Move is a young language, but it's off to a good start in terms of both
differentiation and community. A small, but fanatical group of smart contract programmers and core
contributors united by the Move values are pushing the boundaries of what smart contracts can do,
the applications they can enable, and who can (safely) write them. If that inspires you, read on!

— Sam Blackshear, creator of Move
Before We Begin | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Before We Begin

Move requires an environment to run and develop applications, and in this small chapter we will
cover the prerequisites for the Move language: how to set up your IDE, how to install the compiler
and what is Move 2024. If you are already familiar with these topics or have a CLI installed, you
can skip this chapter and proceed to [the next one](/your-first-move/hello-world).
Install Sui | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Install Sui

Move is a compiled language, so you need to install a compiler to be able to write and run Move
programs. The compiler is included into the Sui binary, which can be installed or downloaded using
one of the methods below.

## Installing via suiup[​](#installing-via-suiup "Direct link to Installing via suiup")

The best way to install Sui is by using [suiup](https://github.com/MystenLabs/suiup). It provides a simple way to install binaries and to manage different versions of binaries for
different environments (e.g. testnet and mainnet).

Installation instructions for suiup can be found
[in the repository README](https://github.com/MystenLabs/suiup).

To install Sui, run the following command:

```move
suiup install sui
```

## Download Binary[​](#download-binary "Direct link to Download Binary")

You can download the latest Sui binary from the
[releases page](https://github.com/MystenLabs/sui/releases). The binary is available for macOS,
Linux and Windows. For education purposes and development, we recommend using the mainnet version.

## Install Using Homebrew (MacOS)[​](#install-using-homebrew-macos "Direct link to Install Using Homebrew (MacOS)")

You can install Sui using the [Homebrew](https://brew.sh/) package manager.

```move
brew install sui
```

## Install Using Chocolatey (Windows)[​](#install-using-chocolatey-windows "Direct link to Install Using Chocolatey (Windows)")

You can install Sui using the [Chocolatey](https://chocolatey.org/install) package manager for
Windows.

```move
choco install sui
```

## Build Using Cargo (MacOS, Linux)[​](#build-using-cargo-macos-linux "Direct link to Build Using Cargo (MacOS, Linux)")

You can install and build Sui locally by using the Cargo package manager (requires Rust)

```move
cargo install --git https://github.com/MystenLabs/sui.git sui --branch mainnet
```

Change the branch target here to testnet or devnet if you are targeting one of those.

Make sure that your system has the latest Rust versions with the command below.

```move
rustup update stable
```

## Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")

For troubleshooting the installation process, please refer to the
[Install Sui](https://docs.sui.io/guides/developer/getting-started/sui-install) Guide.

* [Installing via suiup](#installing-via-suiup)
* [Download Binary](#download-binary)
* [Install Using Homebrew (MacOS)](#install-using-homebrew-macos)
* [Install Using Chocolatey (Windows)](#install-using-chocolatey-windows)
* [Build Using Cargo (MacOS, Linux)](#build-using-cargo-macos-linux)
* [Troubleshooting](#troubleshooting)
Install MVR | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Install MVR

[Move Registry (MVR)](https://moveregistry.com) is a package manager for Move. It allows anyone to
publish and use published packages in new applications written in Move. Local binary allows
searching packages in the registry as well as installing them as a part of the Sui CLI build
process.

## Installing via suiup[​](#installing-via-suiup "Direct link to Installing via suiup")

The best way to install MVR is by using [suiup](https://github.com/MystenLabs/suiup). Suiup
provides an easy way to update and manage different versions of binaries.

Installation instructions for suiup can be found
[in the repository README](https://github.com/MystenLabs/suiup).

To install Move Registry CLI, run the following command:

```move
suiup install mvr
```

After installation, Move Registry will be available as mvr.

## Download Binary[​](#download-binary "Direct link to Download Binary")

You can download the latest MVR binary from the
[releases page](https://github.com/MystenLabs/mvr/releases). The binary is available for macOS,
Linux and Windows. Unlike [Sui](/before-we-begin/install-sui), the MVR binary is not changing between
environments and supports both testnet and mainnet.

## Install Using Cargo[​](#install-using-cargo "Direct link to Install Using Cargo")

You can install and build MVR locally by using Cargo (requires Rust)

```move
cargo install --locked --git https://github.com/mystenlabs/mvr --branch release mvr
```

## Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")

For troubleshooting the installation process, please refer to the
[Install MVR](https://docs.suins.io/move-registry/tooling/mvr-cli#installation) Guide.

* [Installing via suiup](#installing-via-suiup)
* [Download Binary](#download-binary)
* [Install Using Cargo](#install-using-cargo)
* [Troubleshooting](#troubleshooting)
Set Up Your IDE | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Set Up Your IDE

There are two most popular IDEs for Move development: VSCode and IntelliJ IDEA. Both of them provide
basic features like syntax highlighting and error messages, though they differ in their additional
features. Whatever IDE you choose, you'll need to use the terminal to run the
[Move CLI](/before-we-begin/install-sui).

> **IntelliJ Plugin does not support Move 2024 edition, some syntax won't get highlighted.**

## VSCode[​](#vscode "Direct link to VSCode")

* [VSCode](https://code.visualstudio.com/) is a free and open source IDE from Microsoft.
* [Move (Extension)](https://marketplace.visualstudio.com/items?itemName=mysten.move) is a language
  server extension for Move maintained by [Mysten Labs](https://mystenlabs.com).
* [Move Formatter](https://marketplace.visualstudio.com/items?itemName=mysten.prettier-move) - code
  formatter for Move, developed and maintained by [Mysten Labs](https://mystenlabs.com).
* [Move Syntax](https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax) a simple
  syntax highlighting extension for Move by [Damir Shamanaev](https://github.com/damirka/).

## IntelliJ IDEA[​](#intellij-idea "Direct link to IntelliJ IDEA")

* [IntelliJ IDEA](https://www.jetbrains.com/idea/) is a commercial IDE from JetBrains.
* [Move Language Plugin](https://plugins.jetbrains.com/plugin/23301-sui-move-language) provides a
  Move on Sui language extension for IntelliJ IDEA by [MoveFuns](https://movefuns.org/).

## Emacs[​](#emacs "Direct link to Emacs")

* [Emacs](https://www.gnu.org/software/emacs/) is a free and open source text editor.
* [move-mode](https://github.com/amnn/move-mode) is a Move mode for Emacs by
  [Ashok Menon](https://github.com/amnn).

## Zed[​](#zed "Direct link to Zed")

* [Zed](https://zed.dev/) is a next-generation code editor designed for high-performance
  collaboration with humans and AI.
* [Move](https://github.com/Tzal3x/move-zed-extension) is a language server extension for Move
  maintained by [Tzal3x](https://github.com/Tzal3x).

## Github Codespaces[​](#github-codespaces "Direct link to Github Codespaces")

The Web-based IDE from Github can be run right in the browser and provides almost a full-featured
VSCode experience.

* [Github Codespaces](https://github.com/features/codespaces)
* [Move Syntax](https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax) is also
  available in the extensions marketplace.
* [Move Formatter](https://marketplace.visualstudio.com/items?itemName=mysten.prettier-move) is also
  available in the extensions marketplace.

## Other (CLI)[​](#other-cli "Direct link to Other (CLI)")

Some of the tools listed above have CLI-supported versions.

* [prettier-plugin-move](https://www.npmjs.com/package/@mysten/prettier-plugin-move) contains the
  TypeScript package for the Prettier@v3 plugin as well as the binary to run it in a terminal

* [VSCode](#vscode)
* [IntelliJ IDEA](#intellij-idea)
* [Emacs](#emacs)
* [Zed](#zed)
* [Github Codespaces](#github-codespaces)
* [Other (CLI)](#other-cli)
Move 2024 | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Move 2024

Move 2024 is the current edition of the Move language maintained by Mysten Labs. All of the examples
in this book are written in Move 2024. If you're used to the pre-2024 version of Move, refer
to the [Move 2024 Migration Guide](/guides/2024-migration-guide) to learn about the changes
and improvements in the new edition.
Hello, World! | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Hello, World!

In this chapter, you will learn how to create a new package, write a simple module, compile it, and
run tests with the Move CLI. Make sure you have [installed Sui](/before-we-begin/install-sui)
and set up your [IDE environment](/before-we-begin/ide-support). Run the command below to test
if Sui has been installed correctly.

```move
# It should print the client version. E.g. sui-client 1.22.0-036299745.  
sui client --version
```

> Move CLI is a command-line interface for the Move language; it is built into the Sui binary and
> provides a set of commands to manage packages, compile and test code.

The structure of the chapter is as follows:

* [Create a New Package](#create-a-new-package)
* [Directory Structure](#directory-structure)
* [Compiling the Package](#compiling-the-package)
* [Running Tests](#running-tests)

## Create a New Package[​](#create-a-new-package "Direct link to Create a New Package")

To create a new program, we will use the sui move new command followed by the name of the
application. Our first program will be called hello\_world.

> Note: In this and other chapters, if you see code blocks with lines starting with $ (dollar
> sign), it means that the following command should be run in a terminal. The sign should not be
> included. It's a common way of showing commands in terminal environments.

```move
$ sui move new hello_world
```

The sui move command gives access to the Move CLI - a built-in compiler, test runner and a utility
for all things Move. The new command followed by the name of the package will create a new package
in a new folder. In our case, the folder name is "hello\_world".

We can view the contents of the folder to see that the package was created successfully.

```move
$ ls -l hello_world  
Move.toml  
sources  
tests
```

## Directory Structure[​](#directory-structure "Direct link to Directory Structure")

Move CLI will create a scaffold of the application and pre-create the directory structure and all
necessary files. Let's see what's inside.

```move
hello_world  
├── Move.toml  
├── sources  
│   └── hello_world.move  
└── tests  
    └── hello_world_tests.move
```

### Manifest[​](#manifest "Direct link to Manifest")

The Move.toml file, known as the [package manifest](/concepts/manifest), contains definitions
and configuration settings for the package. It is used by the Move Compiler to manage package
metadata, fetch dependencies, and register named addresses. We will explain it in detail in the
[Concepts](/concepts/) chapter.

> By default, the package features one named address - the name of the package.

```move
[addresses]  
hello_world = "0x0"
```

### Sources[​](#sources "Direct link to Sources")

The sources/ directory contains the source files. Move source files have *.move* extension, and
are typically named after the module defined in the file. For example, in our case, the file name is
*hello\_world.move* and the Move CLI has already placed commented out code inside:

```move
/*  
/// Module: hello_world  
module hello_world::hello_world;  
*/
```

> The /\* and \*/ are the comment delimiters in Move. Everything in between is ignored by the
> compiler and can be used for documentation or notes. We explain all ways to comment the code in
> the [Basic Syntax](/move-basics/comments).

The commented out code is a module definition, it starts with the keyword module followed by a
named address (or an address literal), and the module name. The module name is a unique identifier
for the module and has to be unique within the package. The module name is used to reference the
module from other modules or transactions.

### Tests[​](#tests "Direct link to Tests")

The tests/ directory contains package tests. The compiler excludes these files in the regular
build process but uses them in *test* and *dev* modes. The tests are written in Move and are marked
with the #[test] attribute. Tests can be grouped in a separate module (then it's usually called
*module\_name\_tests.move*), or inside the module they're testing.

Modules, imports, constants and functions can be annotated with #[test\_only]. This attribute is
used to exclude modules, functions or imports from the build process. This is useful when you want
to add helpers for your tests without including them in the code that will be published on chain.

The *hello\_world\_tests.move* file contains a commented out test module template:

```move
/*  
#[test_only]  
module hello_world::hello_world_tests;  
// uncomment this line to import the module  
// use hello_world::hello_world;  
  
const ENotImplemented: u64 = 0;  
  
#[test]  
fun test_hello_world() {  
    // pass  
}  
  
#[test, expected_failure(abort_code = hello_world::hello_world_tests::ENotImplemented)]  
fun test_hello_world_fail() {  
    abort ENotImplemented  
}  
*/
```

### Other Folders[​](#other-folders "Direct link to Other Folders")

Additionally, Move CLI supports the examples/ folder. The files there are treated similarly to the
ones placed under the tests/ folder - they're only built in the *test* and *dev* modes. They are
to be examples of how to use the package or how to integrate it with other packages. The most
popular use case is for documentation purposes and library packages.

## Compiling the Package[​](#compiling-the-package "Direct link to Compiling the Package")

Move is a compiled language, and as such, it requires the compilation of source files into Move
Bytecode. It contains only necessary information about the module, its members, and types, and
excludes comments and some identifiers (for example, for constants).

To demonstrate these features, let's replace the contents of the *sources/hello\_world.move* file
with the following:

```move
/// The module `hello_world` under named address `hello_world`.  
/// The named address is set in the `Move.toml`.  
module hello_world::hello_world;  
  
// Imports the `String` type from the Standard Library  
use std::string::String;  
  
/// Returns the "Hello World!" as a `String`.  
public fun hello_world(): String {  
    b"Hello, World!".to_string()  
}
```

During compilation, the code is built, but not run. A compiled package only includes functions that
can be called by other modules or in a transaction. We will explain these concepts in the
[Concepts](/concepts/) chapter. But now, let's see what happens when we run the *sui move build*.

```move
# run from the `hello_world` folder  
$ sui move build  
  
# alternatively, if you didn't `cd` into it  
$ sui move build --path hello_world
```

It should output the following message on your console.

```move
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git  
INCLUDING DEPENDENCY Bridge  
INCLUDING DEPENDENCY DeepBook  
INCLUDING DEPENDENCY SuiSystem  
INCLUDING DEPENDENCY Sui  
INCLUDING DEPENDENCY MoveStdlib  
BUILDING hello_world
```

During the compilation, Move Compiler automatically creates a build folder where it places all
fetched and compiled dependencies as well as the bytecode for the modules of the current package.

> If you're using a versioning system, such as Git, build folder should be ignored. For example, you
> should use a .gitignore file and add build to it.

## Running Tests[​](#running-tests "Direct link to Running Tests")

Before we get to testing, we should add a test. Move Compiler supports tests written in Move and
provides the execution environment. The tests can be placed in both the source files and in the
tests/ folder. Tests are marked with the #[test] attribute and are automatically discovered by
the compiler. We explain tests in depth in the [Testing](/move-basics/testing) section.

Replace the contents of the tests/hello\_world\_tests.move with the following content:

```move
#[test_only]  
module hello_world::hello_world_tests;  
  
use std::unit_test::assert_eq;  
  
use hello_world::hello_world;  
  
#[test]  
fun test_hello_world() {  
    assert_eq!(hello_world::hello_world(), b"Hello, World!".to_string());  
}
```

Here we import the hello\_world module, and call its hello\_world function to test that the output
is indeed the string "Hello, World!". Now, that we have tests in place, let's compile the package in
the test mode and run tests. Move CLI has the test command for this:

```move
$ sui move test
```

The output should be similar to the following:

```move
INCLUDING DEPENDENCY Bridge  
INCLUDING DEPENDENCY DeepBook  
INCLUDING DEPENDENCY SuiSystem  
INCLUDING DEPENDENCY Sui  
INCLUDING DEPENDENCY MoveStdlib  
BUILDING hello_world  
Running Move unit tests  
[ PASS    ] 0x0::hello_world_tests::test_hello_world  
Test result: OK. Total tests: 1; passed: 1; failed: 0
```

If you're running the tests outside of the package folder, you can specify the path to the package:

```move
$ sui move test --path hello_world
```

You can also run a single or multiple tests at once by specifying a string. All the tests names
containing the string will be run:

```move
$ sui move test test_hello
```

## Next Steps[​](#next-steps "Direct link to Next Steps")

In this section, we explained the basics of a Move package: its structure, the manifest, the build,
and test flows. [On the next page](/your-first-move/hello-sui), we will write an application and see how the code
is structured and what the language can do.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Package Manifest](/concepts/manifest) section
* Package in [The Move Reference](/reference/packages)

* [Create a New Package](#create-a-new-package)
* [Directory Structure](#directory-structure)
  + [Manifest](#manifest)
  + [Sources](#sources)
  + [Tests](#tests)
  + [Other Folders](#other-folders)
* [Compiling the Package](#compiling-the-package)
* [Running Tests](#running-tests)
* [Next Steps](#next-steps)
* [Further Reading](#further-reading)
Hello, Sui! | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Hello, Sui!

In the [previous section](/your-first-move/hello-world) we created a new package and demonstrated the basic flow
of creating, building, and testing a Move package. In this section, we will write a simple
application that uses the storage model and can be interacted with. To do this, we will create a
simple todo list application.

## Create a New Package[​](#create-a-new-package "Direct link to Create a New Package")

Following the same flow as in [Hello, World!](/your-first-move/hello-world), we will create a new package called
todo\_list.

```move
$ sui move new todo_list
```

## Add the Code[​](#add-the-code "Direct link to Add the Code")

To speed things up and focus on the application logic, we will provide the code for the todo list
application. Replace the contents of the *sources/todo\_list.move* file with the following code:

> Note: while the contents may seem overwhelming at first, we will break it down in the following
> sections. Try to focus on what's at hand right now.

```move
/// Module: todo_list  
module todo_list::todo_list;  
  
use std::string::String;  
  
/// List of todos. Can be managed by the owner and shared with others.  
public struct TodoList has key, store {  
    id: UID,  
    items: vector<String>  
}  
  
/// Create a new todo list.  
public fun new(ctx: &mut TxContext): TodoList {  
    let list = TodoList {  
        id: object::new(ctx),  
        items: vector[]  
    };  
  
    (list)  
}  
  
/// Add a new todo item to the list.  
public fun add(list: &mut TodoList, item: String) {  
    list.items.push_back(item);  
}  
  
/// Remove a todo item from the list by index.  
public fun remove(list: &mut TodoList, index: u64): String {  
    list.items.remove(index)  
}  
  
/// Delete the list and the capability to manage it.  
public fun delete(list: TodoList) {  
    let TodoList { id, items: _ } = list;  
    id.delete();  
}  
  
/// Get the number of items in the list.  
public fun length(list: &TodoList): u64 {  
    list.items.length()  
}
```

## Build the Package[​](#build-the-package "Direct link to Build the Package")

To make sure that we did everything correctly, let's build the package by running the
sui move build command. If everything is correct, you should see the output similar to the
following:

```move
$ sui move build  
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git  
INCLUDING DEPENDENCY Bridge  
INCLUDING DEPENDENCY DeepBook  
INCLUDING DEPENDENCY SuiSystem  
INCLUDING DEPENDENCY Sui  
INCLUDING DEPENDENCY MoveStdlib  
BUILDING todo_list
```

If there are no errors following this output, you have successfully built the package. If there are
errors, make sure that:

* The code is copied correctly
* The file name and the package name is correct

There are not many other reasons for the code to fail at this stage. But if you are still having
issues, try looking up the structure of the package in
[this location](https://github.com/MystenLabs/move-book/tree/main/packages/todo_list).

## Set Up an Account[​](#set-up-an-account "Direct link to Set Up an Account")

> If you already have an account set up, you can skip this step.

To publish and interact with the package, we need to set up an account. While developing, the best
option for doing so is to run your own
[Local Network](https://docs.sui.io/guides/developer/getting-started/local-network). For now you
just need to run RUST\_LOG="off,sui\_node=info" sui start --with-faucet --force-regenesis. The Sui
Local Network will run on port 9000 of your machine, so make sure that the port isn’t being used by
any other application.

If you are doing it for the first time, you will need to create a new account. To do this, run the
sui client command, then the CLI will prompt you with multiple questions. The answers are marked
below with >:

```move
$ sui client  
Config file ["/path/to/home/.sui/sui_config/client.yaml"] doesn't exist, do you want to connect to a Sui Full node server [y/N]?  
> y  
Sui Full node server URL (Defaults to Sui Testnet if not specified) :  
> http://127.0.0.1:9000  
Environment alias for [http://127.0.0.1:9000] :  
> localnet  
Select key scheme to generate keypair (0 for ed25519, 1 for secp256k1, 2: for secp256r1):  
> 0
```

After you have answered the questions, the CLI will generate a new keypair and save it to the
configuration file. You can now use this account to interact with the network.

To check that we have the account set up correctly, run the sui client active-address command:

```move
$ sui client active-address  
0x....
```

The command will output the address of your account, it starts with 0x followed by 64 characters.

## Requesting Coins[​](#requesting-coins "Direct link to Requesting Coins")

In *devnet* and *testnet* environments, the CLI provides a way to request coins to your account, so
you can interact with the network. To request coins, run the sui client faucet command:

```move
$ sui client faucet  
Request successful. It can take up to 1 minute to get the coin. Run sui client gas to check your gas coins.
```

After waiting a little bit, you can check that the Coin object was sent to your account by running
the sui client balance command:

```move
$ sui client balance  
╭────────────────────────────────────────╮  
│ Balance of coins owned by this address │  
├────────────────────────────────────────┤  
│ ╭──────────────────────────────────╮   │  
│ │ coin  balance (raw)  balance     │   │  
│ ├──────────────────────────────────┤   │  
│ │ Sui   1000000000    1.00 SUI     │   │  
│ ╰──────────────────────────────────╯   │  
╰────────────────────────────────────────╯
```

Alternatively, you can query *objects* owned by your account, by running the sui client objects
command. The actual output will be different, because the object ID is unique, and so is digest, but
the structure will be similar:

```move
$ sui client objects  
╭───────────────────────────────────────────────────────────────────────────────────────╮  
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │  
│ │ objectId   │  0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de  │ │  
│ │ version    │  4                                                                   │ │  
│ │ digest     │  nA68oa8gab/CdIRw+240wze8u0P+sRe4vcisbENcR4U=                        │ │  
│ │ objectType │  0x0000..0002::coin::Coin                                            │ │  
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │  
╰───────────────────────────────────────────────────────────────────────────────────────╯
```

Now that we have the account set up and the coins in the account, we can interact with the network.
We will start by publishing the package to the network.

## Publish[​](#publish "Direct link to Publish")

To publish the package to the network, we will use the sui client publish command. The command
will automatically build the package and use its bytecode to publish in a single transaction.

> We are using the --gas-budget argument during publishing. It specifies how much gas we are
> willing to spend on the transaction. We won't touch on this topic in this section, but it's
> important to know that every transaction in Sui costs gas, and the gas is paid in SUI coins.
> It is worth noting that --gas-budget is not a required parameter. When you do not set it,
> there will be a default consumption limit.

The gas-budget is specified in *MISTs*. 1 SUI equals 10^9 MISTs. For the sake of demonstration, we
will use 100,000,000 MISTs, which is 0.1 SUI.

```move
# run this from the `todo_list` folder  
$ sui client publish --gas-budget 100000000  
  
# alternatively, you can specify path to the package  
$ sui client publish --gas-budget 100000000 todo_list
```

The output of the publish command is rather lengthy, so we will show and explain it in parts.

```move
$ sui client publish --gas-budget 100000000  
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git  
INCLUDING DEPENDENCY Bridge  
INCLUDING DEPENDENCY DeepBook  
INCLUDING DEPENDENCY SuiSystem  
INCLUDING DEPENDENCY Sui  
INCLUDING DEPENDENCY MoveStdlib  
BUILDING todo_list  
Successfully verified dependencies on-chain against source.  
Transaction Digest: GpcDV6JjjGQMRwHpEz582qsd5MpCYgSwrDAq1JXcpFjW
```

As you can see, when we run the publish command, the CLI first builds the package, then verifies
the dependencies on-chain, and finally publishes the package. The output of the command is the
transaction digest, which is a unique identifier of the transaction and can be used to query the
transaction status.

### Transaction Data[​](#transaction-data "Direct link to Transaction Data")

The section titled TransactionData contains the information about the transaction we just sent. It
features fields like sender, which is your address, the gas\_budget set with the --gas-budget
argument, and the Coin we used for payment. It also prints the Commands that were run by the CLI. In
this example, the commands Publish and TransferObject were run - the latter transfers a special
object UpgradeCap to the sender.

```move
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮  
│ Transaction Data                                                                                             │  
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤  
│ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                   │  
│ Gas Owner: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                │  
│ Gas Budget: 100000000 MIST                                                                                   │  
│ Gas Price: 1000 MIST                                                                                         │  
│ Gas Payment:                                                                                                 │  
│  ┌──                                                                                                         │  
│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                                    │  
│  │ Version: 7                                                                                                │  
│  │ Digest: AXYPnups8A5J6pkvLa6RekX2ye3qur66EZ88mEbaUDQ1                                                      │  
│  └──                                                                                                         │  
│                                                                                                              │  
│ Transaction Kind: Programmable                                                                               │  
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │  
│ │ Input Objects                                                                                            │ │  
│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │  
│ │ 0   Pure Arg: Type: address, Value: "0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1" │ │  
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │  
│ ╭─────────────────────────────────────────────────────────────────────────╮                                  │  
│ │ Commands                                                                │                                  │  
│ ├─────────────────────────────────────────────────────────────────────────┤                                  │  
│ │ 0  Publish:                                                             │                                  │  
│ │  ┌                                                                      │                                  │  
│ │  │ Dependencies:                                                        │                                  │  
│ │  │   0x0000000000000000000000000000000000000000000000000000000000000001 │                                  │  
│ │  │   0x0000000000000000000000000000000000000000000000000000000000000002 │                                  │  
│ │  └                                                                      │                                  │  
│ │                                                                         │                                  │  
│ │ 1  TransferObjects:                                                     │                                  │  
│ │  ┌                                                                      │                                  │  
│ │  │ Arguments:                                                           │                                  │  
│ │  │   Result 0                                                           │                                  │  
│ │  │ Address: Input  0                                                    │                                  │  
│ │  └                                                                      │                                  │  
│ ╰─────────────────────────────────────────────────────────────────────────╯                                  │  
│                                                                                                              │  
│ Signatures:                                                                                                  │  
│    gebjSbVwZwTkizfYg2XIuzdx+d66VxFz8EmVaisVFiV3GkDay6L+hQG3n2CQ1hrWphP6ZLc7bd1WRq4ss+hQAQ==                  │  
│                                                                                                              │  
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

### Transaction Effects[​](#transaction-effects "Direct link to Transaction Effects")

Transaction Effects contains the status of the transaction, the changes that the transaction made to
the state of the network and the objects involved in the transaction.

```move
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮  
│ Transaction Effects                                                                               │  
├───────────────────────────────────────────────────────────────────────────────────────────────────┤  
│ Digest: GpcDV6JjjGQMRwHpEz582qsd5MpCYgSwrDAq1JXcpFjW                                              │  
│ Status: Success                                                                                   │  
│ Executed Epoch: 411                                                                               │  
│                                                                                                   │  
│ Created Objects:                                                                                  │  
│  ┌──                                                                                              │  
│  │ ID: 0x160f7856e13b27e5a025112f361370f4efc2c2659cb0023f1e99a8a84d1652f3                         │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │  
│  │ Version: 8                                                                                     │  
│  │ Digest: 8y6bhwvQrGJHDckUZmj2HDAjfkyVqHohhvY1Fvzyj7ec                                           │  
│  └──                                                                                              │  
│  ┌──                                                                                              │  
│  │ ID: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe                         │  
│  │ Owner: Immutable                                                                               │  
│  │ Version: 1                                                                                     │  
│  │ Digest: Ein91NF2hc3qC4XYoMUFMfin9U23xQmDAdEMSHLae7MK                                           │  
│  └──                                                                                              │  
│ Mutated Objects:                                                                                  │  
│  ┌──                                                                                              │  
│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                         │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │  
│  │ Version: 8                                                                                     │  
│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                           │  
│  └──                                                                                              │  
│ Gas Object:                                                                                       │  
│  ┌──                                                                                              │  
│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                         │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │  
│  │ Version: 8                                                                                     │  
│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                           │  
│  └──                                                                                              │  
│ Gas Cost Summary:                                                                                 │  
│    Storage Cost: 10404400 MIST                                                                    │  
│    Computation Cost: 1000000 MIST                                                                 │  
│    Storage Rebate: 978120 MIST                                                                    │  
│    Non-refundable Storage Fee: 9880 MIST                                                          │  
│                                                                                                   │  
│ Transaction Dependencies:                                                                         │  
│    7Ukrc5GqdFqTA41wvWgreCdHn2vRLfgQ3YMFkdks72Vk                                                   │  
│    7d4amuHGhjtYKujEs9YkJARzNEn4mRbWWv3fn4cdKdyh                                                   │  
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
```

### Events[​](#events "Direct link to Events")

If there were any *events* emitted, you would see them in this section. Our package does not use
events, so the section is empty.

```move
╭─────────────────────────────╮  
│ No transaction block events │  
╰─────────────────────────────╯
```

### Object Changes[​](#object-changes "Direct link to Object Changes")

These are the changes to *objects* that transaction has made. In our case, we have *created* a new
UpgradeCap object which is a special object that allows the sender to upgrade the package in the
future, *mutated* the Gas object, and *published* a new package. Packages are also objects on Sui.

```move
╭──────────────────────────────────────────────────────────────────────────────────────────────────╮  
│ Object Changes                                                                                   │  
├──────────────────────────────────────────────────────────────────────────────────────────────────┤  
│ Created Objects:                                                                                 │  
│  ┌──                                                                                             │  
│  │ ObjectID: 0x160f7856e13b27e5a025112f361370f4efc2c2659cb0023f1e99a8a84d1652f3                  │  
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                    │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 ) │  
│  │ ObjectType: 0x2::package::UpgradeCap                                                          │  
│  │ Version: 8                                                                                    │  
│  │ Digest: 8y6bhwvQrGJHDckUZmj2HDAjfkyVqHohhvY1Fvzyj7ec                                          │  
│  └──                                                                                             │  
│ Mutated Objects:                                                                                 │  
│  ┌──                                                                                             │  
│  │ ObjectID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                  │  
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                    │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 ) │  
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │  
│  │ Version: 8                                                                                    │  
│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                          │  
│  └──                                                                                             │  
│ Published Objects:                                                                               │  
│  ┌──                                                                                             │  
│  │ PackageID: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe                 │  
│  │ Version: 1                                                                                    │  
│  │ Digest: Ein91NF2hc3qC4XYoMUFMfin9U23xQmDAdEMSHLae7MK                                          │  
│  │ Modules: todo_list                                                                            │  
│  └──                                                                                             │  
╰──────────────────────────────────────────────────────────────────────────────────────────────────╯
```

### Balance Changes[​](#balance-changes "Direct link to Balance Changes")

This last section contains changes to SUI Coins, in our case, we have *spent* around 0.015 SUI,
which in MIST is 10,500,000. You can see it under the *amount* field in the output.

```move
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮  
│ Balance Changes                                                                                   │  
├───────────────────────────────────────────────────────────────────────────────────────────────────┤  
│  ┌──                                                                                              │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │  
│  │ CoinType: 0x2::sui::SUI                                                                        │  
│  │ Amount: -10426280                                                                              │  
│  └──                                                                                              │  
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
```

### Alternative Output[​](#alternative-output "Direct link to Alternative Output")

It is possible to specify the --json flag during publishing to get the output in JSON format. This
is useful if you want to parse the output programmatically or store it for later use.

```move
$ sui client publish --gas-budget 100000000 --json
```

### Using the Results[​](#using-the-results "Direct link to Using the Results")

After the package is published on chain, we can interact with it. To do this, we need to find the
address (object ID) of the package. It's under the Published Objects section of the
Object Changes output. The address is unique for each package, so you will need to copy it from
the output.

In this example, the address is:

```move
0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe
```

Now that we have the address, we can interact with the package. In the next section, we will show
how to interact with the package by sending transactions.

## Sending Transactions[​](#sending-transactions "Direct link to Sending Transactions")

To demonstrate the interaction with the todo\_list package, we will send a transaction to create a
new list and add an item to it. Transactions are sent via the sui client ptb command, it allows
using the [Transaction Blocks](/concepts/what-is-a-transaction) at full capacity. The command
may look big and complex, but we go through it step by step.

### Prepare the Variables[​](#prepare-the-variables "Direct link to Prepare the Variables")

Before we construct the command, let's store the values we will use in the transaction. Replace the
0x4.... with the address of the package you have published. And MY\_ADDRESS variable will be
automatically set to your address from the CLI output.

```move
$ export PACKAGE_ID=0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe  
$ export MY_ADDRESS=$(sui client active-address)
```

### Building the Transaction in CLI[​](#building-the-transaction-in-cli "Direct link to Building the Transaction in CLI")

Now to building an actual transaction. The transaction will consist of two parts: we will call the
new function in the todo\_list package to create a new list, and then we will transfer the list
object to our account. The transaction will look like this:

```move
$ sui client ptb \  
--gas-budget 100000000 \  
--assign sender @$MY_ADDRESS \  
--move-call $PACKAGE_ID::todo_list::new \  
--assign list \  
--transfer-objects "[list]" sender
```

In this command, we are using the ptb subcommand to build a transaction. Parameters that follow it
define the actual commands and actions that the transaction will perform. The first two calls we
make are utility calls to set the sender address to the command inputs and set the gas budget for
the transaction.

```move
# sets the gas budget for the transaction  
--gas-budget 100000000 \n  
# registers a variable "sender=@..."  
--assign sender @$MY_ADDRESS \n
```

Then we perform the actual call to a function in the package. We use the --move-call followed by
the package ID, the module name, and the function name. In this case, we are calling the new
function in the todo\_list package.

```move
# calls the "new" function in the "todo_list" package under the $PACKAGE_ID address  
--move-call $PACKAGE_ID::todo_list::new
```

The function that we defined actually returns a value, which we want to store. We use the
--assign command to give a name to the returned value. In this case, we are calling it list. And
then we transfer the object to our account.

```move
--move-call $PACKAGE_ID::todo_list::new \  
# assigns the result of the "new" function to the "list" variable (from the previous step)  
--assign list \  
# transfers the object to the sender  
--transfer-objects "[list]" sender
```

Once the command is constructed, you can run it in the terminal. If everything is correct, you
should see the output similar to the one we had in previous sections. The output will contain the
transaction digest, the transaction data, and the transaction effects.

Spoiler: Full transaction output

```move
Transaction Digest: BJwYEnuuMzU4Y8cTwMoJbbQA6cLwPmwxvsRpSmvThoK8  
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮  
│ Transaction Data                                                                                             │  
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤  
│ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                   │  
│ Gas Owner: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                │  
│ Gas Budget: 100000000 MIST                                                                                  │  
│ Gas Price: 1000 MIST                                                                                         │  
│ Gas Payment:                                                                                                 │  
│  ┌──                                                                                                         │  
│  │ ID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                                    │  
│  │ Version: 22                                                                                               │  
│  │ Digest: DiBrBMshDiD9cThpaEgpcYSF76uV4hCoE1qRyQ3rnYCB                                                      │  
│  └──                                                                                                         │  
│                                                                                                              │  
│ Transaction Kind: Programmable                                                                               │  
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │  
│ │ Input Objects                                                                                            │ │  
│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │  
│ │ 0   Pure Arg: Type: address, Value: "0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1" │ │  
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │  
│ ╭──────────────────────────────────────────────────────────────────────────────────╮                         │  
│ │ Commands                                                                         │                         │  
│ ├──────────────────────────────────────────────────────────────────────────────────┤                         │  
│ │ 0  MoveCall:                                                                     │                         │  
│ │  ┌                                                                               │                         │  
│ │  │ Function:  new                                                                │                         │  
│ │  │ Module:    todo_list                                                          │                         │  
│ │  │ Package:   0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe │                         │  
│ │  └                                                                               │                         │  
│ │                                                                                  │                         │  
│ │ 1  TransferObjects:                                                              │                         │  
│ │  ┌                                                                               │                         │  
│ │  │ Arguments:                                                                    │                         │  
│ │  │   Result 0                                                                    │                         │  
│ │  │ Address: Input  0                                                             │                         │  
│ │  └                                                                               │                         │  
│ ╰──────────────────────────────────────────────────────────────────────────────────╯                         │  
│                                                                                                              │  
│ Signatures:                                                                                                  │  
│    C5Lie4dtP5d3OkKzFBa+xM0BiNoB/A4ItthDCRTRBUrEE+jXeNs7mP4AuGwi3nzfTskh29+R1j1Kba4Wdy3QDA==                  │  
│                                                                                                              │  
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯  
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮  
│ Transaction Effects                                                                               │  
├───────────────────────────────────────────────────────────────────────────────────────────────────┤  
│ Digest: BJwYEnuuMzU4Y8cTwMoJbbQA6cLwPmwxvsRpSmvThoK8                                              │  
│ Status: Success                                                                                   │  
│ Executed Epoch: 1213                                                                              │  
│                                                                                                   │  
│ Created Objects:                                                                                  │  
│  ┌──                                                                                              │  
│  │ ID: 0x74973c4ea2e78dc409f60481e23761cee68a48156df93a93fbcceb77d1cacdf6                         │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │  
│  │ Version: 23                                                                                    │  
│  │ Digest: DuHTozDHMsuA7cFnWRQ1Gb8FQghAEBaj3inasJxqYq1c                                           │  
│  └──                                                                                              │  
│ Mutated Objects:                                                                                  │  
│  ┌──                                                                                              │  
│  │ ID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                         │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │  
│  │ Version: 23                                                                                    │  
│  │ Digest: 82fwKarGuDhtomr5oS6ZGNvZNw9QVXLSbPdQu6jQgNV7                                           │  
│  └──                                                                                              │  
│ Gas Object:                                                                                       │  
│  ┌──                                                                                              │  
│  │ ID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                         │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │  
│  │ Version: 23                                                                                    │  
│  │ Digest: 82fwKarGuDhtomr5oS6ZGNvZNw9QVXLSbPdQu6jQgNV7                                           │  
│  └──                                                                                              │  
│ Gas Cost Summary:                                                                                 │  
│    Storage Cost: 2318000 MIST                                                                     │  
│    Computation Cost: 1000000 MIST                                                                 │  
│    Storage Rebate: 978120 MIST                                                                    │  
│    Non-refundable Storage Fee: 9880 MIST                                                          │  
│                                                                                                   │  
│ Transaction Dependencies:                                                                         │  
│    FSz2fYXmKqTf77mFXNq5JK7cKY8agWja7V5yDKEgL8c3                                                   │  
│    GgMZKTt482DYApbAZkPDtdssGHZLbxgjm2uMXhzJax8Q                                                   │  
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯  
╭─────────────────────────────╮  
│ No transaction block events │  
╰─────────────────────────────╯  
  
╭───────────────────────────────────────────────────────────────────────────────────────────────────────╮  
│ Object Changes                                                                                        │  
├───────────────────────────────────────────────────────────────────────────────────────────────────────┤  
│ Created Objects:                                                                                      │  
│  ┌──                                                                                                  │  
│  │ ObjectID: 0x74973c4ea2e78dc409f60481e23761cee68a48156df93a93fbcceb77d1cacdf6                       │  
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │  
│  │ ObjectType: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │  
│  │ Version: 23                                                                                        │  
│  │ Digest: DuHTozDHMsuA7cFnWRQ1Gb8FQghAEBaj3inasJxqYq1c                                               │  
│  └──                                                                                                  │  
│ Mutated Objects:                                                                                      │  
│  ┌──                                                                                                  │  
│  │ ObjectID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                       │  
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │  
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                         │  
│  │ Version: 23                                                                                        │  
│  │ Digest: 82fwKarGuDhtomr5oS6ZGNvZNw9QVXLSbPdQu6jQgNV7                                               │  
│  └──                                                                                                  │  
╰───────────────────────────────────────────────────────────────────────────────────────────────────────╯  
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮  
│ Balance Changes                                                                                   │  
├───────────────────────────────────────────────────────────────────────────────────────────────────┤  
│  ┌──                                                                                              │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │  
│  │ CoinType: 0x2::sui::SUI                                                                        │  
│  │ Amount: -2339880                                                                               │  
│  └──                                                                                              │  
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
```

The section that we want to focus on is the "Object Changes". More specifically, the "Created
Objects" part of it. It contains the object ID, the type and the version of the TodoList that you
have created. We will use this object ID to interact with the list.

```move
╭───────────────────────────────────────────────────────────────────────────────────────────────────────╮  
│ Object Changes                                                                                        │  
├───────────────────────────────────────────────────────────────────────────────────────────────────────┤  
│ Created Objects:                                                                                      │  
│  ┌──                                                                                                  │  
│  │ ObjectID: 0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553                       │  
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │  
│  │ ObjectType: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │  
│  │ Version: 22                                                                                        │  
│  │ Digest: HyWdUpjuhjLY38dLpg6KPHQ3bt4BqQAbdF5gB8HQdEqG                                               │  
│  └──                                                                                                  │  
│ Mutated Objects:                                                                                      │  
│  ┌──                                                                                                  │  
│  │ ObjectID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                       │  
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │  
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │  
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                         │  
│  │ Version: 22                                                                                        │  
│  │ Digest: DiBrBMshDiD9cThpaEgpcYSF76uV4hCoE1qRyQ3rnYCB                                               │  
│  └──                                                                                                  │  
╰───────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

In this example the object ID is
0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553. And the owner should be your
account address. We achieved this by transferring the object to the sender in the last command of
the transaction.

Another way to test that you have successfully created the list is to check the account objects.

```move
$ sui client objects
```

It should have an object that looks similar to this:

```move
╭  ...                                                                                  ╮  
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │  
│ │ objectId   │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553  │ │  
│ │ version    │  22                                                                  │ │  
│ │ digest     │  /DUEiCLkaNSgzpZSq2vSV0auQQEQhyH9occq9grMBZM=                        │ │  
│ │ objectType │  0x468d..29fe::todo_list::TodoList                                   │ │  
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │  
|  ...                                                                                  |
```

### Passing Objects to Functions[​](#passing-objects-to-functions "Direct link to Passing Objects to Functions")

The TodoList that we created in the previous step is an object that you can interact with as its
owner. You can call functions defined in the todo\_list module on this object. To demonstrate this,
we will add an item to the list. First, we will add just one item, and in the second transaction we
will add 3 and remove another one.

Double check that you have variables set up [from the previous step](#prepare-the-variables), and
then add one more variable for the list object.

```move
$ export LIST_ID=0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553
```

Now we can construct the transaction to add an item to the list. The command will look like this:

```move
$ sui client ptb \  
--gas-budget 100000000 \  
--move-call $PACKAGE_ID::todo_list::add @$LIST_ID "'Finish the Hello, Sui chapter'"
```

In this command, we are calling the add function in the todo\_list package. The function takes
two arguments: the list object and the item to add. The item is a string, so we need to wrap it in
single quotes. The command will add the item to the list.

If everything is correct, you should see the output similar to the one we had in previous sections.
Now you can check the list object to see if the item was added.

```move
$ sui client object $LIST_ID
```

The output should contain the item that you have added.

```move
╭───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮  
│ objectId      │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553                                               │  
│ version       │  24                                                                                                               │  
│ digest        │  FGcXH8MGpMs5BdTnC62CQ3VLAwwexYg2id5DKU7Jr9aQ                                                                     │  
│ objType       │  0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList                          │  
│ owner         │ ╭──────────────┬──────────────────────────────────────────────────────────────────────╮                           │  
│               │ │ AddressOwner │  0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1  │                           │  
│               │ ╰──────────────┴──────────────────────────────────────────────────────────────────────╯                           │  
│ prevTx        │  EJVK6FEHtfTdCuGkNsU1HcrmUBEN6H6jshfcptnw8Yt1                                                                     │  
│ storageRebate │  1558000                                                                                                          │  
│ content       │ ╭───────────────────┬───────────────────────────────────────────────────────────────────────────────────────────╮ │  
│               │ │ dataType          │  moveObject                                                                               │ │  
│               │ │ type              │  0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │ │  
│               │ │ hasPublicTransfer │  true                                                                                     │ │  
│               │ │ fields            │ ╭───────┬───────────────────────────────────────────────────────────────────────────────╮ │ │  
│               │ │                   │ │ id    │ ╭────┬──────────────────────────────────────────────────────────────────────╮ │ │ │  
│               │ │                   │ │       │ │ id │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553  │ │ │ │  
│               │ │                   │ │       │ ╰────┴──────────────────────────────────────────────────────────────────────╯ │ │ │  
│               │ │                   │ │ items │ ╭─────────────────────────────────╮                                           │ │ │  
│               │ │                   │ │       │ │  finish the Hello, Sui chapter  │                                           │ │ │  
│               │ │                   │ │       │ ╰─────────────────────────────────╯                                           │ │ │  
│               │ │                   │ ╰───────┴───────────────────────────────────────────────────────────────────────────────╯ │ │  
│               │ ╰───────────────────┴───────────────────────────────────────────────────────────────────────────────────────────╯ │  
╰───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

A JSON representation of the object can be obtained by adding the --json flag to the command.

```move
$ sui client object $LIST_ID --json
```

```move
{  
  "objectId": "0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553",  
  "version": "24",  
  "digest": "FGcXH8MGpMs5BdTnC62CQ3VLAwwexYg2id5DKU7Jr9aQ",  
  "type": "0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList",  
  "owner": {  
    "AddressOwner": "0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1"  
  },  
  "previousTransaction": "EJVK6FEHtfTdCuGkNsU1HcrmUBEN6H6jshfcptnw8Yt1",  
  "storageRebate": "1558000",  
  "content": {  
    "dataType": "moveObject",  
    "type": "0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList",  
    "hasPublicTransfer": true,  
    "fields": {  
      "id": {  
        "id": "0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553"  
      },  
      "items": ["Finish the Hello, Sui chapter"]  
    }  
  }  
}
```

### Chaining Commands[​](#chaining-commands "Direct link to Chaining Commands")

You can chain multiple commands in a single transaction. This shows the power of Transaction Blocks!
Using the same list object, we will add three more items and remove one. The command will look like
this:

```move
$ sui client ptb \  
--gas-budget 100000000 \  
--move-call $PACKAGE_ID::todo_list::add @$LIST_ID "'Finish Concepts chapter'" \  
--move-call $PACKAGE_ID::todo_list::add @$LIST_ID "'Read the Move Basics chapter'" \  
--move-call $PACKAGE_ID::todo_list::add @$LIST_ID "'Learn about Object Model'" \  
--move-call $PACKAGE_ID::todo_list::remove @$LIST_ID 0
```

If previous commands were successful, this one should not be any different. You can check the list
object to see if the items were added and removed. The JSON representation is a bit more readable!

```move
sui client object $LIST_ID --json
```

```move
{  
  "objectId": "0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553",  
  "version": "25",  
  "digest": "EDTXDsteqPGAGu4zFAj5bbQGTkucWk4hhuUquk39enGA",  
  "type": "0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList",  
  "owner": {  
    "AddressOwner": "0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1"  
  },  
  "previousTransaction": "7SXLGBSh31jv8G7okQ9mEgnw5MnTfvzzHEHpWf3Sa9gY",  
  "storageRebate": "1922800",  
  "content": {  
    "dataType": "moveObject",  
    "type": "0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList",  
    "hasPublicTransfer": true,  
    "fields": {  
      "id": {  
        "id": "0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553"  
      },  
      "items": [  
        "Finish Concepts chapter",  
        "Read the Move Basics chapter",  
        "Learn about Object Model"  
      ]  
    }  
  }  
}
```

Commands don't have to be in the same package or operate on the same object. Within a single
transaction block, you can interact with multiple packages and objects. This is a powerful feature
that allows you to build complex interactions on-chain!

## Conclusion[​](#conclusion "Direct link to Conclusion")

In this guide, we have shown how to publish a package on the Move blockchain and interact with it
using the Sui CLI. We have demonstrated how to create a new list object, add items to it, and remove
them. We have also shown how to chain multiple commands in a single transaction block. This guide
should give you a good starting point for building your own applications on the Sui blockchain!

* [Create a New Package](#create-a-new-package)
* [Add the Code](#add-the-code)
* [Build the Package](#build-the-package)
* [Set Up an Account](#set-up-an-account)
* [Requesting Coins](#requesting-coins)
* [Publish](#publish)
  + [Transaction Data](#transaction-data)
  + [Transaction Effects](#transaction-effects)
  + [Events](#events)
  + [Object Changes](#object-changes)
  + [Balance Changes](#balance-changes)
  + [Alternative Output](#alternative-output)
  + [Using the Results](#using-the-results)
* [Sending Transactions](#sending-transactions)
  + [Prepare the Variables](#prepare-the-variables)
  + [Building the Transaction in CLI](#building-the-transaction-in-cli)
  + [Passing Objects to Functions](#passing-objects-to-functions)
  + [Chaining Commands](#chaining-commands)
* [Conclusion](#conclusion)
Concepts | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Concepts

In this chapter you will learn about the basic concepts of Sui and Move. You will learn what is a
package, how to interact with it, what is an account and a transaction, and how data is stored on
Sui. While this chapter is not a complete reference, and you should refer to the
[Sui Documentation](https://docs.sui.io) for that, it will give you a good understanding of the
basic concepts required to write Move programs on Sui.
Package | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Package

Move is a language for writing smart contracts - programs that are stored and run on the blockchain.
A single program is organized into a package. A package is published on the blockchain and is
identified by an [address](/concepts/address). A published package can be interacted with by sending
[transactions](/concepts/what-is-a-transaction) calling its functions. It can also act as a dependency for
other packages.

> To create a new package, use the sui move new command. To learn more about the command, run
> sui move new --help.

Package consists of modules - separate scopes that contain functions, types, and other items.

```move
package 0x...  
    module a  
        struct A1  
        fun hello_world()  
    module b  
        struct B1  
        fun hello_package()
```

## Package Structure[​](#package-structure "Direct link to Package Structure")

Locally, a package is a directory with a Move.toml file and a sources directory. The Move.toml
file - called the "package manifest" - contains metadata about the package, and the sources
directory contains the source code for the modules. Package usually looks like this:

```move
sources/  
    my_module.move  
    another_module.move  
    ...  
tests/  
    ...  
examples/  
    using_my_module.move  
Move.toml
```

The tests directory is optional and contains tests for the package. Code placed into the tests
directory is not published on-chain and is only available in tests. The examples directory can be
used for code examples, and is also not published on-chain.

## Published Package[​](#published-package "Direct link to Published Package")

During development, package doesn't have an address and it needs to be set to 0x0. Once a package
is published, it gets a single unique [address](/concepts/address) on the blockchain containing its modules'
bytecode. A published package becomes *immutable* and can be interacted with by sending
transactions.

```move
0x...  
    my_module: <bytecode>  
    another_module: <bytecode>
```

## Links[​](#links "Direct link to Links")

* [Package Manifest](/concepts/manifest)
* [Address](/concepts/address)
* [Packages](/reference/packages) in the Move Reference.

* [Package Structure](#package-structure)
* [Published Package](#published-package)
* [Links](#links)
Package Manifest | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Package Manifest

The Move.toml is a manifest file that describes the [package](/concepts/packages) and its dependencies.
It is written in [TOML](https://toml.io/en/) format and contains multiple sections, the most
important of which are [package], [dependencies] and [addresses].

```move
[package]  
name = "my_project"  
version = "0.0.0"  
edition = "2024"  
  
[dependencies]  
Example = { git = "https://github.com/example/example.git", subdir = "path/to/package", rev = "framework/testnet" }  
  
[addresses]  
std =  "0x1"  
alice = "0xA11CE"  
  
[dev-addresses]  
alice = "0xB0B"
```

## Sections[​](#sections "Direct link to Sections")

### Package[​](#package "Direct link to Package")

The [package] section is used to describe the package. None of the fields in this section are
published on chain, but they are used in tooling and release management; they also specify the Move
edition for the compiler.

* name - the name of the package when it is imported;
* version - the version of the package, can be used in release management;
* edition - the edition of the Move language; currently, the only valid value is 2024.

### Dependencies[​](#dependencies "Direct link to Dependencies")

The [dependencies] section is used to specify the dependencies of the project. Each dependency is
specified as a key-value pair, where the key is the name of the dependency, and the value is the
dependency specification. The dependency specification can be a git repository URL or a path to the
local directory.

```move
# git repository  
Example = { git = "https://github.com/example/example.git", subdir = "path/to/package", rev = "framework/testnet" }  
  
# local directory  
MyPackage = { local = "../my-package" }
```

Packages also import addresses from other packages. For example, the Sui dependency adds the std
and sui addresses to the project. These addresses can be used in the code as aliases for the
addresses.

Starting with version 1.45 of the Sui CLI, the Sui system packages (std, sui, system,
bridge, and deepbook) are automatically added as dependencies if none of them are explicitly
listed.

### Resolving Version Conflicts with Override[​](#resolving-version-conflicts-with-override "Direct link to Resolving Version Conflicts with Override")

Sometimes dependencies have conflicting versions of the same package. For example, if you have two
dependencies that use different versions of the Example package, you can override the dependency in
the [dependencies] section. To do so, add the override field to the dependency. The version of
the dependency specified in the [dependencies] section will be used instead of the one specified
in the dependency itself.

```move
[dependencies]  
Example = { override = true, git = "https://github.com/example/example.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }
```

### Dev-dependencies[​](#dev-dependencies "Direct link to Dev-dependencies")

It is possible to add [dev-dependencies] section to the manifest. It is used to override
dependencies in the dev and test modes. For example, if you want to use a different version of the
Sui package in the dev mode, you can add a custom dependency specification to the
[dev-dependencies] section.

### Addresses[​](#addresses "Direct link to Addresses")

The [addresses] section is used to add aliases for the addresses. Any address can be specified in
this section, and then used in the code as an alias. For example, if you add alice = "0xA11CE" to
this section, you can use alice as 0xA11CE in the code.

### Dev-addresses[​](#dev-addresses "Direct link to Dev-addresses")

The [dev-addresses] section is the same as [addresses], but only works for the test and dev
modes. Important to note that it is impossible to introduce new aliases in this section, only
override the existing ones. So in the example above, if you add alice = "0xB0B" to this section,
the alice address will be 0xB0B in the test and dev modes, and 0xA11CE in the regular build.

## TOML Styles[​](#toml-styles "Direct link to TOML Styles")

The TOML format supports two styles for tables: inline and multiline. The examples above are using
the inline style, but it is also possible to use the multiline style. You wouldn't want to use it
for the [package] section, but it can be useful for the dependencies.

```move
# Inline style  
[dependencies]  
Example = { override = true, git = "https://github.com/example/example.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }  
MyPackage = { local = "../my-package" }
```

```move
# Multiline style  
[dependencies.Example]  
override = true  
git = "https://github.com/example/example.git"  
subdir = "crates/sui-framework/packages/sui-framework"  
rev = "framework/testnet"  
  
[dependencies.MyPackage]  
local = "../my-package"
```

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Packages](/reference/packages) in the Move Reference.

* [Sections](#sections)
  + [Package](#package)
  + [Dependencies](#dependencies)
  + [Resolving Version Conflicts with Override](#resolving-version-conflicts-with-override)
  + [Dev-dependencies](#dev-dependencies)
  + [Addresses](#addresses)
  + [Dev-addresses](#dev-addresses)
* [TOML Styles](#toml-styles)
* [Further Reading](#further-reading)
Address | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Address

Address is a unique identifier of a location on the blockchain. It is used to identify
[packages](/concepts/packages), [accounts](/concepts/what-is-an-account), and [objects](/object/object-model).
Address has a fixed size of 32 bytes and is usually represented as a hexadecimal string prefixed
with 0x. Addresses are case insensitive.

```move
0xe51ff5cd221a81c3d6e22b9e670ddf99004d71de4f769b0312b68c7c4872e2f1
```

The address above is an example of a valid address. It is 64 characters long (32 bytes) and prefixed
with 0x.

Sui also has reserved addresses that are used to identify standard packages and objects. Reserved
addresses are typically simple values that are easy to remember and type. For example, the address
of the Standard Library is 0x1. Addresses, shorter than 32 bytes, are padded with zeros to the
left.

```move
0x1 = 0x0000000000000000000000000000000000000000000000000000000000000001
```

Here are some examples of reserved addresses:

* 0x1 - address of the Sui Standard Library (alias std)
* 0x2 - address of the Sui Framework (alias sui)
* 0x6 - address of the system Clock object

> You can find all reserved addresses in the [Appendix B](/appendix/reserved-addresses).

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Address type](/move-basics/address) in Move
* [sui::address module](https://docs.sui.io/references/framework/sui/address)

* [Further Reading](#further-reading)
Account | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Account

An account is a way to identify a user. An account is generated from a private key, and is
identified by an address. An account can own objects, and can send transactions. Every transaction
has a sender, and the sender is identified by an [address](/concepts/address).

Sui supports multiple cryptographic algorithms for account generation. The two supported curves are
ed25519, secp256k1, and there is also a special way of generating an account - zklogin. The
cryptographic agility - the unique feature of Sui - allows for flexibility in the account
generation.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Cryptography in Sui](https://blog.sui.io/wallet-cryptography-specifications/) in the
  [Sui Blog](https://blog.sui.io)
* [Keys and Addresses](https://docs.sui.io/concepts/cryptography/transaction-auth/keys-addresses) in
  the [Sui Docs](https://docs.sui.io)
* [Signatures](https://docs.sui.io/concepts/cryptography/transaction-auth/signatures) in the
  [Sui Docs](https://docs.sui.io)

* [Further Reading](#further-reading)
Transaction | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Transaction

Transaction is a fundamental concept in the blockchain world. It is a way to interact with a
blockchain. Transactions are used to change the state of the blockchain, and they are the only way
to do so. In Move, transactions are used to call functions in a package, deploy new packages, and
upgrade existing ones.

## Transaction Structure[​](#transaction-structure "Direct link to Transaction Structure")

> Every transaction explicitly specifies the objects it operates on!

Transactions consist of:

* a sender - the [account](/concepts/what-is-an-account) that *signs* the transaction;
* a list (or a chain) of commands - the operations to be executed;
* command inputs - the arguments for the commands: either pure - simple values like numbers or
  strings, or object - objects that the transaction will access;
* a gas object - the Coin object used to pay for the transaction;
* gas price and budget - the cost of the transaction;

## Inputs[​](#inputs "Direct link to Inputs")

Transaction inputs are the arguments for the transaction and are split between 2 types:

* Pure arguments: These are mostly [primitive types](/move-basics/primitive-types) with some extra
  additions. A pure argument can be: - [bool](/move-basics/primitive-types#booleans). -
  [unsigned integer](/move-basics/primitive-types#integer-types) (u8, u16, u32, u64,
  u128, u256). - [address](/move-basics/address). -
  [std::string::String](/move-basics/string), UTF8 strings. -
  [std::ascii::String](/move-basics/string#ascii-strings), ASCII strings. -
  [vector<T>](/move-basics/vector), where T is a pure type. -
  [std::option::Option<T>](/move-basics/option), where T is a pure type. -
  [std::object::ID](/storage/uid-and-id), typically points to an object. See also
  [What is an Object](/object/object-model).
* Object arguments: These are objects or references of objects that the transaction will access. An
  object argument needs to be either a shared object, a frozen object, or an object that the
  transaction sender owns for the transaction to be successful. For more see
  [Object Model](/object).

## Commands[​](#commands "Direct link to Commands")

Sui transactions may consist of multiple commands. Each command is a single built-in command (like
publishing a package) or a call to a function in an already published package. The commands are
executed in the order they are listed in the transaction, and they can use the results of the
previous commands, forming a chain. Transaction either succeeds or fails as a whole.

Schematically, a transaction looks like this (in pseudo-code):

```move
Inputs:  
- sender = 0xa11ce  
  
Commands:  
- payment = SplitCoins(Gas, [ 1000 ])  
- item = MoveCall(0xAAA::market::purchase, [ payment ])  
- TransferObjects(item, sender)
```

In this example, the transaction consists of three commands:

1. SplitCoins - a built-in command that splits a new coin from the passed object, in this case,
   the Gas object;
2. MoveCall - a command that calls a function purchase in a package 0xAAA, module market
   with the given arguments - the payment object;
3. TransferObjects - a built-in command that transfers the object to the recipient.

## Transaction Effects[​](#transaction-effects "Direct link to Transaction Effects")

Transaction effects are the changes that a transaction makes to the blockchain state. More
specifically, a transaction can change the state in the following ways:

* use the gas object to pay for the transaction;
* create, update, or delete objects;
* emit events;

The result of the executed transaction consists of different parts:

* Transaction Digest - the hash of the transaction which is used to identify the transaction;
* Transaction Data - the inputs, commands and gas object used in the transaction;
* Transaction Effects - the status and the "effects" of the transaction, more specifically: the
  status of the transaction, updates to objects and their new versions, the gas object used, the gas
  cost of the transaction, and the events emitted by the transaction;
* Events - the custom [events](/programmability/events) emitted by the transaction;
* Object Changes - the changes made to the objects, including the *change of ownership*;
* Balance Changes - the changes made to the aggregate balances of the account involved in the
  transaction;

* [Transaction Structure](#transaction-structure)
* [Inputs](#inputs)
* [Commands](#commands)
* [Transaction Effects](#transaction-effects)
Move Basics | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Move Basics

This chapter is all about the basic syntax of the Move language. It covers the basics of the
language, such as types, modules, functions, and control flow. It focuses on the language without a
storage model or a blockchain, and explains the essential concepts of the language. To learn
features specific to Sui, such as storage functions and abilities, refer to the
[Using Objects](/storage/) chapter, however, it is recommended to start with this chapter first.
Module | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Module

A module is the base unit of code organization in Move. Modules are used to group and isolate code,
and all members of the module are private to the module by default. In this section you will learn
how to define a module, declare its members, and access it from other modules.

## Module Declaration[​](#module-declaration "Direct link to Module Declaration")

Modules are declared using the module keyword followed by the package address, module name,
semicolon, and the module body. The module name should be in snake\_case - all lowercase letters
with underscores between words. Modules names must be unique in the package.

Usually, a single file in the sources/ folder contains a single module. The file name should match
the module name - for example, a donut\_shop module should be stored in the donut\_shop.move file.
You can read more about coding conventions in the
[Coding Conventions](/guides/code-quality-checklist) section.

> If you need to declare more than one module in a file, you must use [Module Block](#module-block)
> syntax.

```move
// Module label.  
module book::my_module;  
  
// module body
```

Structs, functions, constants and imports all part of the module:

* [Structs](/move-basics/struct)
* [Functions](/move-basics/function)
* [Constants](/move-basics/constants)
* [Imports](/move-basics/importing-modules)
* [Struct Methods](/move-basics/struct-methods)

## Address and Named Address[​](#address-and-named-address "Direct link to Address and Named Address")

The module address can be specified as both: an address *literal* (does not require the @ prefix)
or a named address specified in the [Package Manifest](/concepts/manifest). In the example
below, both are identical because there's a book = "0x0" record in the [addresses] section of
the Move.toml.

```move
module 0x0::address_literal { /* ... */ }  
module book::named_address { /* ... */ }
```

Addresses section in the Move.toml:

```move
# Move.toml  
[addresses]  
book = "0x0"
```

## Module Members[​](#module-members "Direct link to Module Members")

Module members are declared inside the module body. To illustrate that, let's define a simple module
with a struct, a function and a constant:

```move
module book::my_module_with_members;  
  
// import  
use book::my_module;  
  
// a constant  
const CONST: u8 = 0;  
  
// a struct  
public struct Struct {}  
  
// method alias  
public use fun function as Struct.struct_fun;  
  
// function  
fun function(_: &Struct) { /* function body */ }
```

## Module Block[​](#module-block "Direct link to Module Block")

The pre-2024 edition of Move required the body of the module to be a *module block* - the contents
of the module needed to be surrounded by curly braces {}. The main reason to use block syntax and
not *label* syntax is if you need to define more than one module in a file. However, using module
blocks is not recommended practice.

```move
module book::my_block_module_with_members {  
    // import  
    use book::my_module;  
  
    // a constant  
    const CONST: u8 = 0;  
  
    // a struct  
    public struct Struct {}  
  
    // method alias  
    public use fun function as Struct.struct_fun;  
  
    // function  
    fun function(_: &Struct) { /* function body */ }  
}  
  
// module block allows multiple module definitions in the  
// same file but this is not a recommended practice  
module book::another_module_in_the_file {  
    // ...  
}
```

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Modules](/reference/modules) in the Move Reference.

* [Module Declaration](#module-declaration)
* [Address and Named Address](#address-and-named-address)
* [Module Members](#module-members)
* [Module Block](#module-block)
* [Further Reading](#further-reading)
Comments | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Comments

Comments are a way to add notes or document your code. They are ignored by the compiler and don't
result in Move bytecode. You can use comments to explain what your code does, add notes to yourself
or other developers, temporarily remove a part of your code, or generate documentation. There are
three types of comments in Move: line comments, block comments, and doc comments.

## Line Comment[​](#line-comment "Direct link to Line Comment")

You can use a double slash // to comment out the rest of the line. Everything after // will be
ignored by the compiler.

```move
module book::comments_line;  
  
// let's add a note to everything!  
fun some_function_with_numbers() {  
    let a = 10;  
    // let b = 10 this line is commented and won't be executed  
    let b = 5; // here comment is placed after code  
    a + b; // result is 15, not 10!  
}
```

## Block Comment[​](#block-comment "Direct link to Block Comment")

Block comments are used to comment out a block of code. They start with /\* and end with \*/.
Everything between /\* and \*/ will be ignored by the compiler. You can use block comments to
comment out a single line or multiple lines. You can even use them to comment out a part of a line.

```move
module book::comments_block;  
  
fun /* you can comment everywhere */ go_wild() {  
    /* here  
        there  
        everywhere */ let a = 10;  
    let b = /* even here */ 10; /* and again */  
    a + b;  
}  
/* you can use it to remove certain expressions or definitions  
fun empty_commented_out() {  
  
}  
*/
```

This example is a bit extreme, but it shows all the ways that you can use block comments.

## Doc Comment[​](#doc-comment "Direct link to Doc Comment")

Documentation comments are special comments that are used to generate documentation for your code.
They are similar to block comments but start with three slashes /// and are placed before the
definition of the item they document.

```move
/// Module has documentation!  
module book::comments_doc;  
  
/// This is a 0x0 address constant!  
const AN_ADDRESS: address = @0x0;  
  
/// This is a struct!  
public struct AStruct {  
    /// This is a field of a struct!  
    a_field: u8,  
}  
  
/// This function does something!  
/// And it's documented!  
fun do_something() {}
```

## Whitespace[​](#whitespace "Direct link to Whitespace")

Unlike some languages, whitespace (spaces, tabs, and newlines) have no impact on the meaning of the
program.

* [Line Comment](#line-comment)
* [Block Comment](#block-comment)
* [Doc Comment](#doc-comment)
* [Whitespace](#whitespace)
Primitive Types | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Primitive Types

For simple values, Move has a number of built-in primitive types. They're the foundation for all
other types. The primitive types are:

* [Booleans](#booleans)
* [Unsigned Integers](#integer-types)
* [Addresses](/move-basics/address) - covered in the next section

Before we get to the primitive types, let's first take a look at how to declare and assign variables
in Move.

## Variables and Assignment[​](#variables-and-assignment "Direct link to Variables and Assignment")

Variables are declared using the let keyword. They are immutable by default, but can be made
mutable by adding the mut keyword:

```move
let <variable_name>[: <type>]  = <expression>;  
let mut <variable_name>[: <type>] = <expression>;
```

Where:

* <variable\_name> - the name of the variable
* <type> - the type of the variable, optional
* <expression> - the value to be assigned to the variable

```move
let x: bool = true;  
let mut y: u8 = 42;
```

A mutable variable can be reassigned using the = operator.

```move
y = 43;
```

Variables can also be shadowed by re-declaring them.

```move
let x: u8 = 42;  
let x: u16 = 42;
```

## Booleans[​](#booleans "Direct link to Booleans")

The bool type represents a boolean value - yes or no, true or false. It has two possible values:
true and false, which are keywords in Move. For booleans, the compiler can always infer the type
from the value, so there is no need to explicitly specify it.

```move
let x = true;  
let y = false;
```

Booleans are often used to store flags and to control the flow of the program. Please refer to the
[Control Flow](/move-basics/control-flow) section for more information.

## Integer Types[​](#integer-types "Direct link to Integer Types")

Move supports unsigned integers of various sizes, from 8-bit to 256-bit. The integer types are:

* u8 - 8-bit
* u16 - 16-bit
* u32 - 32-bit
* u64 - 64-bit
* u128 - 128-bit
* u256 - 256-bit

```move
let x: u8 = 42;  
let y: u16 = 42;  
// ...  
let z: u256 = 42;
```

While boolean literals like true and false are clearly booleans, an integer literal like 42
could be any of the integer types. In most of the cases, the compiler will infer the type from the
value, usually defaulting to u64. However, sometimes the compiler is unable to infer the type and
will require an explicit type annotation. It can either be provided during assignment or by using a
type suffix.

```move
// Both are equivalent  
let x: u8 = 42;  
let x = 42u8;
```

### Operations[​](#operations "Direct link to Operations")

Move supports the standard arithmetic operations for integers: addition, subtraction,
multiplication, division, and modulus (remainder). The syntax for these operations is:

| Syntax | Operation | Aborts If |
| --- | --- | --- |
| + | addition | Result is too large for the integer type |
| - | subtraction | Result is less than zero |
| \* | multiplication | Result is too large for the integer type |
| % | modulus (remainder) | The divisor is 0 |
| / | truncating division | The divisor is 0 |

> For more operations, including bitwise operations, please refer to the
> [Move Reference](/reference/primitive-types/integers#bitwise).

The types of the operands *must match*, or the compiler will raise an error. The result of the
operation will be of the same type as the operands. To perform operations on different types, the
operands need to be cast to the same type.

### Casting with as[​](#casting-with-as "Direct link to casting-with-as")

Move supports explicit casting between integer types. The syntax is as follows:

```move
<expression> as <type>
```

Note that parentheses around the expression may be required to prevent ambiguity:

```move
let x: u8 = 42;  
let y: u16 = x as u16;  
let z = 2 * (x as u16); // ambiguous, requires parentheses
```

A more complex example, preventing overflow:

```move
let x: u8 = 255;  
let y: u8 = 255;  
let z: u16 = (x as u16) + ((y as u16) * 2);
```

### Overflow[​](#overflow "Direct link to Overflow")

Move does not support overflow / underflow; an operation that results in a value outside the range
of the type will raise a runtime error. This is a safety feature to prevent unexpected behavior.

```move
let x = 255u8;  
let y = 1u8;  
  
// This will raise an error  
let z = x + y;
```

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Bool](/reference/primitive-types/bool) in the Move Reference.
* [Integer](/reference/primitive-types/integers) in the Move Reference.

* [Variables and Assignment](#variables-and-assignment)
* [Booleans](#booleans)
* [Integer Types](#integer-types)
  + [Operations](#operations)
  + [Casting with `as`](#casting-with-as)
  + [Overflow](#overflow)
* [Further Reading](#further-reading)
Address Type | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Address Type

Move uses a special type called [address](/concepts/address) to represent addresses. It is a
32-byte value that can represent any address on the blockchain. Addresses can be written in two
forms: hexadecimal addresses prefixed with 0x and named addresses.

```move
// address literal  
let value: address = @0x1;  
  
// named address registered in Move.toml  
let value = @std;  
let other = @sui;
```

An address literal starts with the @ symbol followed by a hexadecimal number or an identifier. The
hexadecimal number is interpreted as a 32 byte value. The identifier is looked up in the
[Move.toml](/concepts/manifest) file and replaced with the corresponding address by the
compiler. If the identifier is not found in the Move.toml file, the compiler will throw an error.

## Conversion[​](#conversion "Direct link to Conversion")

Sui Framework offers a set of helper functions to work with addresses. Given that the address type
is a 32 byte value, it can be converted to a u256 type and vice versa. It can also be converted to
and from a vector<u8> type.

Example: Convert an address to a u256 type and back.

```move
use sui::address;  
  
let addr_as_u256: u256 = address::to_u256(@0x1);  
let addr = address::from_u256(addr_as_u256);
```

Example: Convert an address to a vector<u8> type and back.

```move
use sui::address;  
  
let addr_as_u8: vector<u8> = address::to_bytes(@0x1);  
let addr = address::from_bytes(addr_as_u8);
```

Example: Convert an address into a string.

```move
use sui::address;  
use std::string::String;  
  
let addr_as_string: String = address::to_string(@0x1);
```

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Address](/reference/primitive-types/address) in the Move Reference.
* [sui::address](https://docs.sui.io/references/framework/sui/address) module documentation.

* [Conversion](#conversion)
* [Further Reading](#further-reading)
Expression | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Expression

In programming languages, an expression is a unit of code that returns a value. In Move, almost
everything is an expression, with the sole exception of the let statement, which is a declaration.
In this section, we cover the types of expressions and introduce the concept of scope.

> Expressions are sequenced with semicolons ;. If there's "no expression" after the semicolon, the
> compiler will insert a unit (), which represents an empty expression.

## Literals[​](#literals "Direct link to Literals")

In the [Primitive types](/move-basics/primitive-types) section, we introduced the basic types of Move. And to
illustrate them, we used literals. A literal is a notation for representing a fixed value in source
code. Literals can be used to initialize variables or directly pass fixed values as arguments to
functions. Move has the following literals:

* Boolean values: true and false
* Integer values: 0, 1, 123123
* Hexadecimal values: Numbers prefixed with 0x to represent integers, such as 0x0, 0x1, 0x123
* Byte vector values: Prefixed with b, such as b"bytes\_vector"
* Byte values: Hexadecimal literals prefixed with x, such as x"0A"

```move
let b = true;     // true is a literal  
let n = 1000;     // 1000 is a literal  
let h = 0x0A;     // 0x0A is a literal  
let v = b"hello"; // b"hello" is a byte vector literal  
let x = x"0A";    // x"0A" is a byte vector literal  
let c = vector[1, 2, 3]; // vector[] is a vector literal
```

## Operators[​](#operators "Direct link to Operators")

Arithmetic, logical, and bitwise operators are used to perform operations on values. Since these
operations produce values, they are considered expressions.

```move
let sum = 1 + 2;   // 1 + 2 is an expression  
let sum = (1 + 2); // the same expression with parentheses  
let is_true = true && false; // true && false is an expression  
let is_true = (true && false); // the same expression with parentheses
```

## Blocks[​](#blocks "Direct link to Blocks")

A block is a sequence of statements and expressions enclosed in curly braces {}. It returns the
value of the last expression in the block (note that this final expression must not have an ending
semicolon). A block is an expression, so it can be used anywhere an expression is expected.

```move
// block with an empty expression, however, the compiler will  
// insert an empty expression automatically: `let none = { () }`  
// let none = {};  
  
// block with let statements and an expression.  
let sum = {  
    let a = 1;  
    let b = 2;  
    a + b // last expression is the value of the block  
};  
  
// block is an expression, so it can be used in an expression and  
// doesn't have to be assigned to a variable.  
{  
    let a = 1;  
    let b = 2;  
    a + b; // not returned - semicolon.  
    // compiler automatically inserts an empty expression `()`  
};
```

## Function Calls[​](#function-calls "Direct link to Function Calls")

We go into detail about functions in the [Functions](/move-basics/function) section. However, we have already
used function calls in previous sections, so it's worth mentioning them here. A function call is an
expression that calls a function and returns the value of the last expression in the function body,
provided the last expression does not have a terminating semi-colon.

```move
fun add(a: u8, b: u8): u8 {  
    a + b  
}  
  
#[test]  
fun some_other() {  
    let sum = add(1, 2); // not returned due to the semicolon.  
    // compiler automatically inserts an empty expression `()` as return value of the block  
}
```

## Control Flow Expressions[​](#control-flow-expressions "Direct link to Control Flow Expressions")

Control flow expressions are used to control the flow of the program. They are also expressions, so
they return a value. We cover control flow expressions in the [Control Flow](/move-basics/control-flow)
section. Here's a very brief overview:

```move
// if is an expression, so it returns a value; if there are 2 branches,  
// the types of the branches must match.  
if (bool_expr) expr1 else expr2;  
  
// while is an expression, but it returns `()`.  
while (bool_expr) { expr; };  
  
// loop is an expression, but returns `()` as well.  
loop { expr; break };
```

* [Literals](#literals)
* [Operators](#operators)
* [Blocks](#blocks)
* [Function Calls](#function-calls)
* [Control Flow Expressions](#control-flow-expressions)
Custom Types with Struct | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Custom Types with Struct

Move's type system shines when it comes to defining custom types. User defined types can be custom
tailored to the specific needs of the application, not only on the data level, but also in its
behavior. In this section we introduce the struct definition and how to use it.

## Struct[​](#struct "Direct link to Struct")

To define a custom type, you can use the struct keyword followed by the name of the type. After
the name, you can define the fields of the struct. Each field is defined with the
field\_name: field\_type syntax. Field definitions must be separated by commas. The fields can be of
any type, including other structs.

> Move does not support recursive structs, meaning a struct cannot contain itself as a field.

```move
/// A struct representing an artist.  
public struct Artist {  
    /// The name of the artist.  
    name: String,  
}  
  
/// A struct representing a music record.  
public struct Record {  
    /// The title of the record.  
    title: String,  
    /// The artist of the record. Uses the `Artist` type.  
    artist: Artist,  
    /// The year the record was released.  
    year: u16,  
    /// Whether the record is a debut album.  
    is_debut: bool,  
    /// The edition of the record.  
    edition: Option<u16>,  
}
```

In the example above, we define a Record struct with five fields. The title field is of type
String, the artist field is of type Artist, the year field is of type u16, the is\_debut
field is of type bool, and the edition field is of type Option<u16>. The edition field is of
type Option<u16> to represent that the edition is optional.

Structs are private by default, meaning they cannot be imported and used outside of the module they
are defined in. Their fields are also private and can't be accessed from outside the module. See
[visibility](/move-basics/visibility) for more information on different visibility modifiers.

> Fields of a struct are private and can only be accessed by the module defining the struct. Reading
> and writing the fields of a struct in other modules is only possible if the module defining the
> struct provides public functions to access the fields.

## Create and use an instance[​](#create-and-use-an-instance "Direct link to Create and use an instance")

We described the *definition* of a struct. Now let's see how to initialize a struct and use it. A
struct can be initialized using the struct\_name { field1: value1, field2: value2, ... } syntax.
The fields can be initialized in any order, and all of the required fields must be set.

```move
let mut artist = Artist {  
    name: b"The Beatles".to_string()  
};
```

In the example above, we create an instance of the Artist struct and set the name field to a
string "The Beatles".

To access the fields of a struct, you can use the . operator followed by the field name.

```move
// Access the `name` field of the `Artist` struct.  
let artist_name = artist.name;  
  
// Access a field of the `Artist` struct.  
assert_eq!(artist.name, b"The Beatles".to_string());  
  
// Mutate the `name` field of the `Artist` struct.  
artist.name = b"Led Zeppelin".to_string();  
  
// Check that the `name` field has been mutated.  
assert_eq!(artist.name, b"Led Zeppelin".to_string());
```

Only the module defining the struct can access its fields (both mutably and immutably). So the above
code should be in the same module as the Artist struct.

## Unpacking a struct[​](#unpacking-a-struct "Direct link to Unpacking a struct")

Structs are non-discardable by default, meaning that the initialized struct value must be used,
either by storing it or unpacking it. Unpacking a struct means deconstructing it into its fields.
This is done using the let keyword followed by the struct name and the field names.

```move
// Unpack the `Artist` struct and create a new variable `name`  
// with the value of the `name` field.  
let Artist { name } = artist;
```

In the example above we unpack the Artist struct and create a new variable name with the value
of the name field. Because the variable is not used, the compiler will raise a warning. To
suppress the warning, you can use the underscore \_ to indicate that the variable is intentionally
unused.

```move
// Unpack the `Artist` struct and ignore the `name` field.  
let Artist { name: _ } = artist;
```

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Structs](/reference/structs) in the Move Reference.

* [Struct](#struct)
* [Create and use an instance](#create-and-use-an-instance)
* [Unpacking a struct](#unpacking-a-struct)
* [Further Reading](#further-reading)
Abilities: Introduction | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Abilities: Introduction

Move has a unique type system which allows customizing *type abilities*.
[In the previous section](/move-basics/struct), we introduced the struct definition and how to use it.
However, the instances of the Artist and Record structs had to be unpacked for the code to
compile. This is default behavior of a struct without *abilities*.

> Throughout the book you will see chapters with name Ability: <name>, where <name> is the name
> of the ability. These chapters will cover the ability in detail, how it works, and how to use it
> in Move.

## What are Abilities?[​](#what-are-abilities "Direct link to What are Abilities?")

Abilities are a way to allow certain behaviors for a type. They are a part of the struct declaration
and define which behaviors are allowed for the instances of the struct.

## Abilities Syntax[​](#abilities-syntax "Direct link to Abilities Syntax")

Abilities are set in the struct definition using the has keyword followed by a list of abilities.
The abilities are separated by commas. Move supports 4 abilities: copy, drop, key, and
store. Each ability defines a specific behavior for the struct instances.

```move
/// This struct has the `copy` and `drop` abilities.  
public struct VeryAble has copy, drop {  
    // field: Type1,  
    // field2: Type2,  
    // ...  
}
```

## Overview[​](#overview "Direct link to Overview")

A quick overview of the abilities:

> All of the built-in types except [references](/move-basics/references) have copy, drop, and store
> abilities. References have copy and drop.

* copy - allows the struct to be *copied*. Explained in the [Ability: Copy](/move-basics/copy-ability)
  chapter.
* drop - allows the struct to be *dropped* or *discarded*. Explained in the
  [Ability: Drop](/move-basics/drop-ability) chapter.
* key - allows the struct to be used as a *key* in a storage. Explained in the
  [Ability: Key](/storage/key-ability) chapter.
* store - allows the struct to be *stored* in structs that have the *key* ability. Explained in
  the [Ability: Store](/storage/store-ability) chapter.

While it is important to briefly mention them here, we will go into more detail about each ability
in the following chapters and give proper context on how to use them.

## No Abilities[​](#no-abilities "Direct link to No Abilities")

A struct without abilities cannot be discarded, copied, or stored in storage. We call such a struct
a *Hot Potato*. A lighthearted name, but it is a good way to remember that a struct without
abilities is like a hot potato - it can only be passed around and requires special handling. The Hot
Potato is one of the most powerful patterns in Move, and we go into more detail about it in the
[Hot Potato Pattern](/programmability/hot-potato-pattern) chapter.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Type Abilities](/reference/abilities) in the Move Reference.

* [What are Abilities?](#what-are-abilities)
* [Abilities Syntax](#abilities-syntax)
* [Overview](#overview)
* [No Abilities](#no-abilities)
* [Further Reading](#further-reading)
Abilities: Drop | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Abilities: Drop

The drop ability - the simplest of them - allows the instance of a struct to be *ignored* or
*discarded*. In many programming languages this behavior is considered default. However, in Move, a
struct without the drop ability is not allowed to be ignored. This is a safety feature of the Move
language, which ensures that all assets are properly handled. An attempt to ignore a struct without
the drop ability will result in a compilation error.

```move
module book::drop_ability;  
  
/// This struct has the `drop` ability.  
public struct IgnoreMe has drop {  
    a: u8,  
    b: u8,  
}  
  
/// This struct does not have the `drop` ability.  
public struct NoDrop {}  
  
#[test]  
// Create an instance of the `IgnoreMe` struct and ignore it.  
// Even though we constructed the instance, we don't need to unpack it.  
fun test_ignore() {  
    let no_drop = NoDrop {};  
    let _ = IgnoreMe { a: 1, b: 2 }; // no need to unpack  
  
    // The value must be unpacked for the code to compile.  
    let NoDrop {} = no_drop; // OK  
}
```

The drop ability is often used on custom collection types to eliminate the need for special
handling of the collection when it is no longer needed. For example, a vector type has the drop
ability, which allows the vector to be ignored when it is no longer needed. However, the biggest
feature of Move's type system is the ability to not have drop. This ensures that the assets are
properly handled and not ignored.

A struct with a single drop ability is called a *Witness*. We explain the concept of a *Witness*
in the [Witness and Abstract Implementation](/programmability/witness-pattern) section.

## Types with the drop Ability[​](#types-with-the-drop-ability "Direct link to types-with-the-drop-ability")

All native types in Move have the drop ability. This includes:

* [bool](/move-basics/primitive-types#booleans)
* [unsigned integers](/move-basics/primitive-types#integer-types)
* [vector<T>](/move-basics/vector) when T has drop
* [address](/move-basics/address)

All of the types defined in the standard library have the drop ability as well. This includes:

* [Option<T>](/move-basics/option) when T has drop
* [String](/move-basics/string)
* [TypeName](/move-basics/type-reflection)

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Type Abilities](/reference/abilities) in the Move Reference.

* [Types with the `drop` Ability](#types-with-the-drop-ability)
* [Further Reading](#further-reading)
Importing Modules | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Importing Modules

Move achieves high modularity and code reuse by allowing module imports. Modules within the same
package can import each other, and a new package can depend on already existing packages and use
their modules too. This section will cover the basics of importing modules and how to use them in
your own code.

## Importing a Module[​](#importing-a-module "Direct link to Importing a Module")

Modules defined in the same package can import each other. The use keyword is followed by the
module path, which consists of the package address (or alias) and the module name separated by ::.

File: sources/module\_one.move

```move
module book::module_one;  
  
/// Struct defined in the same module.  
public struct Character has drop {}  
  
/// Simple function that creates a new `Character` instance.  
public fun new(): Character { Character {} }
```

Another module defined in the same package can import the first module using the use keyword.

File: sources/module\_two.move

```move
module book::module_two;  
  
use book::module_one; // importing module_one from the same package  
  
/// Calls the `new` function from the `module_one` module.  
public fun create_and_ignore() {  
    let _ = module_one::new();  
}
```

> Note: Any item (struct, function, constant, etc.) that you want to import from another module must
> be marked with the public (or public(package) - see [visibility modifiers](/move-basics/visibility))
> keyword to make it accessible outside its defining module. For example, the Character struct and
> the new function in module\_one are marked public so they can be used in module\_two.

## Importing Members[​](#importing-members "Direct link to Importing Members")

You can also import specific members from a module. This is useful when you only need a single
function or a single type from a module. The syntax is the same as for importing a module, but you
add the member name after the module path.

```move
module book::more_imports;  
  
use book::module_one::new;       // imports the `new` function from the `module_one` module  
use book::module_one::Character; // importing the `Character` struct from the `module_one` module  
  
/// Calls the `new` function from the `module_one` module.  
public fun create_character(): Character {  
    new()  
}
```

## Grouping Imports[​](#grouping-imports "Direct link to Grouping Imports")

Imports can be grouped into a single use statement using curly braces {}. This allows for
cleaner and more organized code when importing multiple members from the same module or package.

```move
module book::grouped_imports;  
  
// imports the `new` function and the `Character` struct from  
// the `module_one` module  
use book::module_one::{new, Character};  
  
/// Calls the `new` function from the `module_one` module.  
public fun create_character(): Character {  
    new()  
}
```

Importing function names is less common in Move, since the function names can overlap and cause
confusion. A recommended practice is to import the entire module and use the module path to access
the function. Types have unique names and should be imported individually.

To import members and the module itself in the group import, you can use the Self keyword. The
Self keyword refers to the module itself and can be used to import the module and its members.

```move
module book::self_imports;  
  
// imports the `Character` struct, and the `module_one` module  
use book::module_one::{Self, Character};  
  
/// Calls the `new` function from the `module_one` module.  
public fun create_character(): Character {  
    module_one::new()  
}
```

## Resolving Name Conflicts[​](#resolving-name-conflicts "Direct link to Resolving Name Conflicts")

When importing multiple members from different modules, it is possible to have name conflicts. For
example, if you import two modules that both have a function with the same name, you will need to
use the module path to access the function. It is also possible to have modules with the same name
in different packages. To resolve the conflict and avoid ambiguity, Move offers the as keyword to
rename the imported member.

```move
module book::conflict_resolution;  
  
// `as` can be placed after any import, including group imports  
use book::module_one::{Self as mod, Character as Char};  
  
/// Calls the `new` function from the `module_one` module.  
public fun create(): Char {  
    mod::new()  
}
```

## Adding an External Dependency[​](#adding-an-external-dependency "Direct link to Adding an External Dependency")

Move packages can depend on other packages; the dependencies are listed in the
[Package Manifest](/concepts/manifest) file called Move.toml.

Package dependencies are defined in the [Package Manifest](/concepts/manifest) as follows:

Move.toml

```move
[dependencies]  
Example = { git = "https://github.com/Example/example.git", subdir = "path/to/package", rev = "v1.2.3" }  
Local = { local = "../my_other_package" }
```

The dependencies section contains an entry for each package dependency. The key of the entry is
the name of the package (Example or Local in the example), and the value is either a git import
table or a local path. The git import contains the URL of the package, the subdirectory where the
package is located, and the revision of the package. The local path is a relative path to the qa
package directory.

If you add a dependency, all of its dependencies also become available to your package.

If a dependency is added to the Move.toml file, the compiler will automatically fetch (and later
refetch) the dependencies when building the package.

> Starting with version 1.45 of the sui CLI, the system packages are automatically included as
> dependencies for all packages if they are not present in Move.toml. Therefore, MoveStdlib,
> Sui, System, Bridge, and Deepbook are all available without an explicit import.

## Importing a Module from Another Package[​](#importing-a-module-from-another-package "Direct link to Importing a Module from Another Package")

Normally, packages define their addresses in the [addresses] section. You can use aliases instead
of full addresses. For example, instead of using 0x2::coin to reference the Sui coin module, you
can use sui::coin. The sui alias is defined in the Sui Framework package's manifest. Similarly,
the std alias is defined in the Standard Library package and can be used instead of 0x1 to
access standard library modules.

To import a module from another package, use the use keyword followed by the module path. The
module path consists of the package address (or alias) and the module name, separated by ::.

```move
module book::imports;  
  
use std::string; // std = 0x1, string is a module in the standard library  
use sui::coin;   // sui = 0x2, coin is a module in the Sui Framework
```

> Note: Module address names come from the [addresses] section of the manifest file (Move.toml),
> not the names used in the [dependencies] section.

* [Importing a Module](#importing-a-module)
* [Importing Members](#importing-members)
* [Grouping Imports](#grouping-imports)
* [Resolving Name Conflicts](#resolving-name-conflicts)
* [Adding an External Dependency](#adding-an-external-dependency)
* [Importing a Module from Another Package](#importing-a-module-from-another-package)
Standard Library | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Standard Library

The Move Standard Library provides functionality for native types and operations. It is a standard
collection of modules that do not interact with storage, but provide basic tools for working with
and manipulating data. It is the only dependency of the
[Sui Framework](/programmability/sui-framework), and is imported together with it.

## Most Common Modules[​](#most-common-modules "Direct link to Most Common Modules")

In this book we go into detail about most of the modules in the Standard Library, however, it is
also helpful to give an overview of the features, so that you can get a sense of what is available
and which module implements it.

| Module | Description | Chapter |
| --- | --- | --- |
| [std::string](https://docs.sui.io/references/framework/std/string) | Provides basic string operations | [String](/move-basics/string) |
| [std::ascii](https://docs.sui.io/references/framework/std/ascii) | Provides basic ASCII operations | - |
| [std::option](https://docs.sui.io/references/framework/std/option) | Implements Option<T> | [Option](/move-basics/option) |
| [std::vector](https://docs.sui.io/references/framework/std/vector) | Native operations on the vector type | [Vector](/move-basics/vector) |
| [std::bcs](https://docs.sui.io/references/framework/std/bcs) | Contains the bcs::to\_bytes() function | [BCS](/programmability/bcs) |
| [std::address](https://docs.sui.io/references/framework/std/address) | Contains a single address::length function | [Address](/move-basics/address) |
| [std::type\_name](https://docs.sui.io/references/framework/std/type_name) | Allows runtime *type reflection* | [Type Reflection](/move-basics/type-reflection) |
| [std::hash](https://docs.sui.io/references/framework/std/hash) | Hashing functions: sha2\_256 and sha3\_256 | - |
| [std::debug](https://docs.sui.io/references/framework/std/debug) | Contains debugging functions, which are available in only in **test** mode | - |
| [std::bit\_vector](https://docs.sui.io/references/framework/std/bit_vector) | Provides operations on bit vectors | - |
| [std::fixed\_point32](https://docs.sui.io/references/framework/std/fixed_point32) | Provides the FixedPoint32 type | - |

## Integer Modules[​](#integer-modules "Direct link to Integer Modules")

The Move Standard Library provides a set of functions associated with integer types. These functions
are split into multiple modules, each associated with a specific integer type. The modules should
not be imported directly, as their functions are available on every integer value.

> All of the modules provide the same set of functions. Namely, max, diff,
> divide\_and\_round\_up, sqrt and pow.

| Module | Description |
| --- | --- |
| [std::u8](https://docs.sui.io/references/framework/std/u8) | Functions for the u8 type |
| [std::u16](https://docs.sui.io/references/framework/std/u16) | Functions for the u16 type |
| [std::u32](https://docs.sui.io/references/framework/std/u32) | Functions for the u32 type |
| [std::u64](https://docs.sui.io/references/framework/std/u64) | Functions for the u64 type |
| [std::u128](https://docs.sui.io/references/framework/std/u128) | Functions for the u128 type |
| [std::u256](https://docs.sui.io/references/framework/std/u256) | Functions for the u256 type |

## Exported Addresses[​](#exported-addresses "Direct link to Exported Addresses")

The Standard Library exports a single named address - std = 0x1. Note the alias std is defined
here.

```move
[addresses]  
std = "0x1"
```

## Implicit Imports[​](#implicit-imports "Direct link to Implicit Imports")

Some modules are imported implicitly and are available in the module without the explicit use
import. For the Standard Library, these modules and types include:

* std::vector
* std::option
* std::option::Option

## Importing std without Sui Framework[​](#importing-std-without-sui-framework "Direct link to Importing std without Sui Framework")

The Move Standard Library can be imported to the package directly. However, std alone is not
enough to build a meaningful application, as it does not provide any storage capabilities and can't
interact with the on-chain state.

```move
MoveStdlib = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/move-stdlib", rev = "framework/mainnet" }
```

## Source Code[​](#source-code "Direct link to Source Code")

The source code of the Move Standard Library is available in the
[Sui repository](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/move-stdlib/sources).

* [Most Common Modules](#most-common-modules)
* [Integer Modules](#integer-modules)
* [Exported Addresses](#exported-addresses)
* [Implicit Imports](#implicit-imports)
* [Importing std without Sui Framework](#importing-std-without-sui-framework)
* [Source Code](#source-code)
Vector | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Vector

Vectors are a native way to store collections of elements in Move. They are similar to arrays in
other programming languages, but with a few differences. In this section, we introduce the vector
type and its operations.

## Vector syntax[​](#vector-syntax "Direct link to Vector syntax")

The vector type is written using the vector keyword followed by the type of the elements in
angle brackets. The type of the elements can be any valid Move type, including other vectors.

Move has a vector literal syntax that allows you to create vectors using the vector keyword
followed by square brackets containing the elements (or no elements for an empty vector).

```move
// An empty vector of bool elements.  
let empty: vector<bool> = vector[];  
  
// A vector of u8 elements.  
let v: vector<u8> = vector[10, 20, 30];  
  
// A vector of vector<u8> elements.  
let vv: vector<vector<u8>> = vector[  
    vector[10, 20],  
    vector[30, 40]  
];
```

The vector type is a built-in type in Move, and does not need to be imported from a module.
Vector operations are defined in the std::vector module, which is implicitly imported
and can be used directly without explicit use import.

## Vector operations[​](#vector-operations "Direct link to Vector operations")

The standard library provides methods to manipulate vectors. The following are some of the most
commonly used operations:

* push\_back: Adds an element to the end of the vector.
* pop\_back: Removes the last element from the vector.
* length: Returns the number of elements in the vector.
* is\_empty: Returns true if the vector is empty.
* remove: Removes an element at a given index.

```move
let mut v = vector[10u8, 20, 30];  
  
assert_eq!(v.length(), 3);  
assert_eq!(v.is_empty(), false);  
  
v.push_back(40);  
let last_value = v.pop_back();  
  
assert_eq!(last_value, 40);
```

## Destroying a Vector of non-droppable types[​](#destroying-a-vector-of-non-droppable-types "Direct link to Destroying a Vector of non-droppable types")

A vector of non-droppable types cannot be discarded. If you define a vector of types without the
drop ability, the vector value cannot be ignored. If the vector is empty, the compiler requires an
explicit call to the destroy\_empty function.

```move
/// A struct without `drop` ability.  
public struct NoDrop {}  
  
#[test]  
fun test_destroy_empty() {  
    // Initialize a vector of `NoDrop` elements.  
    let v = vector<NoDrop>[];  
  
    // While we know that `v` is empty, we still need to call  
    // the explicit `destroy_empty` function to discard the vector.  
    v.destroy_empty();  
}
```

The destroy\_empty function will fail at runtime if you call it on a non-empty vector.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Vector](/reference/primitive-types/vector) in the Move Reference.
* [std::vector](https://docs.sui.io/references/framework/std/vector) module documentation.

* [Vector syntax](#vector-syntax)
* [Vector operations](#vector-operations)
* [Destroying a Vector of non-droppable types](#destroying-a-vector-of-non-droppable-types)
* [Further Reading](#further-reading)
Option | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Option

Option is a type that represents an optional value which may or may not exist. The concept of
Option in Move is borrowed from Rust, and it is a very useful primitive in Move. Option is
defined in the [Standard Library](/move-basics/standard-library), and is defined as follows:

```move
module std::option;  
  
/// Abstraction of a value that may or may not be present.  
public struct Option<Element> has copy, drop, store {  
    vec: vector<Element>  
}
```

*See [full documentation for std::option](https://docs.sui.io/references/framework/std/option) module.*

> The 'std::option' module is implicitly imported in every module, so you don't need to add an
> explicit import.

The Option type is a generic type with an Element type parameter. It contains a single field,
vec, which is a vector of Element. The vector can have a length of 0 or 1, representing the
absence or presence of a value, respectively.

> Note: You might be surprised that Option is a struct containing a vector instead of an
> [enum](/reference/enums). This is for historical reasons: Option was added to Move before it had
> support for enums.

The Option type has two variants: Some and None. The Some variant contains a value, while
the None variant represents the absence of a value. The Option type is used to represent the
absence of a value in a type-safe way, avoiding the need for empty or undefined values.

## In Practice[​](#in-practice "Direct link to In Practice")

To showcase why the Option type is necessary, let's look at an example. Consider an application
which takes a user input and stores it in a variable. Some fields are required, and some are
optional. For example, a user's middle name is optional. While we could use an empty string to
represent the absence of a middle name, it would require extra checks to differentiate between an
empty string and a missing middle name. Instead, we can use the Option type to represent the
middle name.

```move
module book::user_registry;  
  
use std::string::String;  
  
/// A struct representing a user record.  
public struct User has drop {  
    first_name: String,  
    middle_name: Option<String>,  
    last_name: String,  
}  
  
/// Create a new `User` struct with the given fields.  
public fun register(  
    first_name: String,  
    middle_name: Option<String>,  
    last_name: String,  
): User {  
    User { first_name, middle_name, last_name }  
}
```

In the previous example, the middle\_name field is of type Option<String>. This means that the
middle\_name field can either contain a String value, wrapped in Some, or be explicitly empty,
represented by None. Using the Option type makes the optional nature of the field clear, avoiding
ambiguity and the need for extra checks to differentiate between an empty string and a missing
middle name.

## Creating and Using Option values[​](#creating-and-using-option-values "Direct link to Creating and Using Option values")

The Option type, along with the std::option module, is implicitly imported in Move. This means
you can use the Option type directly without needing a use statement.

To create a value of the Option type, you can use the option::some or option::none methods.
Option values also support several operations (borrowing will be discussed in the
[references](/move-basics/references#references-1) chapter):

```move
// `option::some` creates an `Option` value with a value.  
let mut opt = option::some(b"Alice");  
  
// `option::none` creates an `Option` without a value. We need to specify the  
// type since it can't be inferred from context.  
let empty : Option<u64> = option::none();  
  
// `option.is_some()` returns true if option contains a value.  
assert_eq!(opt.is_some(), true);  
assert_eq!(empty.is_none(), true);  
  
// internal value can be `borrow`ed and `borrow_mut`ed.  
assert_ref_eq!(opt.borrow(), &b"Alice");  
  
// `option.extract` takes the value out of the option, leaving the option empty.  
let inner = opt.extract();  
  
// `option.is_none()` returns true if option is None.  
assert_eq!(opt.is_none(), true);
```

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [std::option](https://docs.sui.io/references/framework/std/option) in the standard library

* [In Practice](#in-practice)
* [Creating and Using Option values](#creating-and-using-option-values)
* [Further Reading](#further-reading)
String | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# String

While Move does not have a built-in type to represent strings, it does have two standard
implementations for strings in the [Standard Library](/move-basics/standard-library). The std::string module
defines a String type and methods for UTF-8 encoded strings, and the second module, std::ascii,
provides an ASCII String type and its methods.

> The Sui execution environment automatically converts bytevector into String in transaction
> inputs. As a result, in many cases, constructing a String directly within the
> [Transaction Block](/concepts/what-is-a-transaction) is unnecessary.

## Strings are bytes[​](#strings-are-bytes "Direct link to Strings are bytes")

No matter which type of string you use, it is important to know that strings are just bytes. The
wrappers provided by the string and ascii modules are just that: wrappers. They do provide
safety checks and methods to work with strings, but at the end of the day, they are just vectors of
bytes.

```move
module book::custom_string;  
  
/// Anyone can implement a custom string-like type by wrapping a vector.  
public struct MyString {  
    bytes: vector<u8>,  
}  
  
/// Implement a `from_bytes` function to convert a vector of bytes to a string.  
public fun from_bytes(bytes: vector<u8>): MyString {  
    MyString { bytes }  
}  
  
/// Implement a `bytes` function to convert a string to a vector of bytes.  
public fun bytes(self: &MyString): &vector<u8> {  
    &self.bytes  
}
```

## Working with UTF-8 Strings[​](#working-with-utf-8-strings "Direct link to Working with UTF-8 Strings")

While there are two types of strings (string and ascii) in the standard library, the string
module should be considered the default. It has native implementations of many common operations,
leveraging low-level, optimized runtime code for superior performance. In contrast, the ascii
module is fully implemented in Move, relying on higher-level abstractions and making it less
suitable for performance-critical tasks.

### Definition[​](#definition "Direct link to Definition")

The String type in the std::string module is defined as follows:

```move
module std::string;  
  
/// A `String` holds a sequence of bytes which is guaranteed to be in utf8 format.  
public struct String has copy, drop, store {  
    bytes: vector<u8>,  
}
```

*See [full documentation for std::string](https://docs.sui.io/references/framework/std/string) module.*

### Creating a String[​](#creating-a-string "Direct link to Creating a String")

To create a new UTF-8 String instance, you can use the string::utf8 method. The
[Standard Library](/move-basics/standard-library) provides an alias .to\_string() on the vector<u8> for
convenience.

```move
// the module is `std::string` and the type is `String`  
use std::string::{Self, String};  
  
// strings are normally created using the `utf8` function  
// type declaration is not necessary, we put it here for clarity  
let hello: String = string::utf8(b"Hello");  
  
// The `.to_string()` alias on the `vector<u8>` is more convenient  
let hello = b"Hello".to_string();
```

### Common Operations[​](#common-operations "Direct link to Common Operations")

UTF8 String provides a number of methods to work with strings. The most common operations on strings
are: concatenation, slicing, and getting the length. Additionally, for custom string operations, the
bytes() method can be used to get the underlying byte vector.

```move
let mut str = b"Hello,".to_string();  
let another = b" World!".to_string();  
  
// append(String) adds the content to the end of the string  
str.append(another);  
  
// `sub_string(start, end)` copies a slice of the string  
str.sub_string(0, 5); // "Hello"  
  
// `length()` returns the number of bytes in the string  
str.length(); // 12 (bytes)  
  
// methods can also be chained! Get a length of a substring  
str.sub_string(0, 5).length(); // 5 (bytes)  
  
// whether the string is empty  
str.is_empty(); // false  
  
// get the underlying byte vector for custom operations  
let bytes: &vector<u8> = str.bytes();
```

### Safe UTF-8 Operations[​](#safe-utf-8-operations "Direct link to Safe UTF-8 Operations")

The default utf8 method may abort if the bytes passed into it are not valid UTF-8. If you are not
sure that the bytes you are passing are valid, you should use the try\_utf8 method instead. It
returns an Option<String>, which contains no value if the bytes are not valid UTF-8, and a string
otherwise.

> Hint: Functions with names starting with try\_\* typically return an Option. If the operation
> succeeds, the result is wrapped in Some. If it fails, the function returns None. This naming
> convention, commonly used in Move, is inspired by Rust.

```move
// this is a valid UTF-8 string  
let hello = b"Hello".try_to_string();  
  
assert!(hello.is_some()); // abort if the value is not valid UTF-8  
  
// this is not a valid UTF-8 string  
let invalid = b"\xFF".try_to_string();  
  
assert!(invalid.is_none()); // abort if the value is valid UTF-8
```

### UTF-8 Limitations[​](#utf-8-limitations "Direct link to UTF-8 Limitations")

The string module does not provide a way to access individual characters in a string. This is
because UTF-8 is a variable-length encoding, and the length of a character can be anywhere from 1 to
4 bytes. Similarly, the length() method returns the number of bytes in the string, not the number
of characters.

However, methods like sub\_string and insert validate character boundaries and abort if the
specified index falls within the middle of a character.

## ASCII Strings[​](#ascii-strings "Direct link to ASCII Strings")

This section is coming soon!

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [std::string](https://docs.sui.io/references/framework/std/string) module documentation.
* [std::ascii](https://docs.sui.io/references/framework/std/ascii) module documentation.

* [Strings are bytes](#strings-are-bytes)
* [Working with UTF-8 Strings](#working-with-utf-8-strings)
  + [Definition](#definition)
  + [Creating a String](#creating-a-string)
  + [Common Operations](#common-operations)
  + [Safe UTF-8 Operations](#safe-utf-8-operations)
  + [UTF-8 Limitations](#utf-8-limitations)
* [ASCII Strings](#ascii-strings)
* [Further Reading](#further-reading)
Control Flow | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Control Flow

Control flow statements are used to control the flow of execution in a program. They are used to
make decisions, repeat a block of code, or exit a block of code early. Move includes the following
control flow statements (explained in detail below):

* [if and if-else](#conditional-statements) - making decisions on whether to execute a block of
  code
* [loop and while loops](#repeating-statements-with-loops) - repeating a block of code
* [break and continue statements](#exiting-a-loop-early) - exiting a loop early
* [return](#early-return) statement - exiting a function early

## Conditional Statements[​](#conditional-statements "Direct link to Conditional Statements")

The if expression is used to make decisions in a program. It evaluates a
[boolean expression](/move-basics/expression#literals) and executes a block of code if the expression is true.
Paired with else, it can execute a different block of code if the expression is false.

The syntax for an if expression is:

```move
if (<bool_expression>) <expression>;  
if (<bool_expression>) <expression> else <expression>;
```

Just like any other expression, if requires a semicolon if there are other expressions following
it. The else keyword is optional, except when the resulting value is assigned to a variable, as
all branches must return a value to ensure type safety. Let’s examine how an if expression works
in Move with the following example:

```move
#[test]  
fun test_if() {  
    let x = 5;  
  
    // `x > 0` is a boolean expression.  
    if (x > 0) {  
        std::debug::print(&b"X is bigger than 0".to_string())  
    };  
}
```

Let's see how we can use if and else to assign a value to a variable:

```move
#[test]  
fun test_if_else() {  
    let x = 5;  
    let y = if (x > 0) {  
        1  
    } else {  
        0  
    };  
  
    assert_eq!(y, 1);  
}
```

In this example, the value of the if expression is assigned to the variable y. If x is greater
than 0, y is assigned the value 1; otherwise, it is assigned 0. The else block is required
because both branches of the if expression must return a value of the same type. Omitting the
else block would result in a compiler error, as it ensures all possible branches are accounted for
and type safety is maintained.

Conditional expressions are among the most important control flow statements in Move. They evaluate
user-provided input or stored data to make decisions. One key use case is in the
[assert! macro](/move-basics/assert-and-abort), which checks if a condition is true and aborts execution if
it is not. We’ll explore this in detail shortly.

## Repeating Statements with Loops[​](#repeating-statements-with-loops "Direct link to Repeating Statements with Loops")

Loops are used to execute a block of code multiple times. Move has two built-in types of loops:
loop and while. In many cases they can be used interchangeably, but usually while is used when
the number of iterations is known in advance, and loop is used when the number of iterations is
not known in advance or there are multiple exit points.

Loops are useful for working with collections, such as vectors, or for repeating a block of code
until a specific condition is met. However, take care to avoid infinite loops, which can exhaust gas
limits and cause the transaction to abort.

## The while Loop[​](#the-while-loop "Direct link to the-while-loop")

The while statement executes a block of code repeatedly as long as the associated boolean
expression evaluates to true. Just like we've seen with if, the boolean expression is evaluated
before each iteration of the loop. Additionally, like conditional statements, the while loop is an
expression and requires a semicolon if there are other expressions following it.

The syntax for the while loop is:

```move
while (<bool_expression>) { <expressions>; };
```

Here is an example of a while loop with a very simple condition:

```move
// This function iterates over the `x` variable until it reaches 10, the  
// return value is the number of iterations it took to reach 10.  
//  
// If `x` is 0, then the function will return 10.  
// If `x` is 5, then the function will return 5.  
fun while_loop(mut x: u8): u8 {  
    let mut y = 0;  
  
    // This will loop until `x` is 10.  
    // And will never run if `x` is 10 or more.  
    while (x < 10) {  
        y = y + 1;  
        x = x + 1;  
    };  
  
    y  
}  
  
#[test]  
fun test_while() {  
    assert_eq!(while_loop(0), 10); // 10 times  
    assert_eq!(while_loop(5), 5); // 5 times  
    assert_eq!(while_loop(10), 0); // loop never executed  
}
```

## Infinite loop[​](#infinite-loop "Direct link to infinite-loop")

Now let's imagine a scenario where the boolean expression is always true. For example, if we
literally passed true to the while condition. This is similar to how the loop statement
functions, except that while evaluates a condition.

```move
#[test, expected_failure(out_of_gas, location=Self)]  
fun test_infinite_while() {  
    let mut x = 0;  
  
    // This will loop forever.  
    while (true) {  
        x = x + 1;  
    };  
  
    // This line will never be executed.  
    assert_eq!(x, 5);  
}
```

An infinite while loop, or a while loop with an always true condition, is equivalent to a
loop. The syntax for creating a loop is straightforward:

```move
loop { <expressions>; };
```

Let's rewrite the previous example using loop instead of while:

```move
#[test, expected_failure(out_of_gas, location=Self)]  
fun test_infinite_loop() {  
    let mut x = 0;  
  
    // This will loop forever.  
    loop {  
        x = x + 1;  
    };  
  
    // This line will never be executed.  
    assert_eq!(x, 5);  
}
```

Infinite loops are rarely practical in Move, as every operation consumes gas, and an infinite loop
will inevitably lead to gas exhaustion. If you find yourself using a loop, consider whether there
might be a better approach, as many use cases can be handled more efficiently with other control
flow structures. That said, loop might be useful when combined with break and continue
statements to create controlled and flexible looping behavior.

## Exiting a Loop Early[​](#exiting-a-loop-early "Direct link to Exiting a Loop Early")

As we already mentioned, infinite loops are rather useless on their own. And that's where we
introduce the break and continue statements. They are used to exit a loop early, and to skip the
rest of the current iteration, respectively.

Syntax for the break statement is (without a semicolon):

```move
break
```

The break statement is used to stop the execution of a loop and exit it early. It is often used in
combination with a conditional statement to exit the loop when a certain condition is met. To
illustrate this point, let's turn the infinite loop from the previous example into something that
looks and behaves more like a while loop:

```move
#[test]  
fun test_break_loop() {  
    let mut x = 0;  
  
    // This will loop until `x` is 5.  
    loop {  
        x = x + 1;  
  
        // If `x` is 5, then exit the loop.  
        if (x == 5) {  
            break // Exit the loop.  
        }  
    };  
  
    assert_eq!(x, 5);  
}
```

Almost identical to the while loop, right? The break statement is used to exit the loop when x
is 5. If we remove the break statement, the loop will run forever, just like in the previous
example.

## Skipping an Iteration[​](#skipping-an-iteration "Direct link to Skipping an Iteration")

The continue statement is used to skip the rest of the current iteration and start the next one.
Similarly to break, it is used in combination with a conditional statement to skip the rest of an
iteration when a certain condition is met.

Syntax for the continue statement is (without a semicolon):

```move
continue
```

The example below skips odd numbers and prints only even numbers from 0 to 10:

```move
#[test]  
fun test_continue_loop() {  
    let mut x = 0;  
  
    // This will loop until `x` is 10.  
    loop {  
        x = x + 1;  
  
        // If `x` is odd, then skip the rest of the iteration.  
        if (x % 2 == 1) {  
            continue // Skip the rest of the iteration.  
        };  
  
        std::debug::print(&x);  
  
        // If `x` is 10, then exit the loop.  
        if (x == 10) {  
            break // Exit the loop.  
        }  
    };  
  
    assert_eq!(x, 10) // 10  
}
```

break and continue statements can be used in both while and loop loops.

## Early Return[​](#early-return "Direct link to Early Return")

The return statement is used to exit a [function](/move-basics/function) early and return a value. It is
often used in combination with a conditional statement to exit the function when a certain condition
is met. The syntax for the return statement is:

```move
return <expression>
```

Here is an example of a function that returns a value when a certain condition is met:

```move
/// This function returns `true` if `x` is greater than 0 and not 5,  
/// otherwise it returns `false`.  
fun is_positive(x: u8): bool {  
    if (x == 5) {  
        return false  
    };  
  
    if (x > 0) {  
        return true  
    };  
  
    false  
}  
  
#[test]  
fun test_return() {  
    assert_eq!(is_positive(5), false);  
    assert_eq!(is_positive(0), false);  
    assert_eq!(is_positive(1), true);  
}
```

Unlike in many other languages, the return statement is not required for the last expression in a
function. The last expression in a function block is automatically returned. However, the return
statement is useful when we want to exit a function early if a certain condition is met.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Control Flow](/reference/control-flow) chapter in the Move Reference.

* [Conditional Statements](#conditional-statements)
* [Repeating Statements with Loops](#repeating-statements-with-loops)
* [The `while` Loop](#the-while-loop)
* [Infinite `loop`](#infinite-loop)
* [Exiting a Loop Early](#exiting-a-loop-early)
* [Skipping an Iteration](#skipping-an-iteration)
* [Early Return](#early-return)
* [Further Reading](#further-reading)
Enums and Match | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Enums and Match

An enum is a user-defined data structure that, unlike a [struct](/move-basics/struct), can represent multiple
variants. Each variant can contain primitive types, structs, or other enums. However, recursive enum
definitions — similar to recursive struct definitions — are not allowed.

## Definition[​](#definition "Direct link to Definition")

An enum is defined using the enum keyword, followed by optional abilities and a block of variant
definitions. Each variant has a tag name and may optionally include either positional values or
named fields. Enum must have at least one variant. The structure of each variant is not flexible,
and the total number of variants can be relatively large - up to 100.

```move
module book::segment;  
  
use std::string::String;  
  
/// `Segment` enum definition.  
/// Defines various string segments.  
public enum Segment has copy, drop {  
    /// Empty variant, no value.  
    Empty,  
    /// Variant with a value (positional style).  
    String(String),  
    /// Variant with named fields.  
    Special {  
        content: vector<u8>,  
        encoding: u8, // Encoding tag.  
    },  
}
```

In the code sample above we defined a public Segment enum, which has the drop and copy
abilities, and 3 variants:

* Empty, which has no fields.
* String, which contains a single positional field of type String.
* Special, which uses named fields: content of type vector<u8> and encoding of type u8.

## Instantiating[​](#instantiating "Direct link to Instantiating")

Enums are *internal* to the module in which they are defined. This means an enum can only be
constructed, read, and unpacked within the same module.

[Similar to structs](/move-basics/struct#create-and-use-an-instance), enums are instantiated by specifying the
type, the variant, and the values for any fields defined in that variant.

```move
/// Constructs an `Empty` segment.  
public fun new_empty(): Segment { Segment::Empty }  
  
/// Constructs a `String` segment with the `str` value.  
public fun new_string(str: String): Segment { Segment::String(str) }  
  
/// Constructs a `Special` segment with the `content` and `encoding` values.  
public fun new_special(content: vector<u8>, encoding: u8): Segment {  
    Segment::Special {  
        content,  
        encoding,  
    }  
}
```

Depending on the use case, you may want to provide public constructors, or instantiate enums
internally as a part of application logic.

## Using in Type Definitions[​](#using-in-type-definitions "Direct link to Using in Type Definitions")

The biggest benefit of using enums is the ability to represent varying data structures under a
single type. To demonstrate this, let’s define a struct that contains a vector of Segment values:

```move
/// A struct to demonstrate enum capabilities.  
public struct Segments(vector<Segment>) has copy, drop;  
  
#[test]  
fun test_segments() {  
    let _ = Segments(vector[  
        Segment::Empty,  
        Segment::String(b"hello".to_string()),  
        Segment::String(b" move".to_string()),  
        Segment::Special { content: b"21", encoding: 1 },  
    ]);  
}
```

All variants of the Segment enum share the same type – Segment – which allows us to create a
homogeneous vector containing instances of different variants. This kind of flexibility is not
achievable with structs, as each struct defines a single, fixed shape.

## Pattern Matching[​](#pattern-matching "Direct link to Pattern Matching")

Unlike structs, enums require special handling when it comes to accessing the inner value or
checking the variant. We simply cannot read the inner fields of an enum using the . (dot) syntax,
because we need to make sure that the value we are trying to access is the right one. For that Move
offers *pattern matching* syntax.

> This chapter doesn't intend to cover all the features of pattern matching in Move. Refer to the
> [Pattern Matching](/reference/control-flow/pattern-matching) section in the Move Reference.

Pattern matching allows conditioning the logic based on the *pattern* of the value. It is performed
using the match expression, followed by the matched value in parenthesis and the block of *match
arms*, defining the pattern and expression to be performed if the pattern is right.

Let's extend our example by adding a set of is\_variant-like functions, so external packages can
check the variant. Starting with is\_empty.

```move
/// Whether this is an `Empty` segment.  
public fun is_empty(s: &Segment): bool {  
    // Match is an expression, hence we can use it for return value.  
    match (s) {  
        Segment::Empty => true,  
        Segment::String(_str) => false,  
        Segment::Special { content: _, encoding: _ } => false,  
    }  
}
```

The match keyword begins the expression, and s is the value being tested. Each match arm checks
for a specific variant of the Segment enum. If s matches Segment::Empty, the function returns
true; otherwise, it returns false.

For variants with fields, we need to bind the inner structure to local variables (even if we don’t
use them, marking unused values with \_ to avoid compiler warnings).

### Trick #1 - *any* Condition[​](#trick-1---any-condition "Direct link to trick-1---any-condition")

The Move compiler infers the type of the value used in a match expression and ensures that the
*match arms* are exhaustive – that is, all possible variants or values must be covered.

However, in some cases, such as matching on a primitive value or a collection like a vector, it's
not feasible to list every possible case. For these situations, match supports a wildcard pattern
(\_), which acts as a default arm. This arm is executed when no other patterns match.

We can demonstrate this by simplifying our is\_empty function and replacing the non-Empty
variants with a wildcard:

```move
public fun is_empty(s: &Segment): bool {  
    match (s) {  
        Segment::Empty => true,  
        _ => false, // Anything else returns `false`.  
    }  
}
```

Similarly, we can use the same approach to define is\_special and is\_string:

```move
/// Whether this is a `Special` segment.  
public fun is_special(s: &Segment): bool {  
    match (s) {  
        // Hint: the `..` ignores inner fields  
        Segment::Special { .. } => true,  
        _ => false,  
    }  
}  
  
/// Whether this is a `String` segment.  
public fun is_string(s: &Segment): bool {  
    match (s) {  
        Segment::String(_) => true,  
        _ => false,  
    }  
}
```

### Trick #2 - try\_into Helpers[​](#trick-2---try_into-helpers "Direct link to trick-2---try_into-helpers")

With the addition of is\_variant functions, we enabled external modules to check which variant an
enum instance represents. However, this is often not enough – external code still cannot access the
inner value of a variant due to enums being internal to their module.

A common pattern for addressing this is to define try\_into functions. These functions match on the
value and return an Option containing the inner contents if the match succeeds.

```move
/// Returns `Some(String)` if the `Segment` is `String`, `None` otherwise.  
public fun try_into_inner_string(s: Segment): Option<String> {  
    match (s) {  
        Segment::String(str) => option::some(str),  
        _ => option::none(),  
    }  
}
```

This pattern safely exposes internal data in a controlled way, avoiding abort.

### Trick #3 - Matching on Primitive Values[​](#trick-3---matching-on-primitive-values "Direct link to Trick #3 - Matching on Primitive Values")

The match expression in Move can be used with values of any type – enums, structs, or primitives.
To demonstrate this, let’s implement a to\_string function that creates a new String from a
Segment. In the case of the Special variant, we will match on the encoding field to determine
how to decode the content.

```move
/// Return a `String` representation of a segment.  
public fun to_string(s: &Segment): String {  
    match (*s) {  
        // Return an empty string.  
        Segment::Empty => b"".to_string(),  
        // Return the inner string.  
        Segment::String(str) => str,  
        // Return the decoded contents based on the encoding.  
        Segment::Special { content, encoding } => {  
            // Perform a match on the encoding, we only support 0 - ut8, 1 - hex.  
            match (encoding) {  
                // Plain encoding, return content.  
                0 => content.to_string(),  
                // HEX encoding, decode and return.  
                1 => sui::hex::decode(content).to_string(),  
                // We have to provide a wildcard pattern, because values of `u8` are 0-255.  
                _ => abort,  
            }  
        },  
    }  
}
```

This function demonstrates two key things:

* Nested match expressions can be used for deeper logic branching.
* Wildcards are essential for covering all possible values in primitive types like u8.

## The Final Test[​](#the-final-test "Direct link to The Final Test")

Now we can finalize the test we started before using the features we have added. Let's create a
scenario where we build enums into a vector.

```move
// Note, that the module has changed!  
module book::segment_tests;  
  
use book::segment;  
  
#[test]  
fun test_full_enum_cycle() {  
    use std::unit_test::assert_eq;  
  
    // Create a vector of different Segment variants.  
    let segments = vector[  
        segment::new_empty(),  
        segment::new_string(b"hello".to_string()),  
        segment::new_special(b" ", 0), // plaintext  
        segment::new_string(b"move".to_string()),  
        segment::new_special(b"21", 1), // hex  
    ];  
  
    // Aggregate all segments into the final string using `vector::fold!` macro.  
    let result = segments.fold!(b"".to_string(), |mut acc, segment| {  
        // Do not append empty, only `Special` and `String`.  
        if (!segment.is_empty()) {  
            acc.append(segment.to_string());  
        };  
        acc  
    });  
  
    // Check that the result is what's expected.  
    assert_eq!(result, b"hello move!".to_string());  
}
```

This test demonstrates the full enum workflow: instantiating different variants, using public
accessors, and performing logic with pattern matching. That should be enough to get you started!

To learn more about enums and pattern matching, refer to the resources listed in the
[further reading](#further-reading) section.

## Summary[​](#summary "Direct link to Summary")

* Enums are user-defined types that can represent multiple variants under a single type.
* Each variant can contain different types of data (primitives, structs, or other enums).
* Enums are internal to their defining module and require pattern matching for access.
* Pattern matching is done using the match expression, which:
  + Works with enums, structs, and primitive values;
  + Must handle all possible cases (be exhaustive);
  + Supports the \_ wildcard pattern for remaining cases;
  + Can return values and be used in expressions;
* Common patterns for enums include is\_variant checks and try\_into helper functions.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Enums](/reference/enums) in the Move Reference
* [Pattern Matching](/reference/control-flow/pattern-matching) in the Move Reference

* [Definition](#definition)
* [Instantiating](#instantiating)
* [Using in Type Definitions](#using-in-type-definitions)
* [Pattern Matching](#pattern-matching)
  + [Trick #1 - *any* Condition](#trick-1---any-condition)
  + [Trick #2 - `try_into` Helpers](#trick-2---try_into-helpers)
  + [Trick #3 - Matching on Primitive Values](#trick-3---matching-on-primitive-values)
* [The Final Test](#the-final-test)
* [Summary](#summary)
* [Further Reading](#further-reading)
Constants | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Constants

Constants are immutable values that are defined at the module level. They often serve as a way to
give names to static values that are used throughout a module. For example, if there's a default
price for a product, you might define a constant for it. Constants are stored in the module's
bytecode, and each time they are used, the value is copied.

```move
module book::shop_price;  
  
use sui::{coin::Coin, sui::SUI};  
  
/// Trying to purchase an item at an incorrect price.  
const EWrongPrice: u64 = 0;  
  
/// The price of an item in the shop.  
const ITEM_PRICE: u64 = 100;  
/// The owner of the shop, an address.  
const SHOP_OWNER: address = @0xa11ce;  
  
/// An item sold in the shop.  
public struct Item {}  
  
/// Purchase an item from the shop.  
public fun purchase(coin: Coin<SUI>): Item {  
    assert!(coin.value() == ITEM_PRICE, EWrongPrice);  
  
    transfer::public_transfer(coin, SHOP_OWNER);  
  
    Item {}  
}
```

## Naming Convention[​](#naming-convention "Direct link to Naming Convention")

Constants must start with a capital letter - this is enforced at the compiler level. For constants
used as a value, the convention is to use all uppercase letters and underscores between words, which
makes constants stand out from other identifiers in the code. An exception is made for
[error constants](/move-basics/assert-and-abort#error-constants), which are written in ECamelCase.

```move
/// Price of the item used at the shop.  
const ITEM_PRICE: u64 = 100;  
  
/// Error constant.  
const EItemNotFound: u64 = 1;
```

## Constants are Immutable[​](#constants-are-immutable "Direct link to Constants are Immutable")

Constants can't be changed and assigned new values. As part of the package bytecode, they are
inherently immutable.

```move
module book::immutable_constants;  
  
const ITEM_PRICE: u64 = 100;  
  
// emits an error  
fun change_price() {  
    ITEM_PRICE = 200;  
}
```

## Using Config Pattern[​](#using-config-pattern "Direct link to Using Config Pattern")

A common use case for an application is to define a set of constants that are used throughout the
codebase. But due to constants being private to the module, they can't be accessed from other
modules. One way to solve this is to define a "config" module that exports the constants.

```move
module book::config;  
  
const ITEM_PRICE: u64 = 100;  
const TAX_RATE: u64 = 10;  
const SHIPPING_COST: u64 = 5;  
  
/// Returns the price of an item.  
public fun item_price(): u64 { ITEM_PRICE }  
/// Returns the tax rate.  
public fun tax_rate(): u64 { TAX_RATE }  
/// Returns the shipping cost.  
public fun shipping_cost(): u64 { SHIPPING_COST }
```

This way other modules can import and read the constants, and the update process is simplified. If
the constants need to be changed, only the config module needs to be updated during the package
upgrade.

## Links[​](#links "Direct link to Links")

* [Constants](/reference/constants) in the Move Reference
* [Coding conventions for constants](/guides/code-quality-checklist#regular-constant-are-all_caps)

* [Naming Convention](#naming-convention)
* [Constants are Immutable](#constants-are-immutable)
* [Using Config Pattern](#using-config-pattern)
* [Links](#links)
Aborting Execution | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Aborting Execution

A transaction can either succeed or fail. Successful execution applies all changes made to objects
and on-chain data, and the transaction is committed to the blockchain. Alternatively, if a
transaction aborts, changes are not applied. Use the abort keyword to abort a transaction and
revert any changes that were made.

> It is important to note that there is no catch mechanism in Move. If a transaction aborts, the
> changes made so far are reverted, and the transaction is considered failed.

## Abort[​](#abort "Direct link to Abort")

The abort keyword is used to abort the execution of a transaction. It is used in combination with
an abort code, which is returned to the caller of the transaction. The abort code is an
[integer](/move-basics/primitive-types) of type u64.

```move
let user_has_access = false;  
  
// abort with a predefined constant if `user_has_access` is false  
if (!user_has_access) {  
    abort 1  
};
```

The code above will, of course, abort with abort code 1.

## assert![​](#assert "Direct link to assert!")

The assert! macro is a built-in macro that can be used to assert a condition. If the condition is
false, the transaction will abort with the given abort code. The assert! macro is a convenient way
to abort a transaction if a condition is not met. The macro shortens the code otherwise written with
an if expression + abort. The code argument is optional, but has to be a u64 value or an
#[error] (see below for more information).

```move
// aborts if `user_has_access` is `false` with abort code 0  
assert!(user_has_access, 0);  
  
// expands to:  
if (!user_has_access) {  
    abort 0  
};
```

## Error constants[​](#error-constants "Direct link to Error constants")

To make error codes more descriptive, it is a good practice to define
[error constants](/move-basics/constants). Error constants are defined as const declarations and are usually
prefixed with E followed by a camel case name. Error constants are similar to other constants and
do not have any special handling. However, they are commonly used to improve code readability and
make abort scenarios easier to understand.

```move
/// Error code for when the user has no access.  
const ENoAccess: u64 = 0;  
/// Trying to access a field that does not exist.  
const ENoField: u64 = 1;  
  
/// Updates a record.  
public fun update_record(/* ... , */ user_has_access: bool, field_exists: bool) {  
    // asserts are way more readable now  
    assert!(user_has_access, ENoAccess);  
    assert!(field_exists, ENoField);  
  
    /* ... */  
}
```

## Error messages[​](#error-messages "Direct link to Error messages")

Move 2024 introduces a special type of error constant, marked with the #[error] attribute. This
attribute allows the error constant to be of type vector<u8> and can be used to store an error
message.

```move
#[error]  
const ENotAuthorized: vector<u8> = b"The user is not authorized to perform this action";  
  
#[error]  
const EValueTooLow: vector<u8> = b"The value is too low, it should be at least 10";  
  
/// Performs an action on behalf of the user.  
public fun update_value(user: &mut User, value: u64) {  
    assert!(user.is_authorized, ENotAuthorized);  
    assert!(value >= 10, EValueTooLow);  
  
    user.value = value;  
}
```

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Abort and Assert](/reference/abort-and-assert) in the Move Reference.
* We suggest reading the [Better Error Handling](/guides/better-error-handling) guide to learn
  about best practices for error handling in Move.

* [Abort](#abort)
* [assert!](#assert)
* [Error constants](#error-constants)
* [Error messages](#error-messages)
* [Further Reading](#further-reading)
Functions | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Functions

Functions are the building blocks of Move programs. They are called from
[user transactions](/concepts/what-is-a-transaction) and from other functions and group
executable code into reusable units. Functions can take arguments and return a value. They are
declared with the fun keyword at the module level. Just like any other module member, by default
they're private and can only be accessed from within the module.

```move
module book::math;  
  
#[test_only]  
use std::unit_test::assert_eq;  
  
/// Function takes two arguments of type `u64` and returns their sum.  
/// The `public` visibility modifier makes the function accessible from  
/// outside the module.  
public fun add(a: u64, b: u64): u64 {  
    a + b  
}  
  
#[test]  
fun test_add() {  
    let sum = add(1, 2);  
    assert_eq!(sum, 3);  
}
```

In this example, we define a function add that takes two arguments of type u64 and returns their
sum. The test\_add function, located in the same module, is a test function that calls add. The
test uses the assert! macro to compare the result of add with the expected value. If the
condition inside assert! evaluates to false, the execution is aborted automatically.

## Function declaration[​](#function-declaration "Direct link to Function declaration")

> In Move, functions are typically named using the snake\_case convention. This means function
> names should be all lowercase, with words separated by underscores. Examples include
> do\_something, add, get\_balance, is\_authorized, and so on.

A function is declared with the fun keyword followed by the function name (a valid Move
identifier), a list of arguments in parentheses, and a return type. The function body is a block of
code that contains a sequence of statements and expressions. The last expression the function body
is the return value of the function.

```move
fun return_nothing() {  
    // empty expression, function returns `()`  
}
```

## Accessing functions[​](#accessing-functions "Direct link to Accessing functions")

Just like other module members, functions can be imported and accessed using a path. The path
consists of the module path and the function name, separated by ::. For example, if you have a
function named add in the math module within the book package, its full path would be
book::math::add. If the module has already been imported, you can access it directly as
math::add as in the following example:

```move
module book::use_math;  
  
use book::math;  
  
fun call_add() {  
    // function is called via the path  
    let sum = math::add(1, 2);  
}
```

## Multiple return values[​](#multiple-return-values "Direct link to Multiple return values")

Move functions can return multiple values, which is particularly useful when you need to return more
than one piece of data from a function. The return type is specified as a tuple of types, and the
return value is provided as a tuple of expressions:

```move
fun get_name_and_age(): (vector<u8>, u8) {  
    (b"John", 25)  
}
```

The result of a function call with a tuple return has to be unpacked into variables via the
let (tuple) syntax:

```move
// Tuple must be destructured to access its elements.  
// Name and age are declared as immutable variables.  
let (name, age) = get_name_and_age();  
assert_eq!(name, b"John");  
assert_eq!(age, 25);
```

If any of the declared values need to be declared as mutable, the mut keyword is placed before the
variable name:

```move
// declare name as mutable, age as immutable  
let (mut name, age) = get_name_and_age();
```

If some of the arguments are not used, they can be ignored with the \_ symbol:

```move
// ignore the name, only use the age  
let (_, age) = get_name_and_age();
```

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Functions](/reference/functions) in the Move Reference.

* [Function declaration](#function-declaration)
* [Accessing functions](#accessing-functions)
* [Multiple return values](#multiple-return-values)
* [Further Reading](#further-reading)
Struct Methods | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Struct Methods

Move Compiler supports *receiver syntax* e.f(), which allows defining methods which can be called
on instances of a struct. The term "receiver" specifically refers to the instance that receives the
method call. This is like the method syntax in other programming languages. It is a convenient way
to define functions that operate on the fields of a struct, providing direct access to the struct's
fields and creating cleaner, more intuitive code than passing the struct as a parameter.

## Method syntax[​](#method-syntax "Direct link to Method syntax")

If the first argument of a function is a struct internal to the module that defines the function,
then the function can be called using the . operator. However, if the type of the first argument
is defined in another module, then method won't be associated with the struct by default. In this
case, the . operator syntax is not available, and the function must be called using standard
function call syntax.

When a module is imported, its methods are automatically associated with the struct.

```move
module book::hero;  
  
/// A struct representing a hero.  
public struct Hero has drop {  
    health: u8,  
    mana: u8,  
}  
  
/// Create a new Hero.  
public fun new(): Hero { Hero { health: 100, mana: 100 } }  
  
/// A method which casts a spell, consuming mana.  
public fun heal_spell(hero: &mut Hero) {  
    hero.health = hero.health + 10;  
    hero.mana = hero.mana - 10;  
}  
  
/// A method which returns the health of the hero.  
public fun health(hero: &Hero): u8 { hero.health }  
  
/// A method which returns the mana of the hero.  
public fun mana(hero: &Hero): u8 { hero.mana }  
  
#[test_only]  
use std::unit_test::assert_eq;  
  
#[test]  
// Test the methods of the `Hero` struct.  
fun test_methods() {  
    let mut hero = new();  
    hero.heal_spell();  
  
    assert_eq!(hero.health(), 110);  
    assert_eq!(hero.mana(), 90);  
}
```

## Method Aliases[​](#method-aliases "Direct link to Method Aliases")

Method aliases help avoid name conflicts when modules define multiple structs and their methods.
They can also provide more descriptive method names for structs.

Here's the syntax:

```move
// for local method association  
use fun function_path as Type.method_name;  
  
// exported alias  
public use fun function_path as Type.method_name;
```

> Public aliases are only allowed for structs defined in the same module. For structs defined in
> other modules, aliases can still be created but cannot be made public.

In the example below, we changed the hero module and added another type - Villain. Both Hero
and Villain have similar field names and methods. To avoid name conflicts, we prefixed methods
with hero\_ and villain\_ respectively. However, using aliases allows these methods to be called
on struct instances without the prefix:

```move
module book::hero_and_villain;  
  
/// A struct representing a hero.  
public struct Hero has drop {  
    health: u8,  
}  
  
/// A struct representing a villain.  
public struct Villain has drop {  
    health: u8,  
}  
  
/// Create a new Hero.  
public fun new_hero(): Hero { Hero { health: 100 } }  
  
/// Create a new Villain.  
public fun new_villain(): Villain { Villain { health: 200 } }  
  
// Alias for the `hero_health` method. It will be imported automatically when  
// the module is imported.  
public use fun hero_health as Hero.health;  
  
public fun hero_health(hero: &Hero): u8 { hero.health }  
  
// Alias for the `villain_health` method. Will be imported automatically  
// when the module is imported.  
public use fun villain_health as Villain.health;  
  
public fun villain_health(villain: &Villain): u8 { villain.health }  
  
#[test_only]  
use std::unit_test::assert_eq;  
  
#[test]  
// Test the methods of the `Hero` and `Villain` structs.  
fun test_associated_methods() {  
    let hero = new_hero();  
    assert_eq!(hero.health(), 100);  
  
    let villain = new_villain();  
    assert_eq!(villain.health(), 200);  
}
```

In the test function, the health method is called directly on the Hero and Villain instances
without the prefix, as the compiler automatically associates the methods with their respective
structs.

> Note: In the test function, hero.health() is calling the aliased method, not directly accessing
> the private health field. While the Hero and Villain structs are public, their fields remain
> private to the module. The method call hero.health() uses the public alias defined by
> public use fun hero\_health as Hero.health, which provides controlled access to the private
> field.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Method Syntax](/reference/method-syntax) in the Move Reference.

* [Method syntax](#method-syntax)
* [Method Aliases](#method-aliases)
* [Further Reading](#further-reading)
Visibility Modifiers | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Visibility Modifiers

Every module member has a visibility. By default, all module members are *private* - meaning they
are only accessible within the module they are defined in. However, you can add a visibility
modifier to make a module member *public* - visible outside the module, or *public(package)* -
visible in the modules within the same package, or *entry* - can be called from a transaction but
can't be called from other modules.

## Internal Visibility[​](#internal-visibility "Direct link to Internal Visibility")

A function or a struct defined in a module which has no visibility modifier is *private* to the
module. It can't be called from other modules.

```move
module book::internal_visibility;  
  
// This function can be called from other functions in the same module  
fun internal() { /* ... */ }  
  
// Same module -> can call internal()  
fun call_internal() {  
    internal();  
}
```

The following code will not compile:

```move
module book::try_calling_internal;  
  
use book::internal_visibility;  
  
// Different module -> can't call internal()  
fun try_calling_internal() {  
    internal_visibility::internal();  
}
```

Note that just because a struct field is not visible from Move does not mean that its value is kept
confidential — it is always possible to read the contents of an on-chain object from outside
of Move. You should never store unencrypted secrets inside of objects.

## Public Visibility[​](#public-visibility "Direct link to Public Visibility")

A struct or a function can be made *public* by adding the public keyword before the fun or
struct keyword.

```move
module book::public_visibility;  
  
// This function can be called from other modules  
public fun public_fun() { /* ... */ }
```

A public function can be imported and called from other modules. The following code will compile:

```move
module book::try_calling_public;  
  
use book::public_visibility;  
  
// Different module -> can call public_fun()  
fun try_calling_public() {  
    public_visibility::public_fun();  
}
```

Unlike some languages, struct fields cannot be made public.

## Package Visibility[​](#package-visibility "Direct link to Package Visibility")

A function with *package* visibility can be called from any module within the same package, but not
from modules in other packages. In other words, it is *internal* to the package.

```move
module book::package_visibility;  
  
public(package) fun package_only() { /* ... */ }
```

A package function can be called from any module within the same package:

```move
module book::try_calling_package;  
  
use book::package_visibility;  
  
// Same package `book` -> can call package_only()  
fun try_calling_package() {  
    package_visibility::package_only();  
}
```

## Native Functions[​](#native-functions "Direct link to Native Functions")

Some functions in the [framework](/programmability/sui-framework) and
[standard library](/move-basics/standard-library) are marked with the native modifier. These functions are
natively provided by the Move VM and do not have a body in Move source code. To learn more about the
native modifier, refer to the
[Move Reference](/reference/functions?highlight=native#native-functions).

```move
module std::type_name;  
  
public native fun get<T>(): TypeName;
```

This is an example from std::type\_name, learn more about this module in the
[reflection chapter](/move-basics/type-reflection).

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Visibility](/reference/functions#visibility) in the Move Reference.

* [Internal Visibility](#internal-visibility)
* [Public Visibility](#public-visibility)
* [Package Visibility](#package-visibility)
* [Native Functions](#native-functions)
* [Further Reading](#further-reading)
Ownership and Scope | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Ownership and Scope

Every variable in Move has a scope and an owner. The scope is the range of code where the variable
is valid, and the owner is the scope that this variable belongs to. Once the owner scope ends, the
variable is dropped. This is a fundamental concept in Move, and it is important to understand how it
works.

## Ownership[​](#ownership "Direct link to Ownership")

A variable defined in a function scope is owned by this scope. The runtime goes through the function
scope and executes every expression and statement. After the function scope ends, the variables
defined in it are dropped or deallocated.

```move
module book::ownership;  
  
public fun owner() {  
    let a = 1; // a is owned by the `owner` function  
} // a is dropped here  
  
public fun other() {  
    let b = 2; // b is owned by the `other` function  
} // b is dropped here  
  
#[test]  
fun test_owner() {  
    owner();  
    other();  
    // a & b are not valid here  
}
```

In the example above, the variable a is owned by the owner function, and the variable b is
owned by the other function. When each of these functions are called, the variables are defined,
and when the function ends, the variables are discarded.

## Returning a Value[​](#returning-a-value "Direct link to Returning a Value")

If we changed the owner function to return the variable a, then the ownership of a would be
transferred to the caller of the function.

```move
module book::ownership;  
  
public fun owner(): u8 {  
    let a = 1; // a defined here  
    a // scope ends, a is returned  
}  
  
#[test]  
fun test_owner() {  
    let a = owner();  
    // a is valid here  
} // a is dropped here
```

## Passing by Value[​](#passing-by-value "Direct link to Passing by Value")

Additionally, if we passed the variable a to another function, the ownership of a would be
transferred to this function. When performing this operation, we *move* the value from one scope to
another. This is also called *move semantics*.

```move
module book::ownership;  
  
public fun owner(): u8 {  
    let a = 10;  
    a  
} // a is returned  
  
public fun take_ownership(v: u8) {  
    // v is owned by `take_ownership`  
} // v is dropped here  
  
#[test]  
fun test_owner() {  
    let a = owner();  
    // `u8` is copyable, pass `move a` when calling the function to force the transfer of its ownership  
    take_ownership(move a);  
    // a is not valid here  
}
```

## Scopes with Blocks[​](#scopes-with-blocks "Direct link to Scopes with Blocks")

Each function has a main scope, and it can also have sub-scopes via the use of blocks. A block is a
sequence of statements and expressions, and it has its own scope. Variables defined in a block are
owned by this block, and when the block ends, the variables are dropped.

```move
module book::ownership;  
  
public fun owner() {  
    let a = 1; // a is owned by the `owner` function's scope  
    {  
        let b = 2; // the block that declares b owns it  
        {  
            let c = 3; // the block that declares c owns it  
        }; // c is dropped here  
    }; // b is dropped here  
    // a = b; // error: b is not valid here  
    // a = c; // error: c is not valid here  
} // a is dropped here
```

However, if we return a value from a block, the ownership of the variable is transferred to the
caller of the block.

```move
module book::ownership;  
  
public fun owner(): u8 {  
    let a = 1; // a is owned by the `owner` function's scope  
    let b = {  
        let c = 2; // the block that declares c owns it  
        c // c is returned from the block and transferred to b  
    };  
    a + b // both a and b are valid here  
}
```

## Copyable Types[​](#copyable-types "Direct link to Copyable Types")

Some types in Move are *copyable*, which means that they can be copied without transferring
ownership. This is useful for types that are small and cheap to copy, such as integers and booleans.
The Move compiler will automatically copy these types when they are passed to or returned from a
function, or when they're *moved* to another scope and then accessed in their original scope.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Local Variables and Scopes](/reference/variables) in the Move Reference.

* [Ownership](#ownership)
* [Returning a Value](#returning-a-value)
* [Passing by Value](#passing-by-value)
* [Scopes with Blocks](#scopes-with-blocks)
* [Copyable Types](#copyable-types)
* [Further Reading](#further-reading)
Abilities: Copy | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Abilities: Copy

In Move, the *copy* ability on a type indicates that the instance or the value of the type can be
copied, or duplicated. While this behavior is provided by default when working with numbers or other
primitive types, it is not the default for custom types. Move is designed to express digital assets
and resources, and controlling the ability to duplicate resources is a key principle of the resource
model. However, the Move type system allows you to add the *copy* ability to custom types:

```move
public struct Copyable has copy {}
```

In the example above, we define a custom type Copyable with the *copy* ability. This means that
instances of Copyable can be copied, both implicitly and explicitly.

```move
let a = Copyable {}; // allowed because the Copyable struct has the `copy` ability  
let b = a;   // `a` is copied to `b`  
let c = *&b; // explicit copy via dereference operator  
  
// Copyable doesn't have the `drop` ability, so every instance (a, b, and c) must  
// be used or explicitly destructured. The `drop` ability is explained below.  
let Copyable {} = a;  
let Copyable {} = b;  
let Copyable {} = c;
```

In the example above, a is copied to b implicitly, and then explicitly copied to c using the
dereference operator. If Copyable did not have the *copy* ability, the code would not compile, and
the Move compiler would raise an error.

> Note: In Move, destructuring with empty brackets is often used to consume unused variables,
> especially for types without the drop ability. This prevents compiler errors from values going out
> of scope without explicit use. Also, Move requires the type name in destructuring (e.g.,
> Copyable in let Copyable {} = a;) because it enforces strict typing and ownership rules.

## Copying and Drop[​](#copying-and-drop "Direct link to Copying and Drop")

The copy ability is closely related to the [drop ability](/move-basics/drop-ability). If a type has the
*copy* ability, it is very likely that it should have drop too. This is because the *drop* ability
is required to clean up resources when the instance is no longer needed. If a type only has *copy*,
managing its instances gets more complicated, as the instances must be explicitly used or consumed.

```move
public struct Value has copy, drop {}
```

All of the primitive types in Move behave as if they have the *copy* and *drop* abilities. This
means that they can be copied and dropped, and the Move compiler will handle the memory management
for them.

## Types with the copy Ability[​](#types-with-the-copy-ability "Direct link to types-with-the-copy-ability")

All native types in Move have the copy ability. This includes:

* [bool](/move-basics/primitive-types#booleans)
* [unsigned integers](/move-basics/primitive-types#integer-types)
* [vector](/move-basics/vector)
* [address](/move-basics/address)

All of the types defined in the standard library have the copy ability as well. This includes:

* [Option](/move-basics/option)
* [String](/move-basics/string)
* [TypeName](/move-basics/type-reflection)

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Type Abilities](/reference/abilities) in the Move Reference.

* [Copying and Drop](#copying-and-drop)
* [Types with the `copy` Ability](#types-with-the-copy-ability)
* [Further Reading](#further-reading)
References | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# References

In the [Ownership and Scope](/move-basics/ownership-and-scope) section, we explained that when a value is
passed to a function, it is *moved* to the function's scope. This means that the function becomes
the owner of the value, and the original scope (owner) can no longer use it. This is an important
concept in Move, as it ensures that the value is not used in multiple places at the same time.
However, there are use cases when we want to pass a value to a function but retain ownership. This
is where references come into play.

To illustrate this, let's consider a simple example - an application for a metro (subway) pass. We
will look at 4 different scenarios where a card can be:

1. Purchased at a kiosk for a fixed price
2. Shown to an inspector to prove that the passenger has a valid pass
3. Used at the turnstile to enter the metro, and purchase a ride
4. Recycled after it's empty

## Layout[​](#layout "Direct link to Layout")

The initial layout of the metro pass application is simple. We define the Card type and the USES
[constant](/move-basics/constants) that represents the number of rides on a single card. We also add
[error constants](/move-basics/assert-and-abort#error-constants) for the case when the card is empty and when the card is not empty.

```move
module book::metro_pass;  
  
/// Error code for when the card is empty.  
const ENoUses: u64 = 0;  
/// Error code for when the card is not empty.  
const EHasUses: u64 = 1;  
  
/// Number of uses for a metro pass card.  
const USES: u8 = 3;  
  
/// A metro pass card  
public struct Card { uses: u8 }  
  
/// Purchase a metro pass card.  
public fun purchase(/* pass a Coin */): Card {  
    Card { uses: USES }  
}
```

## References[​](#references-1 "Direct link to References")

References are a way to *show* a value to a function without giving up ownership. In our case, when
we show the Card to the inspector, we don't want to give up ownership of it, and we don't allow the
inspector to use up any of our rides. We just want to allow the *reading* of the value of our Card
and to prove its ownership.

To do so, in the function signature, we use the & symbol to indicate that we are passing a
*reference* to the value, not the value itself.

```move
/// Show the metro pass card to the inspector.  
public fun is_valid(card: &Card): bool {  
    card.uses > 0  
}
```

Because the function does not take ownership of the Card, it can *read* its data but cannot *write*
to it, meaning it cannot modify the number of rides. Additionally, the function signature ensures
that it cannot be called without a Card instance. This is an important property that allows the
[Capability Pattern](/programmability/capability), which we will cover in the next chapters.

Creating a reference to a value is often referred to as "borrowing" the value. For example, the
method to get a reference to the value wrapped by an Option is called borrow.

## Mutable Reference[​](#mutable-reference "Direct link to Mutable Reference")

In some cases, we want to allow the function to modify the Card. For example, when using the Card at
a turnstile, we need to deduct a ride. To achieve this, we use the &mut keyword in the function
signature.

```move
/// Use the metro pass card at the turnstile to enter the metro.  
public fun enter_metro(card: &mut Card) {  
    assert!(card.uses > 0, ENoUses);  
    card.uses = card.uses - 1;  
}
```

As you can see in the function body, the &mut reference allows mutating the value, and the
function can spend rides.

## Passing by Value[​](#passing-by-value "Direct link to Passing by Value")

Lastly, let's illustrate what happens when we pass the value itself to the function. In this case,
the function takes the ownership of the value, making it inaccessible in the original scope. The
owner of the Card can recycle it and thereby relinquish ownership to the function.

```move
/// Recycle the metro pass card.  
public fun recycle(card: Card) {  
    assert!(card.uses == 0, EHasUses);  
    let Card { uses: _ } = card;  
}
```

In the recycle function, the Card is passed by value, transferring ownership to the function. This
allows it to be unpacked and destroyed.

> Note: In Move, \_ is a wildcard pattern used in destructuring to ignore a field while still
> consuming the value. Destructuring must match all fields in a struct type. If a struct has fields,
> you must list all of them explicitly or use \_ to ignore unwanted fields.

## Full Example[​](#full-example "Direct link to Full Example")

To illustrate the full flow of the application, let's put all the pieces together in a test.

```move
#[test]  
fun test_card_2024() {  
    // declaring variable as mutable because we modify it  
    let mut card = purchase();  
  
    card.enter_metro(); // modify the card but don't move it  
    assert!(card.is_valid()); // read the card!  
  
    card.enter_metro(); // modify the card but don't move it  
    card.enter_metro(); // modify the card but don't move it  
  
    card.recycle(); // move the card out of the scope  
}
```

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [References](/reference/primitive-types/references) in the Move
  Reference.

* [Layout](#layout)
* [References](#references-1)
* [Mutable Reference](#mutable-reference)
* [Passing by Value](#passing-by-value)
* [Full Example](#full-example)
* [Further Reading](#further-reading)
Generics | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Generics

Generics are a way to define a type or function that can work with any type. This is useful when you
want to write a function which can be used with different types, or when you want to define a type
that can hold any other type. Generics are the foundation of many advanced features in Move
including collections, abstract implementations, and more.

## In the Standard Library[​](#in-the-standard-library "Direct link to In the Standard Library")

In this chapter we already mentioned the [vector](/move-basics/vector) type, which is a generic type that can
hold any other type. Another example of a generic type in the standard library is the
[Option](/move-basics/option) type, which is used to represent a value that may or may not be present.

## Generic Syntax[​](#generic-syntax "Direct link to Generic Syntax")

To define a generic type or function, a type signature needs to have a list of generic parameters
enclosed in angle brackets (< and >). The generic parameters are separated by commas.

```move
/// Container for any type `T`.  
public struct Container<T> has drop {  
    value: T,  
}  
  
/// Function that creates a new `Container` with a generic value `T`.  
public fun new<T>(value: T): Container<T> {  
    Container { value }  
}
```

In the example above, Container is a generic type with a single type parameter T, the value
field of the container stores the T. The new function is a generic function with a single type
parameter T, and it returns a Container with the given value. Generic types must be initialized
with a concrete type, and generic functions must be called with a concrete type, although in some
cases the Move compiler can infer the correct type.

```move
#[test]  
fun test_container() {  
    // these three lines are equivalent  
    let container: Container<u8> = new(10); // type inference  
    let container = new<u8>(10); // create a new `Container` with a `u8` value  
    let container = new(10u8);  
  
    assert_eq!(container.value, 10);  
  
    // Value can be ignored only if it has the `drop` ability.  
    let Container { value: _ } = container;  
}
```

In the test function test\_container, we demonstrate three equivalent ways to create a new
Container with a u8 value. Because numeric constants have ambiguous types, we must specify the
type of the number literal somewhere (in the type of the container, the parameter to new, or the
number literal itself); once we specify one of these the compiler can infer the others.

## Multiple Type Parameters[​](#multiple-type-parameters "Direct link to Multiple Type Parameters")

You can define a type or function with multiple type parameters. The type parameters are separated
by commas.

```move
/// A pair of values of any type `T` and `U`.  
public struct Pair<T, U> {  
    first: T,  
    second: U,  
}  
  
/// Function that creates a new `Pair` with two generic values `T` and `U`.  
public fun new_pair<T, U>(first: T, second: U): Pair<T, U> {  
    Pair { first, second }  
}
```

In the example above, Pair is a generic type with two type parameters T and U, and the
new\_pair function is a generic function with two type parameters T and U. The function returns
a Pair with the given values. The order of the type parameters is important, and should match the
order of the type parameters in the type signature.

```move
#[test]  
fun test_generic() {  
    // these three lines are equivalent  
    let pair_1: Pair<u8, bool> = new_pair(10, true); // type inference  
    let pair_2 = new_pair<u8, bool>(10, true); // create a new `Pair` with a `u8` and `bool` values  
    let pair_3 = new_pair(10u8, true);  
  
    assert_eq!(pair_1.first, 10);  
    assert_eq!(pair_1.second, true);  
  
    // Unpacking is identical.  
    let Pair { first: _, second: _ } = pair_1;  
    let Pair { first: _, second: _ } = pair_2;  
    let Pair { first: _, second: _ } = pair_3;  
  
}
```

If we added another instance where we swapped type parameters in the new\_pair function, and tried
to compare two types, we'd see that the type signatures are different, and cannot be compared.

```move
#[test]  
fun test_swap_type_params() {  
    let pair1: Pair<u8, bool> = new_pair(10u8, true);  
    let pair2: Pair<bool, u8> = new_pair(true, 10u8);  
  
    // this line will not compile  
    // assert_eq!(pair1, pair2);  
  
    let Pair { first: pf1, second: ps1 } = pair1; // first1: u8, second1: bool  
    let Pair { first: pf2, second: ps2 } = pair2; // first2: bool, second2: u8  
  
    assert_eq!(pf1, ps2); // 10 == 10  
    assert_eq!(ps1, pf2); // true == true  
}
```

Since the types for pair1 and pair2 are different, the comparison pair1 == pair2 will not
compile.

## Why Generics?[​](#why-generics "Direct link to Why Generics?")

In the examples above we focused on instantiating generic types and calling generic functions to
create instances of these types. However, the real power of generics lies in their ability to define
shared behavior for the base, generic type, and then use it independently of the concrete types.
This is especially useful when working with collections, abstract implementations, and other
advanced features in Move.

```move
/// A user record with name, age, and some generic metadata  
public struct User<T> {  
    name: String,  
    age: u8,  
    /// Varies depending on application.  
    metadata: T,  
}
```

In the example above, User is a generic type with a single type parameter T, with shared fields
name, age, and the generic metadata field, which can store any type. No matter what metadata
is, all instances of User will contain the same fields and methods.

```move
/// Updates the name of the user.  
public fun update_name<T>(user: &mut User<T>, name: String) {  
    user.name = name;  
}  
  
/// Updates the age of the user.  
public fun update_age<T>(user: &mut User<T>, age: u8) {  
    user.age = age;  
}
```

## Phantom Type Parameters[​](#phantom-type-parameters "Direct link to Phantom Type Parameters")

In some cases, you may want to define a generic type with a type parameter that is not used in the
fields or methods of the type. This is called a *phantom type parameter*. Phantom type parameters
are useful when you want to define a type that can hold any other type, but you want to enforce some
constraints on the type parameter.

```move
/// A generic type with a phantom type parameter.  
public struct Coin<phantom T> {  
    value: u64  
}
```

The Coin type here does not contain any fields or methods that use the type parameter T. It is
used to differentiate between different types of coins, and to enforce some constraints on the type
parameter T.

```move
public struct USD {}  
public struct EUR {}  
  
#[test]  
fun test_phantom_type() {  
    let coin1: Coin<USD> = Coin { value: 10 };  
    let coin2: Coin<EUR> = Coin { value: 20 };  
  
    // Unpacking is identical because the phantom type parameter is not used.  
    let Coin { value: _ } = coin1;  
    let Coin { value: _ } = coin2;  
}
```

In the example above, we demonstrate how to create two different instances of Coin with different
phantom type parameters USD and EUR. The type parameter T is not used in the fields or methods
of the Coin type, but it is used to differentiate between different types of coins. This helps
ensure that the USD and EUR coins are not mistakenly mixed up.

## Constraints on Type Parameters[​](#constraints-on-type-parameters "Direct link to Constraints on Type Parameters")

Type parameters can be constrained to have certain abilities. This is useful when you need the inner
type to allow certain behaviors, such as *copy* or *drop*. The syntax for constraining a type
parameter is T: <ability> + <ability>.

```move
/// A generic type with a type parameter that has the `drop` ability.  
public struct Droppable<T: drop> {  
    value: T,  
}  
  
/// A generic struct with a type parameter that has the `copy` and `drop` abilities.  
public struct CopyableDroppable<T: copy + drop> {  
    value: T, // T must have the `copy` and `drop` abilities  
}
```

The Move Compiler will enforce that the type parameter T has the specified abilities. If the type
parameter does not have the specified abilities, the code will not compile.

```move
/// Type without any abilities.  
public struct NoAbilities {}  
  
#[test]  
fun test_constraints() {  
    // Fails - `NoAbilities` does not have the `drop` ability  
    // let droppable = Droppable<NoAbilities> { value: 10 };  
  
    // Fails - `NoAbilities` does not have the `copy` and `drop` abilities  
    // let copyable_droppable = CopyableDroppable<NoAbilities> { value: 10 };  
}
```

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Generics](/reference/generics) in the Move Reference.

* [In the Standard Library](#in-the-standard-library)
* [Generic Syntax](#generic-syntax)
* [Multiple Type Parameters](#multiple-type-parameters)
* [Why Generics?](#why-generics)
* [Phantom Type Parameters](#phantom-type-parameters)
* [Constraints on Type Parameters](#constraints-on-type-parameters)
* [Further Reading](#further-reading)
Type Reflection | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Type Reflection

In programming languages, *reflection* is the ability of a program to examine and modify its own
structure and behavior. Move supports a limited form of reflection that lets you inspect the type of
a value at runtime. This is handy when you need to store type information in a homogeneous
collection, or when you want to check if a type comes from a particular package.

Type reflection is implemented in the [Standard Library](/move-basics/standard-library) module
[std::type\_name](https://docs.sui.io/references/framework/std/type_name). It provides a set of functions, main of which are
with\_defining\_ids and with\_original\_ids.

```move
let defining_type_name: TypeName = type_name::with_defining_ids<T>();  
let original_type_name: TypeName = type_name::with_original_ids<T>();  
  
// Returns only "ID" of the package.  
let defining_package: address = type_name::defining_id<T>();  
let original_package: address = type_name::original_id<T>();
```

## Defining IDs vs. Original IDs[​](#defining-ids-vs-original-ids "Direct link to Defining IDs vs. Original IDs")

It is important to understand the difference between *defining ID* and *original ID*.

* Original ID is the first published ID of the package (before the first upgrade).
* Defining ID is the package ID which introduced the reflected type, this property becomes crucial
  when new types are introduced in package upgrades.

For example, suppose the first version of a package was published at 0xA and introduced the type
Version1. Later, in an upgrade, the package moved to address 0xB and introduced a new type
Version2. For Version1, the defining ID and original ID are the same. For Version2, however,
they differ: the original ID is 0xA, while the defining ID is 0xB.

```move
// Note: values `0xA` and `0xB` are used for illustration purposes only!  
// Don't attempt to run this code, as it will inevitably fail.  
module book::upgrade;  
  
// Introduced in initial version.  
// Defining ID: 0xA  
// Original ID: 0xA  
//  
// With Defining IDs: 0xA::upgrade::Version1  
// With Original IDs: 0xA::upgrade::Version1  
public struct Version1 has drop {}  
  
// Introduced in a package upgrade.  
// Defining ID: 0xB  
// Original ID: 0xA  
//  
// With Defining IDs: 0xB::upgrade::Version2  
// With Original IDs: 0xA::upgrade::Version2  
public struct Version2 has drop {}
```

## In practice[​](#in-practice "Direct link to In practice")

The module is straightforward, and operations allowed on the result are limited to getting a string
representation and extracting the module and address of the type.

```move
module book::type_reflection;  
  
use std::ascii::String;  
use std::type_name::{Self, TypeName};  
  
/// A function that returns the name of the type `T` and its module and address.  
public fun do_i_know_you<T>(): (String, String, String) {  
    let type_name: TypeName = type_name::with_defining_ids<T>();  
  
    // there's a way to borrow  
    let str: &String = type_name.as_string();  
  
    let module_name: String = type_name.module_string();  
    let address_str: String = type_name.address_string();  
  
    // and a way to consume the value  
    let str = type_name.into_string();  
  
    (str, module_name, address_str)  
}  
  
#[test_only]  
public struct MyType {}  
  
#[test_only]  
use std::unit_test::assert_eq;  
  
#[test]  
fun test_type_reflection() {  
    let (type_name, module_name, _address_str) = do_i_know_you<MyType>();  
  
    assert_eq!(module_name, b"type_reflection".to_ascii_string());  
}
```

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [std::type\_name](https://docs.sui.io/references/framework/std/type_name) module documentation.

* [Defining IDs vs. Original IDs](#defining-ids-vs-original-ids)
* [In practice](#in-practice)
* [Further Reading](#further-reading)
Testing | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Testing

Testing is a crucial aspect of software development, especially in blockchain applications where
security and correctness are paramount. In this section, we will cover the fundamentals of testing
in Move, including how to write and organize tests effectively.

## The #[test] Attribute[​](#the-test-attribute "Direct link to the-test-attribute")

Tests in Move are functions marked with the #[test] attribute. This attribute tells the compiler
that the function is a test function and should be run when tests are executed. Test functions are
regular functions, but they must take no arguments and have no return value. They are excluded from
the bytecode and are never published.

```move
module book::testing;  
  
#[test_only]  
use std::unit_test::assert_eq;  
  
// The test attribute is placed before the `fun` keyword (can be both above or  
// right before the `fun` keyword, as in `#[test] fun my_test() { ... }`)  
// The name of the test in this case would be `book::testing::simple_test`.  
#[test]  
fun simple_test() {  
    let sum = 2 + 2;  
    assert_eq!(sum, 4);  
}  
  
// The name of this test would be `book::testing::more_advanced_test`.  
#[test] fun more_advanced_test() {  
    let sum = 2 + 2 + 2;  
    assert_eq!(sum, 4);  
}
```

## Running Tests[​](#running-tests "Direct link to Running Tests")

To run tests, you can use the sui move test command. This command will first build the package in
*test mode* and then run all tests found in the package. In test mode, modules from both sources/
and tests/ directories are processed and their tests executed.

```move
$ sui move test  
> UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git  
> INCLUDING DEPENDENCY Bridge  
> INCLUDING DEPENDENCY DeepBook  
> INCLUDING DEPENDENCY SuiSystem  
> INCLUDING DEPENDENCY Sui  
> INCLUDING DEPENDENCY MoveStdlib  
> BUILDING book  
> Running Move unit tests  
> ...
```

## Test Fail Cases with #[expected\_failure][​](#test-fail-cases-with-expected_failure "Direct link to test-fail-cases-with-expected_failure")

Tests for fail cases can be marked with #[expected\_failure]. This attribute, when added to a
#[test] function, tells the compiler that the test is expected to fail. This is useful when you
want to test that a function fails when a certain condition is met.

> Note: This attribute can only be added to a #[test] function.

The attribute can take an argument specifying the expected abort code that should be returned if the
test fails. If the test returns an abort code different from the one specified in the argument, it
will fail. Likewise, if execution does not result in an abort, the test will also fail.

```move
module book::testing_failure;  
  
const EInvalidArgument: u64 = 1;  
  
#[test]  
#[expected_failure(abort_code = 0)]  
fun test_fail() {  
    abort 0 // aborts with code 0  
}  
  
// attributes can be grouped together  
#[test, expected_failure(abort_code = EInvalidArgument)]  
fun test_fail_1() {  
    abort EInvalidArgument // aborts with code EInvalidArgument  
}
```

The abort\_code argument can use constants defined in the tests module as well as imported from
other modules. This is the only case where constants can be used and "accessed" in other modules.

## Utilities with #[test\_only][​](#utilities-with-test_only "Direct link to utilities-with-test_only")

In some cases, it is helpful to give the test environment access to some internal functions or
features. This simplifies the testing process and allows for more thorough testing. However, it is
important to remember that these functions should not be included in the final package. This is
where the #[test\_only] attribute comes in handy.

```move
module book::testing;  
  
#[test_only]  
use std::unit_test::assert_eq;  
  
// Public function which uses the `secret` function.  
public fun multiply_by_secret(x: u64): u64 {  
    x * secret()  
}  
  
/// Private function which is not available to the public.  
fun secret(): u64 { 100 }  
  
#[test_only]  
/// This function is only available for testing purposes in tests and other  
/// test-only functions. Mind the visibility - for `#[test_only]` it is  
/// common to use `public` visibility.  
public fun secret_for_testing(): u64 {  
    secret()  
}  
  
#[test]  
// In the test environment we have access to the `secret_for_testing` function.  
fun test_multiply_by_secret() {  
    let expected = secret_for_testing() * 2;  
    assert_eq!(multiply_by_secret(2), expected);  
}
```

Functions marked with the #[test\_only] will be available to the test environment, and to the other
modules if their visibility is set to public.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Unit Testing](/reference/unit-testing) in the Move Reference.

* [The `#[test]` Attribute](#the-test-attribute)
* [Running Tests](#running-tests)
* [Test Fail Cases with `#[expected_failure]`](#test-fail-cases-with-expected_failure)
* [Utilities with `#[test_only]`](#utilities-with-test_only)
* [Further Reading](#further-reading)
Object Model | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Object Model

This chapter describes the Object Model of Sui. It focuses on the theory and concepts behind the
Object Model, preparing you for a practical dive into Sui Storage operations and resource ownership.
For convenience and easier lookup, we split the chapter into several sections, each covering a
specific aspect of the Object Model.

In no way should this chapter be considered a comprehensive guide to the Object Model. It is only a
high-level overview of the concepts and principles behind the Object Model.

For a more detailed description, refer to the
[Sui Documentation](https://docs.sui.io/concepts/object-model).
Move - Language for Digital Assets | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Move - Language for Digital Assets

Smart-contract programming languages have historically focused on defining and managing digital
assets. For example, the ERC-20 standard in Ethereum pioneered a set of standards to interact with
digital currency tokens, establishing a blueprint for creating and managing digital currencies on
the blockchain. Subsequently, the introduction of the ERC-721 standard marked a significant
evolution, popularizing the concept of non-fungible tokens (NFTs), which represent unique,
indivisible assets. These standards laid the groundwork for the complex digital assets we see today.

However, Ethereum's programming model lacked a native representation of assets. In other words,
externally, a Smart Contract behaved like an asset, but the language itself did not have a way to
inherently represent assets. From the start, Move aimed to provide a first-class abstraction for
assets, opening up new avenues for thinking about and programming assets.

It is important to highlight which properties are essential for an asset:

* **Ownership:** Every asset is associated with an owner(s), mirroring the straightforward concept
  of ownership in the physical world—just as you own a car, you can own a digital asset. Move
  enforces ownership in such a way that once an asset is *moved*, the previous owner completely
  loses any control over it. This mechanism ensures a clear and secure change of ownership.
* **Non-copyable:** In the real world, unique items cannot be duplicated effortlessly. Move applies
  this principle to digital assets, ensuring they cannot be arbitrarily copied within the program.
  This property is crucial for maintaining the scarcity and uniqueness of digital assets, mirroring
  the intrinsic value of physical assets.
* **Non-discardable:** Just as you cannot accidentally lose a house or a car without a trace, Move
  ensures that no asset can be discarded or lost in a program. Instead, assets must be explicitly
  transferred or destroyed. This property guarantees the deliberate handling of digital assets,
  preventing accidental loss and ensuring accountability in asset management.

Move managed to encapsulate these properties in its design, becoming an ideal language for digital
assets.

## Summary[​](#summary "Direct link to Summary")

* Move was designed to provide a first-class abstraction for digital assets, enabling developers to
  create and manage assets natively.
* Essential properties of digital assets include ownership, non-copyability, and non-discardability,
  which Move enforces in its design.
* Move's asset model mirrors real-world asset management, ensuring secure and accountable asset
  ownership and transfer.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Move: A Language With Programmable Resources (pdf)](https://developers.diem.com/papers/diem-move-a-language-with-programmable-resources/2019-06-18.pdf)
  by Sam Blackshear, Evan Cheng, David L. Dill, Victor Gao, Ben Maurer, Todd Nowacki, Alistair Pott,
  Shaz Qadeer, Rain, Dario Russi, Stephane Sezer, Tim Zakian, Runtian Zhou\*

* [Summary](#summary)
* [Further Reading](#further-reading)
Evolution of Move | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Evolution of Move

While Move was created to manage digital assets, its initial storage model was bulky and not
well-suited for many use cases. For instance, if Alice wanted to transfer an asset X to Bob, Bob had
to create a new "empty" resource, and then Alice could transfer asset X to Bob. This process was not
intuitive and presented implementation challenges, partly due to the restrictive design of
[Diem](https://www.diem.com/en-us). Another drawback of the original design was the lack of built-in
support for a "transfer" operation, requiring every module to implement its own storage transfer
logic. Additionally, managing heterogeneous collections of assets in a single account was
particularly challenging.

Sui addressed these challenges by redesigning the storage and ownership model of objects to more
closely resemble real-world object interactions. With a native concept of ownership and *transfer*,
Alice can directly transfer asset X to Bob. Furthermore, Bob can maintain a collection of different
assets without any preparatory steps. These improvements laid the foundation for the Object Model in
Sui.

## Summary[​](#summary "Direct link to Summary")

* Move's initial storage model was not well-suited for managing digital assets, requiring complex
  and restrictive transfer operations.
* Sui introduced the Object Model, which provides a native concept of ownership, simplifying asset
  management and enabling heterogeneous collections.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Why We Created Sui Move](https://blog.sui.io/why-we-created-sui-move/) by Sam Blackshear

* [Summary](#summary)
* [Further Reading](#further-reading)
What is an Object? | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# What is an Object?

The Object Model in Sui can be viewed as a high-level abstraction representing digital assets as
*objects*. These objects have their own type and associated behaviors, a unique identifier, and
support native storage operations like *transfer* and *share*. Designed to be intuitive and easy to
use, the Object Model enables a wide range of use cases to be implemented with ease.

Objects in Sui have the following properties:

* **Type:** Every object has a type, defining the structure and behavior of the object. Objects of
  different types cannot be mixed or used interchangeably, ensuring objects are used correctly
  according to their type system.
* **Unique ID:** Each object has a unique identifier, distinguishing it from other objects. This ID
  is generated upon the object's creation and is immutable. It's used to track and identify objects
  within the system.

* **Owner:** Every object is associated with an owner, who has control over changes to the object.
  Ownership on Sui can be exclusive to an account, shared across the network, or frozen, allowing
  read-only access without modification or transfer capabilities. We will discuss ownership in more
  detail in the following sections.

  Note that ownership does not control the confidentiality of an object — it is always
  possible to read the contents of an on-chain object from outside of Move. You should never store
  unencrypted secrets inside of objects.
* **Data:** Objects encapsulate their data, simplifying management and manipulation. The data
  structure and operations are defined by the object's type.
* **Version:** The transition from accounts to objects is facilitated by object versioning.
  Traditionally, blockchains use a *nonce* to prevent replay attacks. In Sui, the object's version
  acts as a nonce, preventing replay attacks for each object.
* **Digest:** Every object has a digest, which is a hash of the object's data. The digest is used to
  cryptographically verify the integrity of the object's data and ensures that it has not been
  tampered with. The digest is calculated when the object is created and is updated whenever the
  object's data changes.

## Summary[​](#summary "Direct link to Summary")

* Objects in Sui are high-level abstractions representing digital assets.
* Objects have a type, unique ID, owner, data, version, and digest.
* The Object Model simplifies asset management and enables a wide range of use cases.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Object Model](https://docs.sui.io/concepts/object-model) in Sui Documentation.

* [Summary](#summary)
* [Further Reading](#further-reading)
Ownership | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Ownership

Sui introduces four distinct ownership types for objects: single owner, shared state, immutable
shared state, and object-owner. Each model offers unique characteristics and suits different use
cases, enhancing flexibility and control in object management.

Note that ownership does not control the confidentiality of an object — it is always possible
to read the contents of an on-chain object from outside of Move. You should never store unencrypted
secrets inside of objects.

See the [Storage Functions](/storage/storage-functions) chapter for details on how to change
the owner or ownership type of an object.

## Account Owner (or Single Owner)[​](#account-owner-or-single-owner "Direct link to Account Owner (or Single Owner)")

The account owner, also known as the *single owner* model, is the foundational ownership type in
Sui. Here, an object is owned by a single account, granting that account exclusive control over the
object within the behaviors associated with its type. This model embodies the concept of *true
ownership*, where the account possesses complete authority over the object, making it inaccessible
to others for modification or transfer. This level of ownership clarity is a significant advantage
over other blockchain systems, where ownership definitions can be more ambiguous, and smart
contracts may have the ability to alter or transfer assets without the owner's consent.

Just like your private mobile phone, you own it, you can easily unlock and operate it, but others cannot.
Sui is designed to prevent things like cracking someone else's phone password (bypassing permission
checks to use objects that do not belong to others). Therefore, no one can use your assets unless
authorized by you.

## Shared State[​](#shared-state "Direct link to Shared State")

Single owner model has its limitations: for example, it is very tricky to implement a marketplace
for digital assets without a shared state. For a generic marketplace scenario, imagine that Alice
owns an asset X, and she wants to sell it by putting it into a shared marketplace. Then Bob can come
and buy the asset directly from the marketplace. The reason why this is tricky is that it is
impossible to write a smart contract that would "lock" the asset in Alice's account and take it out
when Bob buys it. First, it will be a violation of the single owner model, and second, it requires a
shared access to the asset.

To facilitate a problem of shared data access, Sui has introduced a shared ownership model. In this
model, an object can be shared with the network. Shared objects can be read and modified by any
account on the network, and the rules of interaction are defined by the implementation of the
object. Typical uses for shared objects are: marketplaces, shared resources, escrows, and other
scenarios where multiple accounts need access to the same state.

## Immutable (Frozen) State[​](#immutable-frozen-state "Direct link to Immutable (Frozen) State")

Sui also offers the *frozen object* model, where an object becomes permanently read-only. These
immutable objects, while readable, cannot be modified or moved, providing a stable and constant
state accessible to all network participants. Frozen objects are ideal for public data, reference
materials, and other use cases where the state permanence is desirable.

## Object Owner[​](#object-owner "Direct link to Object Owner")

The last ownership model in Sui is the *object owner*. In this model, an object is owned by another
object. This feature allows creating complex relationships between objects, storing large
heterogeneous collections, and implementing extensible and modular systems. Practically speaking,
since the transactions are initiated by accounts, the transaction still accesses the parent object,
but it can then access the child objects through the parent object.

A use case we love to mention is a game character. Alice can own the Hero object from a game, and
the Hero can own items: also represented as objects, like a "Map", or a "Compass". Alice may take
the "Map" from the "Hero" object, and then send it to Bob, or sell it on a marketplace. With object
owner, it becomes very natural to imagine how the assets can be structured and managed in relation
to each other.

## Summary[​](#summary "Direct link to Summary")

* **Single Owner:** Objects are owned by a single account, granting exclusive control over the
  object.
* **Shared State:** Objects can be shared with the network, allowing multiple accounts to read and
  modify the object.
* **Immutable State:** Objects become permanently read-only, providing a stable and constant state.
* **Object Owner:** Objects can own other objects, enabling complex relationships and modular
  systems.

## Next Steps[​](#next-steps "Direct link to Next Steps")

In the next section we will talk about transaction execution paths in Sui, and how the ownership
models affect the transaction execution.

* [Account Owner (or Single Owner)](#account-owner-or-single-owner)
* [Shared State](#shared-state)
* [Immutable (Frozen) State](#immutable-frozen-state)
* [Object Owner](#object-owner)
* [Summary](#summary)
* [Next Steps](#next-steps)
Fast Path & Consensus | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Fast Path & Consensus

The Object Model allows for variable transaction execution paths, depending on the object's
ownership type. The transaction execution path determines how the transaction is processed and
validated by the network. In this section, we'll explore the different transaction execution paths
in Sui and how they interact with the consensus mechanism.

## Concurrency Challenge[​](#concurrency-challenge "Direct link to Concurrency Challenge")

At its core, blockchain technology faces a fundamental concurrency challenge: multiple parties may
try to modify or access the same data simultaneously in a decentralized environment. This requires a
system for sequencing and validating transactions to support the network's consistency. Sui
addresses this challenge through a consensus mechanism, ensuring all nodes agree on the
transactions' sequence and state.

Consider a marketplace scenario where Alice and Bob simultaneously attempt to purchase the same
asset. The network must resolve this conflict to prevent double-spending, ensuring that at most one
transaction succeeds while the other is rightfully rejected.

## Fast Path[​](#fast-path "Direct link to Fast Path")

However, not all transactions require the same level of validation and consensus. For example, if
Alice wants to transfer an object that she owns to Bob, the network can process this transaction
without sequencing it with respect to all other transactions in the network, as only Alice has the
authority to access the object. This is known as the *fast path* execution, where transactions
accessing account-owned objects are processed quickly without the need for extensive consensus. No
concurrent data access -> simpler challenge -> fast path.

Another ownership model that allows for fast path execution is the *immutable state*. Since
immutable objects cannot change, transactions involving them can be processed quickly without the
need to sequence them.

## Consensus Path[​](#consensus-path "Direct link to Consensus Path")

Transactions that do access shared state - on Sui it is represented with shared objects - require
sequencing to ensure that the state is updated and consistent across all nodes. This is known as the
execution through *consensus*, where transactions accessing shared objects are subject to the
agreement process to maintain network consistency.

## Objects owned by Objects[​](#objects-owned-by-objects "Direct link to Objects owned by Objects")

Lastly, it is important to mention that objects owned by other objects are subject to the same rules
as the parent object. If the parent object is *shared*, the child object is also transitively
shared. If the parent object is immutable, the child object is also immutable.

## Summary[​](#summary "Direct link to Summary")

* **Fast Path:** Transactions involving account-owned objects or immutable shared state are
  processed quickly without the need for extensive consensus.
* **Consensus Path:** Transactions involving shared objects require sequencing and consensus to
  ensure network integrity.
* **Objects owned by Objects:** Child objects inherit the ownership model of the parent object.

* [Concurrency Challenge](#concurrency-challenge)
* [Fast Path](#fast-path)
* [Consensus Path](#consensus-path)
* [Objects owned by Objects](#objects-owned-by-objects)
* [Summary](#summary)
Using Objects | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Using Objects

In the [Object Model](/object) chapter, we introduced the shift in the Move language from an
account-based model to an object-based one. This chapter takes a closer look at that model. You’ll
learn how objects work and how to put them to use in your Sui applications.

If you haven’t read the [Object Model](/object) chapter yet, we recommend starting there before
continuing.
Sui Verifier: Internal Constraint | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Sui Verifier: Internal Constraint

The Sui Bytecode Verifier enforces a set of rules on Move bytecode to ensure the safety of critical
storage operations. One of these rules is the *internal constraint*. It requires that the caller of
a function with a type parameter T must be the *defining module* of that type. In other words, T
must be *internal* to the module making the call.

This rule is not (yet) part of the Move language itself, which can make it feel opaque. Still, it’s
an important rule to understand, especially when working with storage-related operations on Sui.

Let’s look at an example from the [Sui Framework](/programmability/sui-framework). The emit function in the
[sui::event](/programmability/events) module requires its type parameter T to be *internal* to the caller:

```move
// An actual example of a function that enforces `internal` on `T`.  
module sui::event;  
  
// Sui Verifier will emit an error at compilation if this function is  
// called from a module that does not define `T`.  
public native fun emit<T: copy + drop>(event: T);
```

Here’s a correct call to emit. The type A is defined inside the module exercise\_internal, so
it’s internal and valid:

```move
// Defines type `A`.  
module book::exercise_internal;  
  
use sui::event;  
  
/// Type defined in this module, so it's internal here.  
public struct A has copy, drop {}  
  
// This works because `A` is defined locally.  
public fun call_internal() {  
    event::emit(A {})  
}
```

But if you try to call emit with a type defined elsewhere, the verifier rejects it. For example,
this function, when added to the same module, fails because it tries to use the TypeName type from
the [Standard Library](/move-basics/standard-library):

```move
// This one fails!  
public fun call_foreign_fail() {  
    use std::type_name;  
  
    event::emit(type_name::get<A>());  
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid event.  
    // Error: `sui::event::emit` must be called with a type  
    // defined in the current module.  
}
```

Internal constraints only apply to certain functions in the [Sui Framework](/programmability/sui-framework). We’ll
return to this concept several times throughout the book.
Ability: Key | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Ability: Key

In the [Basic Syntax](/move-basics) chapter, we already covered two out of four abilities:
[Drop](/move-basics/drop-ability) and [Copy](/move-basics/copy-ability). They affect the behavior of a value in a scope and
are not directly related to storage. Now it is time to cover the key ability, which allows a
struct to be *stored*.

Historically, the key ability was created to mark a type as a *key in storage*. A type with the
key ability could be stored at the top level in global storage and could be *owned* by an account
or address. With the introduction of the [Object Model](/object), the key ability became the
defining ability for *objects*.

> Later in the book, we will refer to any struct with the key ability as an Object.

## Object Definition[​](#object-definition "Direct link to Object Definition")

A struct with the key ability is considered *an object* and can be used in storage functions. The
Sui Verifier requires the first field of the struct to be named id and to have the type UID.
Additionally, it requires all fields to have the store ability — we’ll explore it in detail [on
the next page](/storage/store-ability).

```move
/// `User` object definition.  
public struct User has key {  
    id: UID, // required by Sui Bytecode Verifier  
    name: String, // field types must have `store`  
}  
  
/// Creates a new instance of the `User` type.  
/// Uses the special struct `TxContext` to derive a Unique ID (UID).  
public fun new(name: String, ctx: &mut TxContext): User {  
    User {  
        id: object::new(ctx), // creates a new UID  
        name,  
    }  
}
```

## Relation to copy and drop[​](#relation-to-copy-and-drop "Direct link to relation-to-copy-and-drop")

UID is a type that does not have the [drop](/move-basics/drop-ability) or [copy](/move-basics/copy-ability) abilities.
Since it is required as a field of any type with the key ability, this means that types with key
can never have drop or copy.

This property can be leveraged in [ability constraints](/move-basics/generics#constraints-on-type-parameters): requiring drop or copy
automatically excludes key, and conversely, requiring key excludes types with drop or copy.

## Types with the key Ability[​](#types-with-the-key-ability "Direct link to types-with-the-key-ability")

Due to the UID requirement for types with key, none of the native types in Move can have the
key ability, nor can any of the types in the [Standard Library](/move-basics/standard-library). The key
ability is present only in some [Sui Framework](/programmability/sui-framework) types and in custom types.

## Summary[​](#summary "Direct link to Summary")

* The key ability defines an object
* The first field of an object must be id with type UID
* Fields of a key type must the have [store](/storage/store-ability) ability
* Objects cannot have [drop](/move-basics/drop-ability) or [copy](/move-basics/copy-ability)

## Next Steps[​](#next-steps "Direct link to Next Steps")

The key ability defines objects in Move and forces the fields to have store. In the next section
we cover the store ability to later explain how [storage operations](/storage/storage-functions) work.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Type Abilities](/reference/abilities) in the Move Reference.

* [Object Definition](#object-definition)
* [Relation to `copy` and `drop`](#relation-to-copy-and-drop)
* [Types with the `key` Ability](#types-with-the-key-ability)
* [Summary](#summary)
* [Next Steps](#next-steps)
* [Further Reading](#further-reading)
Ability: Store | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Ability: Store

The [key ability](/storage/key-ability) requires all fields to have store, which defines what the store
ability means: it is the ability to serve as a field of an Object. A struct with
[copy](/move-basics/copy-ability) or [drop](/move-basics/drop-ability) but without store can never be *stored*. A type
with key but without store cannot be wrapped - used as a field—in another object, and is
constrained to always remain at the top level.

## Definition[​](#definition "Direct link to Definition")

The store ability allows a type to be used as a field in a struct with the key ability.

```move
use std::string::String;  
  
/// Extra metadata with `store`; all fields must have `store` as well!  
public struct Metadata has store {  
    bio: String,  
}  
  
/// An object for a single user record.  
public struct User has key {  
    id: UID,  
    name: String,       // String has `store`  
    age: u8,            // All integers have `store`  
    metadata: Metadata, // Another type with the `store` ability  
}
```

## Relation to copy and drop[​](#relation-to-copy-and-drop "Direct link to relation-to-copy-and-drop")

All three non-key abilities can be used in any combination.

## Relation to key[​](#relation-to-key "Direct link to relation-to-key")

An object with the store ability can be *stored* in other objects.

> While not a language or verifier feature, store acts as a *public* modifier on a struct,
> allowing calling *public* [transfer functions](/storage/storage-functions) which do not have an
> [internal constraint](/storage/internal-constraint).

## Types with the store Ability[​](#types-with-the-store-ability "Direct link to types-with-the-store-ability")

All native types (except references) in Move have the store ability. This includes:

* [bool](/move-basics/primitive-types#booleans)
* [unsigned integers](/move-basics/primitive-types#integer-types)
* [vector](/move-basics/vector)
* [address](/move-basics/address)

All of the types defined in the standard library have the store ability as well. This includes:

* [Option](/move-basics/option)
* [String](/move-basics/string) and [ASCII String](/move-basics/string)
* [TypeName](/move-basics/type-reflection)

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Type Abilities](/reference/abilities) in the Move Reference.

* [Definition](#definition)
* [Relation to `copy` and `drop`](#relation-to-copy-and-drop)
* [Relation to `key`](#relation-to-key)
* [Types with the `store` Ability](#types-with-the-store-ability)
* [Further Reading](#further-reading)
Storage Functions | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Storage Functions

The module that defines main storage operations is sui::transfer. It is implicitly imported in all
packages that depend on the [Sui Framework](/programmability/sui-framework), so, like other
implicitly imported modules (e.g. std::option or std::vector), it does not require adding a use
statement.

> For quick reference, [Appendix C: Transfer Functions](/appendix/transfer-functions)
> contains a list of all storage functions and object states.

## Overview[​](#overview "Direct link to Overview")

The transfer module provides functions to perform storage operations for each of the
[ownership types](/object/ownership).

1. [Transfer](#transfer) - send an object to an address, put it into *address owned* state;
2. [Freeze](#freeze) - put an object into *immutable* state, so it becomes a *public constant* and
   can never change.
3. [Share](#share) - put an object into a *shared* state, so it is available to everyone;

The transfer module is a go-to for most of the storage operations, except a special case with
[Dynamic Fields](/programmability/dynamic-fields) which are covered in the next chapter.

## Ownership and References: a Quick Recap[​](#ownership-and-references-a-quick-recap "Direct link to Ownership and References: a Quick Recap")

In the [Ownership and Scope](/move-basics/ownership-and-scope) and
[References](/move-basics/references) chapters, we covered the basics of ownership and
references in Move. It is important that you understand these concepts when using storage functions.
Here is a quick recap of the most important points:

* The *move* semantics in Move means that the value is *moved* from one scope to another. In other
  words, if an instance of a type is passed to a function *by value*, it is *moved* to the function
  scope and can't be accessed in the caller scope anymore.
* To maintain the ownership of the value, you can pass it *by reference*. Either by *immutable
  reference* &T or *mutable reference* &mut T. Then the value is *borrowed* and can be accessed
  in the callee scope, however the owner stays the same.

```move
/// Moved by value  
public fun take<T>(value: T) { /* value is moved here! */ abort }  
  
/// For immutable reference, value stays in parent scope.  
public fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort }  
  
/// For mutable reference, value stays in parent scope but can be mutated.  
public fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort }
```

## Internal Rule in Transfer Functions[​](#internal-rule-in-transfer-functions "Direct link to Internal Rule in Transfer Functions")

Storage operations can only be performed on objects, and come in two forms: *internal* and *public*.
Internal, or sometimes called *restricted*, transfer functions can be performed on [key](/storage/key-ability)-only
types, and - comes with the name - enforce [internal constraint](/storage/internal-constraint). Public
versions can be called on any object that has key and [store](/storage/store-ability). Hence, key-only types'
storage is fully governed by their defining module, and store allows calling public transfer
functions in other modules.

```move
/// T: internal, can be called only in the module which defines the `T`.  
public fun transfer<T: key>(obj: T, recipient: address);  
  
/// No requirement for `T` to be internal to the caller, but requires `store`.  
public fun public_transfer<T: key + store>(obj: T, recipient: address);
```

In the example above, the transfer function can only be called from the module that defines the
T, and has a type constraint T: key. While public\_transfer - clearly indicated in the name -
can be called from any module, but requires T to have key and store.

Knowing this rule is critical for understanding application design in Move. Choice between making
object publicly transferable (key and store) and keeping it internal (key-only) may
drastically affect application logic and further development.

## Transfer[​](#transfer "Direct link to Transfer")

The transfer::transfer function is a function used to transfer an object to an address. Its
signature is as follows, only accepts a type with the [key ability](/storage/key-ability) and an
[address](/move-basics/address) of the recipient. Note that the object is passed into the
function *by value*, therefore it is *moved* to the function scope and then moved to the recipient
address.

```move
module sui::transfer;  
  
// Transfer `obj` to `recipient`.  
public fun transfer<T: key>(obj: T, recipient: address);  
  
// Public version of the `transfer` function.  
public fun public_transfer<T: key + store>(obj: T, recipient: address);
```

### Transfer Example[​](#transfer-example "Direct link to Transfer Example")

In the following example, you can see how it can be used in a module that defines and sends an
object to the transaction sender.

```move
module book::transfer_to_sender;  
  
/// A struct with `key` is an object. The first field is `id: UID`!  
public struct AdminCap has key { id: UID }  
  
/// `init` function is a special function that is called when the module  
/// is published. It is a good place to do a setup for an application.  
fun init(ctx: &mut TxContext) {  
    // Create a new `AdminCap` object, in this scope.  
    let admin_cap = AdminCap { id: object::new(ctx) };  
  
    // Transfer the object to the transaction sender.  
    transfer::transfer(admin_cap, ctx.sender());  
}  
  
/// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient  
/// becomes the owner of the object, and only they can access it.  
public fun transfer_admin_cap(cap: AdminCap, recipient: address) {  
    transfer::transfer(cap, recipient);  
}
```

When the module is published, the init function will get called, and the AdminCap object which
we created in it will be *transferred* to the transaction sender. The ctx.sender() function
returns the sender address for the current transaction.

Once the AdminCap has been transferred to the sender, for example, to 0xa11ce, the sender, and
only the sender, will be able to access the object. This type of ownership is called *address
ownership*.

> Address owned objects are a subject to *true ownership* - only owner address can access them. This
> is a fundamental concept in the Sui storage model.

### Public Transfer[​](#public-transfer "Direct link to Public Transfer")

Let's extend the example with a function that uses AdminCap to authorize a mint of a new object
and its transfer to an address:

```move
/// Some `Gift` object that the admin can `mint_and_transfer` to an address.  
public struct Gift has key, store { id: UID }  
  
/// Creates a new `Gift` object and transfers it to the `recipient`.  
public fun mint_and_transfer(  
    _: &AdminCap, recipient: address, ctx: &mut TxContext  
) {  
    let gift = Gift { id: object::new(ctx) };  
    transfer::public_transfer(gift, recipient);  
}
```

The mint\_and\_transfer function is a *public* function that "could" be called by anyone, but it
requires a reference to an AdminCap as the first argument. Without it, the function will not be
callable. This is a simple and very explicit way to restrict access to privileged functions called
*[Capability](/programmability/capability)*. Because the AdminCap object is *address owned*,
only 0xa11ce will be able to call the mint\_and\_transfer function.

Unlike AdminCap where we restricted transferability as well as usability by adding only key
ability, Gift has a key and store combination, which means, that whoever owns a Gift can
freely call transfer::public\_transfer and send it to anyone else. Without store, in our current
implementation, Gift would've been *"soulbound"* meaning that the happy owner of the Gift would
not be able to do anything with it.

### Quick Recap[​](#quick-recap "Direct link to Quick Recap")

* transfer function is used to send an object to an address;
* The object becomes *address owned* and can only be accessed by the recipient;
* *Address owned* object can be used by reference or by value, including being transferred to
  another address;
* *Public* version of it is public\_transfer and requires store
* Functions can be gated by requiring an object to be passed as an argument, creating a
  *capability*.

## Freeze[​](#freeze "Direct link to Freeze")

The transfer::freeze\_object function is a function that is used to put an object into an
*immutable* state. Once an object is *frozen*, it can never change, and it can be accessed by anyone
by immutable reference.

The function signature is as follows, only accepts a type with the [key ability](/storage/key-ability).
Just like all other storage functions, it takes the object *by value*. The public version of this
function is public\_freeze\_object, and requires T to have store.

```move
module sui::transfer;  
  
// Make object immutable and allow anyone to read it.  
public fun freeze_object<T: key>(obj: T);  
  
// Public version of the `freeze_object` function.  
public fun public_freeze_object<T: key + store>(obj: T);
```

Let's extend the previous example and add a function that allows the admin to create a Config
object and freeze it:

```move
/// Some `Config` object that the admin can `create_and_freeze`.  
public struct Config has key {  
    id: UID,  
    message: String  
}  
  
/// Creates a new `Config` object and freezes it.  
public fun create_and_freeze(  
    _: &AdminCap,  
    message: String,  
    ctx: &mut TxContext  
) {  
    let config = Config {  
        id: object::new(ctx),  
        message  
    };  
  
    // Freeze the object so it becomes immutable.  
    transfer::freeze_object(config);  
}  
  
/// Returns the message from the `Config` object.  
/// Can access the object by immutable reference!  
public fun message(c: &Config): String { c.message }
```

Config is an object that has a message field, and the create\_and\_freeze function creates a new
Config and freezes it. Once the object is frozen, it can be accessed by anyone by immutable
reference. The message function is a public function that returns the message from the Config
object. Config is now publicly available by its ID, and the message can be read by anyone.

> Function definitions are not connected to object's state. It is possible to define a function that
> takes a mutable reference to a type that is always frozen. However, it will not be callable on a
> frozen object.

The message function in the example above can be called on an immutable Config object. However,
two functions shown below are not callable on a frozen object:

```move
// === These can't be called on a frozen object! ===  
  
/// The function can be defined, but it won't be callable on a frozen object.  
/// Only immutable references are allowed.  
public fun message_mut(c: &mut Config): &mut String { &mut c.message }  
  
/// Deletes the `Config` object, takes it by value.  
/// Can't be called on a frozen object!  
public fun delete_config(c: Config) {  
    let Config { id, message: _ } = c;  
    id.delete()  
}
```

To summarize:

* transfer::freeze\_object function is used to put an object into an *immutable* state;
* Once an object is *frozen*, it can never be changed, deleted or transferred, and it can be
  accessed by anyone by immutable reference;
* *Public* version of the freeze\_object function is public\_freeze\_object and requires the T to
  have store.

## Owned -> Frozen[​](#owned---frozen "Direct link to Owned -> Frozen")

Since the transfer::freeze\_object signature accepts any type with the key ability, it can take
an object that was created in the same scope, but it can also take an object that was owned by an
account. This means that the freeze\_object function can be used to *freeze* an object that was
*transferred* to the sender. For security concerns, we would not want to freeze the AdminCap
object - it would be a security risk, since anyone would be able to access it. However, we can
freeze the Gift object that was minted and transferred to the recipient:

> Single Owner -> Immutable conversion is possible!

```move
/// Freezes the `Gift` object so it becomes immutable.  
/// Gift has `key` and `store`, so `public_freeze_object` can be used!  
public fun freeze_gift(gift: Gift) {  
    transfer::public_freeze_object(gift);  
}
```

## Share[​](#share "Direct link to Share")

The transfer::share\_object function is a function used to put an object into a *shared* state.
Once an object is *shared*, it can be accessed by anyone by a mutable reference (hence, immutable
too). The function signature is as follows, only accepts a type with the
[key ability](/storage/key-ability):

```move
module sui::transfer;  
  
/// Put an object to a Shared state - can be accessed mutably and immutably.  
public fun share_object<T: key>(obj: T);  
  
/// Public version of `share_object` function.  
public fun public_share_object<T: key + store>(obj: T);
```

Like other transfer functions, share\_object has its *public* version which requires T to have
store.

Once an object is *shared*, it is publicly available as a mutable reference.

## Special Case: Shared Object Deletion[​](#special-case-shared-object-deletion "Direct link to Special Case: Shared Object Deletion")

While the shared object can't normally be taken by value, there is one special case where it can -
if the function that takes it deletes the object. This is a special case in the Sui storage model,
and it is used to allow the deletion of shared objects. To show how it works, we will create a
function that creates and shares a Config object and then another one that deletes it:

```move
/// Creates a new `Config` object and shares it.  
public fun create_and_share(message: String, ctx: &mut TxContext) {  
    let config = Config {  
        id: object::new(ctx),  
        message  
    };  
  
    // Share the object so it becomes shared.  
    transfer::share_object(config);  
}
```

The create\_and\_share function creates a new Config object and shares it. The object is now
publicly available as a mutable reference. Let's create a function that deletes the shared object:

```move
/// Deletes the `Config` object, takes it by value.  
/// Can be called on a shared object!  
public fun delete_config(c: Config) {  
    let Config { id, message: _ } = c;  
    id.delete()  
}
```

The delete\_config function takes the Config object by value and deletes it, and the Sui Verifier
would allow this call. However, if the function returned the Config object back or attempted to
freeze or transfer it, the Sui Verifier would reject the transaction.

```move
// Won't work!  
public fun transfer_shared(c: Config, to: address) {  
    transfer::transfer(c, to);  
}
```

To summarize:

* share\_object function is used to put an object into a *shared* state;
* Once an object is *shared*, it can be accessed by anyone by a mutable reference;
* Shared objects can be deleted, but they can't be transferred or frozen;
* *Public* version of the share\_object function is public\_share\_object and requires the T to
  have store.

## Next Steps[​](#next-steps "Direct link to Next Steps")

Now that you know main features of the transfer module, you can start building more complex
applications on Sui that involve storage operations. In the next chapter, we will cover the
[Store Ability](/storage/store-ability) which allows storing data inside objects and relaxes transfer
restrictions which we barely touched on here. And after that we will cover the
[UID and ID](/storage/uid-and-id) types which are the most important types in the Sui storage model.

* [Overview](#overview)
* [Ownership and References: a Quick Recap](#ownership-and-references-a-quick-recap)
* [Internal Rule in Transfer Functions](#internal-rule-in-transfer-functions)
* [Transfer](#transfer)
  + [Transfer Example](#transfer-example)
  + [Public Transfer](#public-transfer)
  + [Quick Recap](#quick-recap)
* [Freeze](#freeze)
* [Owned -> Frozen](#owned---frozen)
* [Share](#share)
* [Special Case: Shared Object Deletion](#special-case-shared-object-deletion)
* [Next Steps](#next-steps)
UID and ID | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# UID and ID

The use of the UID type is required by the Sui Verifier on all types that have the
[key](/storage/key-ability) ability. Here we go deeper into UID and its usage.

## Definition[​](#definition "Direct link to Definition")

The UID type is defined in the sui::object module and is a wrapper around an ID which, in
turn, wraps the address type. The UIDs on Sui are guaranteed to be unique, and can't be reused
after the object was deleted.

```move
module sui::object;  
  
/// UID is a unique identifier of an object  
public struct UID has store {  
    id: ID  
}  
  
/// ID is a wrapper around an address  
public struct ID has store, drop {  
    bytes: address  
}
```

## Fresh UID Generation[​](#fresh-uid-generation "Direct link to Fresh UID Generation")

* UID is *derived* from the tx\_hash and an index which is incremented for each new UID.
* The derive\_id function is implemented in the sui::tx\_context module, and that is why
  [TxContext](/programmability/transaction-context) is required for UID generation.
* Sui Verifier will not allow using a UID that wasn't created in the same function. That prevents
  UIDs from being pre-generated or reused after the object was unpacked.

New UID is created with the object::new function. It takes a mutable reference to TxContext, and
returns a new UID.

```move
public fun uid(ctx: &mut TxContext) {  
  let id = object::new(ctx); // Create a fresh UID from TxContext.  
  id.delete(); // Delete the UID.  
}
```

UID acts as a representation of an object, and allows defining behaviors and features of an
object. One of the key features - [Dynamic Fields](/programmability/dynamic-fields) - is
possible because of the UID type being explicit. Additionally, it allows receiving objects sent to
other objects. This feature is called [Transfer to Object (TTO)](/storage/transfer-to-object), and we
will explain later in this chapter.

## UID Derivation[​](#uid-derivation "Direct link to UID Derivation")

Sui allows deriving UID's from other UIDs using *derivation keys*. This functionality is implemented
in the [sui::derived\_object](https://docs.sui.io/references/framework/sui_sui/derived_object) module and allows generating predictable and
deterministic UIDs for easier off-chain discovery. UID for each pair of parent + key can be
generated only once!

```move
use sui::derived_object;  
  
/// Some central application object.  
public struct Base has key { id: UID }  
  
/// Derived Object.  
public struct Derived has key { id: UID }  
  
/// Create and share a new Derived object using `address` as a `key`.  
public fun derive(base: &mut Base, key: address) {  
    let id = derived_object::claim(&mut base.id, key);  
    transfer::share_object(Derived { id })  
}
```

Derived addresses reduce the load on off-chain indexers, since it is enough to store the ID of the
parent object and get derived IDs using a derivation function. ID derivation function is part of the
most SDKs, and also present in Move:

```move
module sui::derived_object;  
  
/// Checks if a UID was derived with `key` at `parent`.  
public fun exists<K: copy + drop + store>(parent: &UID, key: K): bool;  
  
/// Derive inner `address` of a UID, regardless of whether it was created.  
public fun derive_address<K: copy + drop + store>(parent: ID, key: K): address;
```

The same derivation functionality is used to generate UIDs for
[dynamic fields](/programmability/dynamic-fields).

## UID Lifecycle[​](#uid-lifecycle "Direct link to UID Lifecycle")

The UID type is created with the object::new function, and deleted with the object::delete
function. The object::delete consumes the UID *by value*, hence, it is only possible to delete
object's UID after the object [was unpacked](/move-basics/struct#unpacking-a-struct).

```move
public struct Character has key { id: UID }  
  
public fun character(ctx: &mut TxContext) {  
    // Instantiate `Character` object.  
    let char = Character { id: object::new(ctx) };  
  
    // Unpack object to get its UID.  
    let Character { id } = char;  
  
    // Delete the UID.  
    id.delete();  
}
```

## Keeping the UID[​](#keeping-the-uid "Direct link to Keeping the UID")

The UID does not need to be deleted immediately after the object struct is unpacked. Sometimes it
may carry [Dynamic Fields](/programmability/dynamic-fields) or objects transferred to it via
[Transfer To Object](/storage/transfer-to-object). In such cases, the UID may be kept and stored in a
separate object.

## Proof of Deletion[​](#proof-of-deletion "Direct link to Proof of Deletion")

The ability to return the UID of an object may be utilized in pattern called *proof of deletion*. It
is a rarely used technique, but it may be useful in some cases, for example, the creator or an
application may incentivize the deletion of an object by exchanging the deleted IDs for some reward.

In framework development this method could be used to ignore / bypass certain restrictions on
"taking" the object. If there's a container that enforces certain logic on transfers, like Kiosk
does, there could be a special scenario of skipping the checks by providing a proof of deletion.

This is one of the open topics for exploration and research, and it may be used in various ways.

## ID[​](#id "Direct link to ID")

When talking about UID we should also mention the ID type. It is a wrapper around the address
type, and is used to represent an address-pointer. Usually, ID is used to point at an object,
however, there is no restriction, and no guarantee that the ID points to an existing object.

> ID can be received as a transaction argument in a
> [Transaction Block](/concepts/what-is-a-transaction). Alternatively, ID can be created from an
> address value using to\_id() function.

```move
public fun conversion_methods(ctx: &mut TxContext) {  
    let uid: UID = object::new(ctx);  
    let id: ID = uid.to_inner();  
  
    let addr_from_uid: address = uid.to_address();  
    let addr_from_id: address = id.to_address();  
  
    uid.delete();  
}
```

This example demonstrates different conversion methods: UID.to\_inner creates a copy of underlying
ID, and UID.to\_address returns inner address. Another often useful method ID.to\_address copies
inner value from the ID type.

## Fresh Object Address[​](#fresh-object-address "Direct link to Fresh Object Address")

[TxContext](/programmability/transaction-context) provides the fresh\_object\_address
function which can be utilized to create unique addresses and ID - it may be useful in some
application that assign unique identifiers to user actions - for example, an order\_id in a
marketplace.

## Links[​](#links "Direct link to Links")

* [sui::object](https://docs.sui.io/references/framework/sui_sui/object) module documentation
* [sui::derived\_object](https://docs.sui.io/references/framework/sui_sui/derived_object) module documentation
* [Derived Objects](https://docs.sui.io/concepts/sui-move-concepts/derived-objects) in Sui
  Documentation

* [Definition](#definition)
* [Fresh UID Generation](#fresh-uid-generation)
* [UID Derivation](#uid-derivation)
* [UID Lifecycle](#uid-lifecycle)
* [Keeping the UID](#keeping-the-uid)
* [Proof of Deletion](#proof-of-deletion)
* [ID](#id)
* [Fresh Object Address](#fresh-object-address)
* [Links](#links)
Receiving as Object | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Receiving as Object

[Address owned](/storage/storage-functions#transfer) Object state supports two types of owners: an
account and another Object. If an object was transferred to another object, Sui provides a way to
*receive* this object through its owner's [UID](/storage/uid-and-id).

> This feature is also known as *"Transfer to Object"* or TTO.

## Definition[​](#definition "Direct link to Definition")

Receiving functionality is implemented in the [sui::transfer](https://docs.sui.io/references/framework/sui_sui/transfer) module. It consists of a
special type Receiving which is instantiated through a special transaction argument, and the
receive function which takes a [UID](/storage/uid-and-id) of the parent.

> Currently, T in the transfer::receive is a subject to [Internal Constraint](/storage/internal-constraint). Public
> version of receive is called public\_receive, and like other [storage functions][storage-funs]
> it requires T to have [store](/storage/store-ability).

```move
module sui::transfer;  
  
// An ephemeral wrapper around `Receiving` argument. Provided as a special input  
// in a Transaction Block.  
// Note: this type should be explicitly imported to be used!  
public struct Receiving<phantom T: key> has drop {  
    id: ID,  
    version: u64,  
}  
  
/// Receive `T` from parent `UID` through special type `Receiving`.  
public fun receive<T: key>(parent: &mut UID, to_receive: Receiving<T>): T;
```

Due to the UID type requirement, receiving cannot be performed on an arbitrary object that does
not provide access or special receiving implementation. This feature should be used be used with
caution and in a controlled setting.

## Example[​](#example "Direct link to Example")

As an illustration for *transfer* and *receive* consider an example: PostOffice allows registering
Post Boxes and sending to accounts' post boxes.

```move
module book::receiving;  
  
use sui::derived_object;  
use sui::transfer::Receiving; // not imported by default!  
  
/// Base derivation object to create derived `PostBox`-es.  
public struct PostOffice has key { id: UID }  
  
/// Object with derived UID which receives objects sent to an address.  
public struct PostBox has key { id: UID, owner: address }  
  
/// Transfer functionality. Anyone can come to the PostOffice and send to a specific  
/// recipient's PostBox. Items can be received from the `PostBox` by the recipient.  
public fun send<T: key + store>(office: &PostOffice, parcel: T, recipient: address) {  
    let postbox = derived_object::derive_address(office.id.to_inner(), recipient);  
    transfer::public_transfer(parcel, postbox)  
}  
  
/// Receive the parcel. Requires the sender to be the owner of the `PostBox`!  
public fun receive<T: key + store>(  
    box: &mut PostBox,  
    to_receive: Receiving<T>,  
    ctx: &TxContext  
): T {  
    assert!(box.owner == ctx.sender());  
  
    // Receive `to_receive` from `PostBox`.  
    let parcel = transfer::public_receive(&mut box.id, to_receive);  
    parcel  
}  
  
/// If user hasn't claimed their `PostBox` yet, create it.  
/// Note: this is not a requirement for transferring assets!  
/// Parcels can be sent even to unregistered post boxes, see `send` implementation.  
public fun register_address(office: &mut PostOffice, ctx: &mut TxContext) {  
    transfer::share_object(PostBox {  
        id: derived_object::claim(&mut office.id, ctx.sender()),  
        owner: ctx.sender()  
    })  
}  
  
// Create a PostOffice on module publish.  
fun init(ctx: &mut TxContext) {  
    transfer::share_object(PostOffice { id: object::new(ctx) });  
}
```

## Use Cases[​](#use-cases "Direct link to Use Cases")

Transferring to objects is a powerful feature which allows objects to act as owners of other
objects. One of the reasons to use it is the extra authorization performed upon receiving, eg the
PostOffice in the example above could charge a receiving fee.

* Allows parallel execution of transfers to multiple objects without referencing them in the
  transaction;
* Parent objects can also be transferred, acting as a container;
* PostBox-like applications, where user gets assets only after activating their account;
* Account abstraction-like applications where an object is mocking an account.

## Links[​](#links "Direct link to Links")

* [Transfer to Object](https://docs.sui.io/concepts/transfers/transfer-to-object) in Sui
  Documentation
* [sui::transfer](https://docs.sui.io/references/framework/sui_sui/transfer) module documentation

* [Definition](#definition)
* [Example](#example)
* [Use Cases](#use-cases)
* [Links](#links)
Advanced Programmability | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Advanced Programmability

In previous chapters we've covered [the basics of Move](/move-basics) and
[Sui Storage Model](/storage). Now it's time to dive deeper into the advanced topics of Sui
programmability.

This chapter introduces more complex concepts, practices and features of Move and Sui that are
essential for building more sophisticated applications. It is intended for developers who are
already familiar with the basics of Move and Sui, and are looking to expand their knowledge and
skills.
Sui Framework | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Sui Framework

Sui Framework is a default dependency set in the [Package Manifest](/concepts/manifest). It
depends on the [Standard Library](/move-basics/standard-library) and provides Sui-specific
features, including the interaction with the storage, and Sui-specific native types and modules.

*For convenience, we grouped the modules in the Sui Framework into multiple categories. But they're
still part of the same framework.*

## Core[​](#core "Direct link to Core")

| Module | Description | Chapter |
| --- | --- | --- |
| [sui::address](https://docs.sui.io/references/framework/sui/address) | Adds conversion methods to the [address type](/move-basics/address) | [Address](/move-basics/address) |
| [sui::transfer](https://docs.sui.io/references/framework/sui/transfer) | Implements the storage operations for Objects | [Storage Functions](/storage/storage-functions) |
| [sui::tx\_context](https://docs.sui.io/references/framework/sui/tx_context) | Contains the TxContext struct and methods to read it | [Transaction Context](/programmability/transaction-context) |
| [sui::object](https://docs.sui.io/references/framework/sui/object) | Defines the UID and ID type, required for creating objects | [UID and ID](/storage/uid-and-id) |
| [sui::derived\_object](https://docs.sui.io/references/framework/sui/derived_object) | Allows UID generation through key derivation | [UID Derivation](/storage/uid-and-id#uid-derivation) |
| [sui::clock](https://docs.sui.io/references/framework/sui/clock) | Defines the Clock type and its methods | [Epoch and Time](/programmability/epoch-and-time) |
| [sui::dynamic\_field](https://docs.sui.io/references/framework/sui/dynamic_field) | Implements methods to add, use and remove dynamic fields | [Dynamic Fields](/programmability/dynamic-fields) |
| [sui::dynamic\_object\_field](https://docs.sui.io/references/framework/sui/dynamic_object_field) | Implements methods to add, use and remove dynamic object fields | [Dynamic Object Fields](/programmability/dynamic-object-fields) |
| [sui::event](https://docs.sui.io/references/framework/sui/event) | Allows emitting events for off-chain listeners | [Events](/programmability/events) |
| [sui::package](https://docs.sui.io/references/framework/sui/package) | Defines the Publisher type and package upgrade methods | [Publisher](/programmability/publisher), Package Upgrades |
| [sui::display](https://docs.sui.io/references/framework/sui/display) | Implements the Display object and ways to create and update it | [Display](/programmability/display) |

## Collections[​](#collections "Direct link to Collections")

| Module | Description | Chapter |
| --- | --- | --- |
| [sui::vec\_set](https://docs.sui.io/references/framework/sui/vec_set) | Implements a set type | [Collections](/programmability/collections) |
| [sui::vec\_map](https://docs.sui.io/references/framework/sui/vec_map) | Implements a map with vector keys | [Collections](/programmability/collections) |
| [sui::table](https://docs.sui.io/references/framework/sui/table) | Implements the Table type and methods to interact with it | [Dynamic Collections](/programmability/dynamic-collections) |
| [sui::linked\_table](https://docs.sui.io/references/framework/sui/linked_table) | Implements the LinkedTable type and methods to interact with it | [Dynamic Collections](/programmability/dynamic-collections) |
| [sui::bag](https://docs.sui.io/references/framework/sui/bag) | Implements the Bag type and methods to interact with it | [Dynamic Collections](/programmability/dynamic-collections) |
| [sui::object\_table](https://docs.sui.io/references/framework/sui/object_table) | Implements the ObjectTable type and methods to interact with it | [Dynamic Collections](/programmability/dynamic-collections) |
| [sui::object\_bag](https://docs.sui.io/references/framework/sui/object_bag) | Implements the ObjectBag type and methods to interact with it | [Dynamic Collections](/programmability/dynamic-collections) |

## Utilities[​](#utilities "Direct link to Utilities")

| Module | Description | Chapter |
| --- | --- | --- |
| [sui::bcs](https://docs.sui.io/references/framework/sui/bcs) | Implements the BCS encoding and decoding functions | [Binary Canonical Serialization](/programmability/bcs) |
| [sui::borrow](https://docs.sui.io/references/framework/sui/borrow) | Implements the borrowing mechanic for borrowing by *value* | [Hot Potato](/programmability/hot-potato-pattern) |
| [sui::hex](https://docs.sui.io/references/framework/sui/hex) | Implements the hex encoding and decoding functions | - |
| [sui::types](https://docs.sui.io/references/framework/sui/types) | Provides a way to check if the type is a One-Time-Witness | [One Time Witness](/programmability/one-time-witness) |

## Exported Addresses[​](#exported-addresses "Direct link to Exported Addresses")

Sui Framework exports two named addresses: sui = 0x2 and std = 0x1 from the std dependency.

```move
[addresses]  
sui = "0x2"  
  
# Exported from the MoveStdlib dependency  
std = "0x1"
```

## Implicit Imports[​](#implicit-imports "Direct link to Implicit Imports")

Just like with [Standard Library](/move-basics/standard-library#implicit-imports), some of the
modules and types are imported implicitly in the Sui Framework. This is the list of modules and
types that are available without explicit use import:

* sui::object
* sui::object::ID
* sui::object::UID
* sui::tx\_context
* sui::tx\_context::TxContext
* sui::transfer

## Source Code[​](#source-code "Direct link to Source Code")

The source code of the Sui Framework is available in the
[Sui repository](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources).

* [Core](#core)
* [Collections](#collections)
* [Utilities](#utilities)
* [Exported Addresses](#exported-addresses)
* [Implicit Imports](#implicit-imports)
* [Source Code](#source-code)
Transaction Context | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Transaction Context

Every transaction has the execution context. The context is a set of predefined variables that are
available to the program during execution. For example, every transaction has a sender address, and
the transaction context contains a variable that holds the sender address.

The transaction context is available to the program through the TxContext struct. The struct is
defined in the [sui::tx\_context](https://docs.sui.io/references/framework/sui/tx_context) module and contains the following fields:

```move
module sui::tx_context;  
  
/// Information about the transaction currently being executed.  
/// This cannot be constructed by a transaction--it is a privileged object created by  
/// the VM and passed in to the entrypoint of the transaction as `&mut TxContext`.  
public struct TxContext has drop {  
    /// The address of the user that signed the current transaction  
    sender: address,  
    /// Hash of the current transaction  
    tx_hash: vector<u8>,  
    /// The current epoch number  
    epoch: u64,  
    /// Timestamp that the epoch started at  
    epoch_timestamp_ms: u64,  
    /// Counter recording the number of fresh id's created while executing  
    /// this transaction. Always 0 at the start of a transaction  
    ids_created: u64  
}
```

Transaction context cannot be constructed manually or directly modified. It is created by the system
and passed to the function as a reference in a transaction. Any function called in a
[Transaction](/concepts/what-is-a-transaction) has access to the context and can pass it into
the nested calls.

> TxContext has to be the last argument in the function signature.

## Reading the Transaction Context[​](#reading-the-transaction-context "Direct link to Reading the Transaction Context")

With only exception of the ids\_created, all of the fields in the TxContext have getters. The
getters are defined in the sui::tx\_context module and are available to the program. The getters
don't require &mut because they don't modify the context.

```move
public fun some_action(ctx: &TxContext) {  
    let me = ctx.sender();  
    let epoch = ctx.epoch();  
    let digest = ctx.digest();  
    // ...  
}
```

## Mutability[​](#mutability "Direct link to Mutability")

The TxContext is required to create new objects (or just UIDs) in the system. New UIDs are
derived from the transaction digest, and for the digest to be unique, there needs to be a changing
parameter. Sui uses the ids\_created field for that. Every time a new UID is created, the
ids\_created field is incremented by one. This way, the digest is always unique.

Internally, it is represented as the derive\_id function:

```move
native fun derive_id(tx_hash: vector<u8>, ids_created: u64): address;
```

## Generating Unique Addresses[​](#generating-unique-addresses "Direct link to Generating Unique Addresses")

The underlying derive\_id function can also be utilized in your program to generate unique
addresses. The function itself is not exposed, but a wrapper function fresh\_object\_address is
available in the sui::tx\_context module. It may be useful if you need to generate a unique
identifier in your program.

```move
module sui::tx_context;  
  
/// Create an `address` that has not been used. As it is an object address, it will never  
/// occur as the address for a user.  
/// In other words, the generated address is a globally unique object ID.  
public fun fresh_object_address(ctx: &mut TxContext): address {  
    let ids_created = ctx.ids_created;  
    let id = derive_id(*&ctx.tx_hash, ids_created);  
    ctx.ids_created = ids_created + 1;  
    id  
}
```

* [Reading the Transaction Context](#reading-the-transaction-context)
* [Mutability](#mutability)
* [Generating Unique Addresses](#generating-unique-addresses)
Module Initializer | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Module Initializer

A common use case in many applications is to run certain code just once when the package is
published. Imagine a simple store module that needs to create the main Store object upon its
publication. In Sui, this is achieved by defining an init function within the module. This
function will automatically be called when the module is published.

> All of the modules' init functions are called during the publishing process. Currently, this
> behavior is limited to the publish command and does not extend to package upgrades.

```move
module book::shop;  
  
/// The Capability which grants the Shop owner the right to manage  
/// the shop.  
public struct ShopOwnerCap has key, store { id: UID }  
  
/// The singular Shop itself, created in the `init` function.  
public struct Shop has key {  
    id: UID,  
    /* ... */  
}  
  
// Called only once, upon module publication. It must be  
// private to prevent external invocation.  
fun init(ctx: &mut TxContext) {  
    // Transfers the ShopOwnerCap to the sender (publisher).  
    transfer::transfer(ShopOwnerCap {  
        id: object::new(ctx)  
    }, ctx.sender());  
  
    // Shares the Shop object.  
    transfer::share_object(Shop {  
        id: object::new(ctx)  
    });  
}
```

In the same package, another module can have its own init function, encapsulating distinct logic.

```move
// In the same package as the `shop` module  
module book::bank;  
  
public struct Bank has key {  
    id: UID,  
    /* ... */  
}  
  
fun init(ctx: &mut TxContext) {  
    transfer::share_object(Bank {  
        id: object::new(ctx)  
    });  
}
```

## init Features[​](#init-features "Direct link to init-features")

The function is called on publish, if it is present in the module and follows the rules:

* The function has to be named init, be private and have no return values.
* Takes one or two arguments: [One Time Witness](/programmability/one-time-witness) (optional) and
  [TxContext](/programmability/transaction-context). With TxContext always being the last argument.

```move
fun init(ctx: &mut TxContext) { /* ... */}  
fun init(otw: OTW, ctx: &mut TxContext) { /* ... */ }
```

TxContext can also be passed as immutable reference: &TxContext. However, practically speaking, it
should always be &mut TxContext since the init function can't access the on-chain state and to
create new objects it requires the mutable reference to the context.

```move
fun init(ctx: &TxContext) { /* ... */}  
fun init(otw: OTW, ctx: &TxContext) { /* ... */ }
```

## Trust and Security[​](#trust-and-security "Direct link to Trust and Security")

While init function can be used to create sensitive objects once, it is important to know that the
same object (e.g. StoreOwnerCap from the first example) can still be created in another function.
Especially given that new functions can be added to the module during an upgrade. So the init
function is a good place to set up the initial state of the module, but it is not a security measure
on its own.

There are ways to guarantee that the object was created only once, such as the
[One Time Witness](/programmability/one-time-witness). And there are ways to limit or disable the upgrade of the
module, which we will cover in the Package Upgrades chapter.

## Next Steps[​](#next-steps "Direct link to Next Steps")

As follows from the definition, the init function is guaranteed to be called only once when the
module is published. So it is a good place to put the code that initializes module's objects and
sets up the environment and configuration.

For example, if there's a [Capability](/programmability/capability) which is required for certain actions, it
should be created in the init function. In the next chapter we will talk about the Capability
pattern in more detail.

* [`init` Features](#init-features)
* [Trust and Security](#trust-and-security)
* [Next Steps](#next-steps)
Pattern: Capability | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Pattern: Capability

In programming, a *capability* is a token that gives the owner the right to perform a specific
action. It is a pattern that is used to control access to resources and operations. A simple example
of a capability is a key to a door. If you have the key, you can open the door. If you don't have
the key, you can't open the door. A more practical example is an Admin Capability which allows the
owner to perform administrative operations, which regular users cannot.

## Capability is an Object[​](#capability-is-an-object "Direct link to Capability is an Object")

In the [Sui Object Model](/object/), capabilities are represented as objects. An owner of an
object can pass this object to a function to prove that they have the right to perform a specific
action. Due to strict typing, the function taking a capability as an argument can only be called
with the correct capability.

> There's a convention to name capabilities with the Cap suffix, for example, AdminCap or
> KioskOwnerCap.

```move
module book::capability;  
  
use std::string::String;  
use sui::event;  
  
/// The capability granting the application admin the right to create new  
/// accounts in the system.  
public struct AdminCap has key, store { id: UID }  
  
/// The user account in the system.  
public struct Account has key, store {  
    id: UID,  
    name: String  
}  
  
/// A simple `Ping` event with no data.  
public struct Ping has copy, drop { by: ID }  
  
/// Creates a new account in the system. Requires the `AdminCap` capability  
/// to be passed as the first argument.  
public fun new(_: &AdminCap, name: String, ctx: &mut TxContext): Account {  
    Account {  
        id: object::new(ctx),  
        name,  
    }  
}  
  
/// Account, and any other objects, can also be used as a Capability in the  
/// application. For example, to emit an event.  
public fun send_ping(acc: &Account) {  
    event::emit(Ping {  
        by: acc.id.to_inner()  
    })  
}  
  
/// Updates the account name. Can only be called by the `Account` owner.  
public fun update(account: &mut Account, name: String) {  
    account.name = name;  
}
```

## Using init for Admin Capability[​](#using-init-for-admin-capability "Direct link to using-init-for-admin-capability")

A very common practice is to create a single AdminCap object on package publish. This way, the
application can have a setup phase where the admin account prepares the state of the application.

```move
module book::admin_cap;  
  
/// The capability granting the admin privileges in the system.  
/// Created only once in the `init` function.  
public struct AdminCap has key { id: UID }  
  
/// Create the AdminCap object on package publish and transfer it to the  
/// package owner.  
fun init(ctx: &mut TxContext) {  
    transfer::transfer(  
        AdminCap { id: object::new(ctx) },  
        ctx.sender()  
    )  
}
```

## Address Check vs Capability[​](#address-check-vs-capability "Direct link to Address Check vs Capability")

Utilizing objects as capabilities is a relatively new concept in blockchain programming. And in
other smart-contract languages, authorization is often performed by checking the address of the
sender. This pattern is still viable on Sui, however, overall recommendation is to use capabilities
for better security, discoverability, and code organization.

Let's look at how the new function that creates a user would look like if it was using the address
check:

```move
/// Error code for unauthorized access.  
const ENotAuthorized: u64 = 0;  
  
/// The application admin address.  
const APPLICATION_ADMIN: address = @0xa11ce;  
  
/// Creates a new user in the system. Requires the sender to be the application  
/// admin.  
public fun new(ctx: &mut TxContext): User {  
    assert!(ctx.sender() == APPLICATION_ADMIN, ENotAuthorized);  
    User { id: object::new(ctx) }  
}
```

And now, let's see how the same function would look like with the capability:

```move
/// Grants the owner the right to create new users in the system.  
public struct AdminCap {}  
  
/// Creates a new user in the system. Requires the `AdminCap` capability to be  
/// passed as the first argument.  
public fun new(_: &AdminCap, ctx: &mut TxContext): User {  
    User { id: object::new(ctx) }  
}
```

Using capabilities has several advantages over the address check:

* Migration of admin rights is easier with capabilities due to them being objects. In case of
  address, if the admin address changes, all the functions that check the address need to be
  updated - hence, require a package upgrade.
* Function signatures are more descriptive with capabilities. It is clear that the new function
  requires the AdminCap to be passed as an argument. And this function can't be called without it.
* Object Capabilities don't require extra checks in the function body, and hence, decrease the
  chance of a developer mistake.
* An owned Capability also serves in discovery. The owner of the AdminCap can see the object in
  their account (via a Wallet or Explorer), and know that they have the admin rights. This is less
  transparent with the address check.

However, the address approach has its own advantages. For example, if an address is multisig, and
transaction building gets more complex, it might be easier to check the address. Also, if there's a
central object of the application that is used in every function, it can store the admin address,
and this would simplify migration. The central object approach is also valuable for revocable
capabilities, where the admin can revoke the capability from the user.

* [Capability is an Object](#capability-is-an-object)
* [Using `init` for Admin Capability](#using-init-for-admin-capability)
* [Address Check vs Capability](#address-check-vs-capability)
Epoch and Time | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Epoch and Time

Sui has two ways of accessing the current time: Epoch and Time. The former represents
operational periods in the system and changed roughly every 24 hours. The latter represents the
current time in milliseconds since the Unix Epoch. Both can be accessed freely in the program.

## Epoch[​](#epoch "Direct link to Epoch")

Epochs are used to separate the system into operational periods. During an epoch the validator set
is fixed, however, at the epoch boundary, the validator set can be changed. Epochs play a crucial
role in the consensus algorithm and are used to determine the current validator set. They are also
used as measurement in the staking mechanism.

Epoch can be read from the [transaction context](/programmability/transaction-context):

```move
public fun current_epoch(ctx: &TxContext) {  
    let epoch = ctx.epoch();  
    // ...  
}
```

It is also possible to get the unix timestamp of the epoch start:

```move
public fun current_epoch_start(ctx: &TxContext) {  
    let epoch_start = ctx.epoch_timestamp_ms();  
    // ...  
}
```

Normally, epochs are used in staking and system operations, however, in custom scenarios they can be
used to emulate 24h periods. They are critical if an application relies on the staking logic or
needs to know the current validator set.

## Time[​](#time "Direct link to Time")

For a more precise time measurement, Sui provides the Clock object. It is a system object that is
updated during checkpoints by the system, which stores the current time in milliseconds since the
Unix Epoch. The Clock object is defined in the sui::clock module and has a reserved address
0x6.

Clock is a shared object, but a transaction attempting to access it mutably will fail. This
limitation allows parallel access to the Clock object, which is important for maintaining
performance.

```move
module sui::clock;  
  
/// Singleton shared object that exposes time to Move calls.  This  
/// object is found at address 0x6, and can only be read (accessed  
/// via an immutable reference) by entry functions.  
///  
/// Entry Functions that attempt to accept `Clock` by mutable  
/// reference or value will fail to verify, and honest validators  
/// will not sign or execute transactions that use `Clock` as an  
/// input parameter, unless it is passed by immutable reference.  
public struct Clock has key {  
    id: UID,  
    /// The clock's timestamp, which is set automatically by a  
    /// system transaction every time consensus commits a  
    /// schedule, or by `sui::clock::increment_for_testing` during  
    /// testing.  
    timestamp_ms: u64,  
}
```

There is only one public function available in the Clock module - timestamp\_ms. It returns the
current time in milliseconds since the Unix Epoch.

```move
use sui::clock::Clock;  
  
/// Clock needs to be passed as an immutable reference.  
public fun current_time(clock: &Clock) {  
    let time = clock.timestamp_ms();  
    // ...  
}
```

## Testing[​](#testing "Direct link to Testing")

The Clock module provides a number of methods for use in testing.

```move
#[test_only]  
use sui::clock;  
#[test_only]  
use std::unit_test::assert_eq;  
  
#[test]  
fun use_clock_in_test() {  
    // Get `ctx` and create `Clock` for testing  
    let ctx = &mut tx_context::dummy();  
    let mut clock = clock::create_for_testing(ctx);  
    assert_eq!(clock.timestamp_ms(), 0);  
  
    // Add a value to the timestamp stored in `Clock`  
    clock.increment_for_testing(2_000_000_000);  
    assert_eq!(clock.timestamp_ms(), 2_000_000_000);  
  
    // Set the timestamp, but the time set must be no less than the value stored in `Clock`  
    clock.set_for_testing(3_000_000_000);  
    assert_eq!(clock.timestamp_ms(), 3_000_000_000);  
  
    // The following setting will fail because the time set must be at least the timestamp stored in `Clock`  
    // clock.set_for_testing(1_000_000_000);  
    // assert_eq!(clock.timestamp_ms(), 1_000_000_000);  
  
    // If need a shared `Clock` for testing, you can set it through this function  
    // clock.share_for_testing();  
  
    // `Clock` does not have a `drop` capability, so it needs to be destroyed manually at the end of the test  
    clock.destroy_for_testing();  
}
```

* [Epoch](#epoch)
* [Time](#time)
* [Testing](#testing)
Collections | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Collections

Collection types are a fundamental part of any programming language. They are used to store a
collection of data, such as a list of items. The vector type has already been covered in the
[vector section](/move-basics/vector), and in this chapter we will cover the vector-based
collection types offered by the [Sui Framework](/programmability/sui-framework).

## Vector[​](#vector "Direct link to Vector")

While we have previously covered the vector type in the [vector section](/move-basics/vector),
it is worth going over it again in a new context. This time we will cover the usage of the vector
type in objects and how it can be used in an application.

```move
module book::collections_vector;  
  
use std::string::String;  
  
/// The Book that can be sold by a `BookStore`  
public struct Book has key, store {  
    id: UID,  
    name: String  
}  
  
/// The BookStore that sells `Book`s  
public struct BookStore has key, store {  
    id: UID,  
    books: vector<Book>  
}
```

## VecSet[​](#vecset "Direct link to VecSet")

VecSet is a collection type that stores a set of unique items. It is similar to a vector, but it
does not allow duplicate items. This property makes it useful for storing a collection of unique
items, such as a list of IDs or addresses.

```move
module book::collections_vec_set;  
  
use sui::vec_set::{Self, VecSet};  
  
public struct App has drop {  
    /// `VecSet` used in the struct definition  
    subscribers: VecSet<address>  
}  
  
#[test_only]  
use std::unit_test::assert_eq;  
  
#[test]  
fun vec_set_playground() {  
    let set = vec_set::empty<u8>(); // create an empty set  
    let mut set = vec_set::singleton(1); // create a set with a single item  
  
    set.insert(2); // add an item to the set  
    set.insert(3);  
  
    assert!(set.contains(&1)); // check if an item is in the set  
    assert!(set.length() == 3); // get the number of items in the set  
    assert!(!set.is_empty()); // check if the set is empty  
  
    set.remove(&2); // remove an item from the set  
}
```

VecSet will fail on attempt to insert an item that already exists in the set.

## VecMap[​](#vecmap "Direct link to VecMap")

VecMap is a collection type that stores a map of key-value pairs. It is similar to a VecSet, but
it allows you to associate a value with each item in the set. This makes it useful for storing a
collection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs
and their associated data.

Keys in a VecMap are unique, and each key can only be associated with a single value. If you try
to insert a key-value pair with a key that already exists in the map, the old value will be replaced
with the new value.

```move
module book::collections_vec_map;  
  
use std::string::String;  
use sui::vec_map::{Self, VecMap};  
  
public struct Metadata has drop {  
    name: String,  
    /// `VecMap` used in the struct definition  
    attributes: VecMap<String, String>  
}  
  
#[test]  
fun vec_map_playground() {  
    let mut map = vec_map::empty(); // create an empty map  
  
    map.insert(2, b"two".to_string()); // add a key-value pair to the map  
    map.insert(3, b"three".to_string());  
  
    assert!(map.contains(&2)); // check if a key is in the map  
  
    map.remove(&2); // remove a key-value pair from the map  
}
```

## Limitations[​](#limitations "Direct link to Limitations")

Standard collection types are a great way to store typed data with guaranteed safety and
consistency. However, they are limited by the type of data they can store - the type system won't
allow you to store a wrong type in a collection; and they're limited in size - by the object size
limit. They will work for relatively small-sized sets and lists, but for larger collections you may
need to use a different approach.

Another limitations on collection types is inability to compare them. Because the order of insertion
is not guaranteed, an attempt to compare a VecSet to another VecSet may not yield the expected
results.

> This behavior is caught by the linter and will emit a warning: *Comparing collections of type
> 'sui::vec\_set::VecSet' may yield unexpected result*

```move
let mut set1 = vec_set::empty();  
set1.insert(1);  
set1.insert(2);  
  
let mut set2 = vec_set::empty();  
set2.insert(2);  
set2.insert(1);  
  
assert_eq!(set1, set2); // aborts!
```

In the example above, the comparison will fail because the order of insertion is not guaranteed, and
the two VecSet instances may have different orders of elements. And the comparison will fail even
if the two VecSet instances contain the same elements.

## Summary[​](#summary "Direct link to Summary")

* Vector is a native type that allows storing a list of items.
* VecSet is built on top of vector and allows storing sets of unique items.
* VecMap is used to store key-value pairs in a map-like structure.
* Vector-based collections are strictly typed and limited by the object size limit and are best
  suited for small-sized sets and lists.

## Next Steps[​](#next-steps "Direct link to Next Steps")

In the next section we will cover the [Wrapper Type Pattern](/programmability/wrapper-type-pattern) - a design
pattern often used with collection types to extend or restrict their behavior.

* [Vector](#vector)
* [VecSet](#vecset)
* [VecMap](#vecmap)
* [Limitations](#limitations)
* [Summary](#summary)
* [Next Steps](#next-steps)
Pattern: Wrapper type | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Pattern: Wrapper type

Sometimes, there’s a need to create a new type that behaves similarly to an existing type but with
certain modifications or restrictions. For example, you might want to create a
[collection type](/programmability/collections) that behaves like a vector but doesn’t allow modifying the elements
after they’ve been inserted. The wrapper type pattern is an effective way to achieve this.

## Definition[​](#definition "Direct link to Definition")

The wrapper type pattern is a design pattern in which you create a new type that wraps an existing
type. The wrapper type is distinct from the original but can be converted to and from it.

Often, it is implemented as a positional struct with a single field.

```move
module book::wrapper_type_pattern;  
  
/// Very simple stack implementation using the wrapper type pattern. Does not allow  
/// accessing the elements unless they are popped.  
public struct Stack<T>(vector<T>) has copy, store, drop;  
  
/// Create a new instance by wrapping the value.  
public fun new<T>(value: vector<T>): Stack<T> {  
    Stack(value)  
}  
  
/// Push an element to the stack.  
public fun push_back<T>(v: &mut Stack<T>, el: T) {  
    v.0.push_back(el);  
}  
  
/// Pop an element from the stack. Unlike `vector`, this function won't  
/// fail if the stack is empty and will return `None` instead.  
public fun pop_back<T>(v: &mut Stack<T>): Option<T> {  
    if (v.0.length() == 0) option::none()  
    else option::some(v.0.pop_back())  
}  
  
/// Get the size of the stack.  
public fun size<T>(v: &Stack<T>): u64 {  
    v.0.length()  
}
```

## Common Practices[​](#common-practices "Direct link to Common Practices")

In cases where the goal is to extend the behavior of an existing type, it is common to provide
accessors for the wrapped type. This approach allows users to access the underlying type directly
when needed. For example, in the following code, we provide the inner(), inner\_mut(), and
into\_inner() methods for the Stack type.

```move
/// Allows reading the contents of the `Stack`.  
public fun inner<T>(v: &Stack<T>): &vector<T> { &v.0 }  
  
/// Allows mutable access to the contents of the `Stack`.  
public fun inner_mut<T>(v: &mut Stack<T>): &mut vector<T> { &mut v.0 }  
  
/// Unpacks the `Stack` into the underlying `vector`.  
public fun into_inner<T>(v: Stack<T>): vector<T> {  
    let Stack(inner) = v;  
    inner  
}
```

## Advantages[​](#advantages "Direct link to Advantages")

The wrapper type pattern offers several benefits:

* Custom Functions: It allows you to define custom functions for an existing type.
* Robust Function Signatures: It constrains function signatures to the new type, thereby making the
  code more robust.
* Improved Readability: It often increases the readability of the code by providing a more
  descriptive type name.

## Disadvantages[​](#disadvantages "Direct link to Disadvantages")

The wrapper type pattern is powerful in two scenarios—when you want to limit the behavior of an
existing type while providing a custom interface to the same data structure, and when you want to
extend the behavior of an existing type. However, it does have some limitations:

* Verbosity: It can be verbose to implement, especially if you want to expose all the methods of the
  wrapped type.
* Sparse Implementation: The implementation can be quite minimal, as it often just forwards calls to
  the wrapped type.

## Next Steps[​](#next-steps "Direct link to Next Steps")

The wrapper type pattern is very useful, particularly when used in conjunction with collection
types, as demonstrated in the previous section. In the next section, we will cover
[Dynamic Fields](/programmability/dynamic-fields) — an important primitive that enables
[Dynamic Collections](/programmability/dynamic-collections), a way to store large collections of data in a more
flexible, albeit more expensive, way.

* [Definition](#definition)
* [Common Practices](#common-practices)
* [Advantages](#advantages)
* [Disadvantages](#disadvantages)
* [Next Steps](#next-steps)
Dynamic Fields | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Dynamic Fields

Sui Object model allows objects to be attached to other objects as *dynamic fields*. The behavior is
similar to how a Map works in other programming languages. However, unlike a Map which in Move
would be strictly typed (we have covered it in the [Collections](/programmability/collections) section), dynamic
fields allow attaching objects of any type. A similar approach from the world of frontend
development would be a JavaScript Object type which allows storing any type of data dynamically.

> There's no limit to the number of dynamic fields that can be attached to an object. Thus, dynamic
> fields can be used to store large amounts of data that don't fit into the object limit size.

Dynamic Fields allow for a wide range of applications, from splitting data into smaller parts to
avoid [object size limit](/guides/building-against-limits) to attaching objects as a part of
application logic.

## Definition[​](#definition "Direct link to Definition")

Dynamic Fields are defined in the sui::dynamic\_field module of the
[Sui Framework](/programmability/sui-framework). They are attached to object's UID via a *name*, and can be
accessed using that name. There can be only one field with a given name attached to an object.

```move
module sui::dynamic_field;  
  
/// Internal object used for storing the field and value  
public struct Field<Name: copy + drop + store, Value: store> has key {  
    /// Determined by the hash of the object ID, the field name  
    /// value and it's type, i.e. hash(parent.id || name || Name)  
    id: UID,  
    /// The value for the name of this field  
    name: Name,  
    /// The value bound to this field  
    value: Value,  
}
```

As the definition shows, dynamic fields are stored in an internal Field object, which has the
UID generated in a deterministic way based on the object ID, the field name, and the field type.
The Field object contains the field name and the value bound to it. The constraints on the Name
and Value type parameters define the abilities that the key and value must have.

## Usage[​](#usage "Direct link to Usage")

The methods available for dynamic fields are straightforward: a field can be added with add,
removed with remove, and read with borrow and borrow\_mut. Additionally, the exists\_ method
can be used to check if a field exists (for stricter checks with type, there is an
exists\_with\_type method).

```move
module book::dynamic_fields;  
  
// a very common alias for `dynamic_field` is `df` since the  
// module name is quite long  
use sui::dynamic_field as df;  
use std::string::String;  
  
/// The object that we will attach dynamic fields to.  
public struct Character has key {  
    id: UID  
}  
  
// List of different accessories that can be attached to a character.  
// They must have the `store` ability.  
public struct Hat has key, store { id: UID, color: u32 }  
public struct Mustache has key, store { id: UID }  
  
#[test]  
fun test_character_and_accessories() {  
    let ctx = &mut tx_context::dummy();  
    let mut character = Character { id: object::new(ctx) };  
  
    // Attach a hat to the character's UID  
    df::add(  
        &mut character.id,  
        b"hat_key",  
        Hat { id: object::new(ctx), color: 0xFF0000 }  
    );  
  
    // Similarly, attach a mustache to the character's UID  
    df::add(  
        &mut character.id,  
        b"mustache_key",  
        Mustache { id: object::new(ctx) }  
    );  
  
    // Check that the hat and mustache are attached to the character  
    assert!(df::exists_(&character.id, b"hat_key"));  
    assert!(df::exists_(&character.id, b"mustache_key"));  
  
    // Modify the color of the hat  
    let hat: &mut Hat = df::borrow_mut(&mut character.id, b"hat_key");  
    hat.color = 0x00FF00;  
  
    // Remove the hat and mustache from the character  
    let hat: Hat = df::remove(&mut character.id, b"hat_key");  
    let mustache: Mustache = df::remove(&mut character.id, b"mustache_key");  
  
    // Check that the hat and mustache are no longer attached to the character  
    assert!(!df::exists_(&character.id, b"hat_key"));  
    assert!(!df::exists_(&character.id, b"mustache_key"));  
  
    std::unit_test::destroy(character);  
    std::unit_test::destroy(mustache);  
    std::unit_test::destroy(hat);  
}
```

In the example above, we define a Character object and two different types of accessories that
could never be put together in a vector. However, dynamic fields allow us to store them together in
a single object. Both objects are attached to the Character via a vector<u8> (bytestring
literal), and can be accessed using their respective names.

As you can see, when we attached the accessories to the Character, we passed them *by value*. In
other words, both values were moved to a new scope, and their ownership was transferred to the
Character object. If we changed the ownership of Character object, the accessories would have
been moved with it.

And the last important property of dynamic fields we should highlight is that they are *accessed
through their parent*. This means that the Hat and Mustache objects are not directly accessible
and follow the same rules as the parent object.

## Foreign Types as Dynamic Fields[​](#foreign-types-as-dynamic-fields "Direct link to Foreign Types as Dynamic Fields")

Dynamic fields allow objects to carry data of any type, including those defined in other modules.
This is possible due to their generic nature and relatively weak constraints on the type parameters.
Let's illustrate this by attaching a few different values to a Character object.

```move
let mut character = Character { id: object::new(ctx) };  
  
// Attach a `String` via a `vector<u8>` name  
df::add(&mut character.id, b"string_key", b"Hello, World!".to_string());  
  
// Attach a `u64` via a `u32` name  
df::add(&mut character.id, 1000u32, 1_000_000_000u64);  
  
// Attach a `bool` via a `bool` name  
df::add(&mut character.id, true, false);
```

In this example we showed how different types can be used for both *name* and the *value* of a
dynamic field. The String is attached via a vector<u8> name, the u64 is attached via a u32
name, and the bool is attached via a bool name. Anything is possible with dynamic fields!

## Orphaned Dynamic Fields[​](#orphaned-dynamic-fields "Direct link to Orphaned Dynamic Fields")

> To prevent orphaned dynamic fields, please, use [Dynamic Collection Types](/programmability/dynamic-collections)
> such as Bag as they track the dynamic fields and won't allow unpacking if there are attached
> fields.

The object::delete() function, which is used to delete a UID, does not track the dynamic fields,
and cannot prevent dynamic fields from becoming orphaned. Once the parent UID is deleted, the
dynamic fields are not automatically deleted, and they become orphaned. This means that the dynamic
fields are still stored in the blockchain, but they will never become accessible again.

```move
let hat = Hat { id: object::new(ctx), color: 0xFF0000 };  
let mut character = Character { id: object::new(ctx) };  
  
// Attach a `Hat` via a `vector<u8>` name  
df::add(&mut character.id, b"hat_key", hat);  
  
// ! DO NOT do this in your code  
// ! Danger - deleting the parent object  
let Character { id } = character;  
id.delete();  
  
// ...`Hat` is now stuck in a limbo, it will never be accessible again
```

Orphaned objects are not a subject to storage rebate, and the storage fees will remain unclaimed.
One way to avoid orphaned dynamic fields during unpacking of an object is to return the UID and
store it somewhere temporarily until the dynamic fields are removed and handled properly.

## Custom Type as a Field Name[​](#custom-type-as-a-field-name "Direct link to Custom Type as a Field Name")

In the examples above, we used primitive types as field names since they have the required set of
abilities. But dynamic fields get even more interesting when we use custom types as field names.
This allows for a more structured way of storing data, and also allows for protecting the field
names from being accessed by other modules.

```move
/// A custom type with fields in it.  
public struct AccessoryKey has copy, drop, store { name: String }  
  
/// An empty key, can be attached only once.  
public struct MetadataKey has copy, drop, store {}
```

Two field names that we defined above are AccessoryKey and MetadataKey. The AccessoryKey has a
String field in it, hence it can be used multiple times with different name values. The
MetadataKey is an empty key, and can be attached only once.

```move
let mut character = Character { id: object::new(ctx) };  
  
// Attaching via an `AccessoryKey { name: b"hat" }`  
df::add(  
    &mut character.id,  
    AccessoryKey { name: b"hat".to_string() },  
    Hat { id: object::new(ctx), color: 0xFF0000 }  
);  
// Attaching via an `AccessoryKey { name: b"mustache" }`  
df::add(  
    &mut character.id,  
    AccessoryKey { name: b"mustache".to_string() },  
    Mustache { id: object::new(ctx) }  
);  
  
// Attaching via a `MetadataKey`  
df::add(&mut character.id, MetadataKey {}, 42);
```

As you can see, custom types do work as field names but as long as they can be *constructed* by the
module, in other words - if they are *internal* to the module and defined in it. This limitation on
struct packing can open up new ways in the design of the application.

This approach is used in the Object Capability pattern, where an
application can authorize a foreign object to perform operations in it while not exposing the
capabilities to other modules.

## Exposing UID[​](#exposing-uid "Direct link to Exposing UID")

Mutable access to UID is a security risk. Exposing UID of your type as a mutable reference can
lead to unwanted modifications or removal of the object's dynamic fields. Additionally, it affects
the Transfer to Object and
[Dynamic Object Fields](/programmability/dynamic-object-fields). Make sure to understand the implications before
exposing the UID as a mutable reference.

Because dynamic fields are attached to UIDs, their usage in other modules depends on whether the
UID can be accessed. By default struct visibility protects the id field and won't let other
modules access it directly. However, if there's a public accessor method that returns a reference to
UID, dynamic fields can be read in other modules.

```move
/// Exposes the UID of the character, so that other modules can read  
/// dynamic fields.  
public fun uid(c: &Character): &UID {  
    &c.id  
}
```

In the example above, we show how to expose the UID of a Character object. This solution may
work for some applications, however, it is important to remember that exposed UID allows reading
*any* dynamic field attached to the object.

If you need to expose the UID only within the package, use a restrictive visibility, like
public(package), or even better - use more specific accessor methods that would allow only reading
specific fields.

```move
/// Only allow modules in the same package to access the UID.  
public(package) fun uid_package(c: &Character): &UID {  
    &c.id  
}  
  
/// Allow borrowing dynamic fields from the character.  
public fun borrow<Name: copy + store + drop, Value: store>(  
    c: &Character,  
    n: Name  
): &Value {  
    df::borrow(&c.id, n)  
}
```

## Dynamic Fields vs Fields[​](#dynamic-fields-vs-fields "Direct link to Dynamic Fields vs Fields")

Dynamic Fields are more expensive than regular fields, as they require additional storage and costs
for accessing them. Their flexibility comes at a price, and it is important to understand the
implications when making a decision between using dynamic fields and regular fields.

## Limits[​](#limits "Direct link to Limits")

Dynamic Fields are not subject to the [object size limit](/guides/building-against-limits), and
can be used to store large amounts of data. However, they are still subject to the
[dynamic fields created limit](/guides/building-against-limits), which is set to 1000 fields per
transaction.

## Applications[​](#applications "Direct link to Applications")

Dynamic Fields can play a crucial role in applications of any complexity. They open up a variety of
different use cases, from storing heterogeneous data to attaching objects as part of the application
logic. They allow for certain [upgradeability practices](/guides/upgradeability-practices) based
on the ability to define them *later* and change the type of the field.

## Next Steps[​](#next-steps "Direct link to Next Steps")

In the next section we will cover [Dynamic Object Fields](/programmability/dynamic-object-fields) and explain how
they differ from dynamic fields, and what are the implications of using them.

* [Definition](#definition)
* [Usage](#usage)
* [Foreign Types as Dynamic Fields](#foreign-types-as-dynamic-fields)
* [Orphaned Dynamic Fields](#orphaned-dynamic-fields)
* [Custom Type as a Field Name](#custom-type-as-a-field-name)
* [Exposing UID](#exposing-uid)
* [Dynamic Fields vs Fields](#dynamic-fields-vs-fields)
* [Limits](#limits)
* [Applications](#applications)
* [Next Steps](#next-steps)
Dynamic Object Fields | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Dynamic Object Fields

> This section expands on the [Dynamic Fields](/programmability/dynamic-fields). Please, read it first to
> understand the basics of dynamic fields.

Another variation of dynamic fields is *dynamic object fields*, which have certain differences from
regular dynamic fields. In this section, we will cover the specifics of dynamic object fields and
explain how they differ from regular dynamic fields.

> General recommendation is to avoid using dynamic object fields in favor of (just) dynamic fields,
> especially if there's no need for direct discovery through the ID. The extra costs of dynamic
> object fields may not be justified by the benefits they provide.

## Definition[​](#definition "Direct link to Definition")

Dynamic Object Fields are defined in the sui::dynamic\_object\_fields module in the
[Sui Framework](/programmability/sui-framework). They are similar to dynamic fields in many ways, but unlike them,
dynamic object fields have an extra constraint on the Value type. The Value must have a
combination of key and store, not just store as in the case of dynamic fields.

They're less explicit in their framework definition, as the concept itself is more abstract:

```move
module sui::dynamic_object_field;  
  
/// Internal object used for storing the field and the name associated with the  
/// value. The separate type is necessary to prevent key collision with direct  
/// usage of dynamic_field  
public struct Wrapper<Name> has copy, drop, store {  
    name: Name,  
}
```

Unlike Field type in the [Dynamic Fields](/programmability/dynamic-fields#definition) section, the Wrapper type
only stores the name of the field. The value is the object itself, and is *not wrapped*.

The constraints on the Value type become visible in the methods available for dynamic object
fields. Here's the signature for the add function:

```move
/// Adds a dynamic object field to the object `object: &mut UID` at field  
/// specified by `name: Name`. Aborts with `EFieldAlreadyExists` if the object  
/// already has that field with that name.  
public fun add<Name: copy + drop + store, Value: key + store>(  
    // we use &mut UID in several spots for access control  
    object: &mut UID,  
    name: Name,  
    value: Value,  
) { /* implementation omitted */ }
```

The rest of the methods which are identical to the ones in the
[Dynamic Fields](/programmability/dynamic-fields#usage) section have the same constraints on the Value type.
Let's list them for reference:

* add - adds a dynamic object field to the object
* remove - removes a dynamic object field from the object
* borrow - borrows a dynamic object field from the object
* borrow\_mut - borrows a mutable reference to a dynamic object field from the object
* exists\_ - checks if a dynamic object field exists
* exists\_with\_type - checks if a dynamic object field exists with a specific type

Additionally, there is an id method which returns the ID of the Value object without
specifying its type.

## Usage & Differences with Dynamic Fields[​](#usage--differences-with-dynamic-fields "Direct link to Usage & Differences with Dynamic Fields")

The main difference between dynamic fields and dynamic object fields is that the latter allows
storing *only objects* as values. This means that you can't store primitive types like u64 or
bool. It may be considered a limitation, if not for the fact that dynamic object fields are *not
wrapped* into a separate object.

> The relaxed requirement for wrapping keeps the object available for off-chain discovery via its
> ID. However, this property may not be outstanding if wrapped object indexing is implemented,
> making the dynamic object fields a redundant feature.

```move
module book::dynamic_object_field;  
  
use std::string::String;  
  
// there are two common aliases for the long module name: `dof` and  
// `ofield`. Both are commonly used and met in different projects.  
use sui::dynamic_object_field as dof;  
use sui::dynamic_field as df;  
  
/// The `Character` that we will use for the example  
public struct Character has key { id: UID }  
  
/// Metadata that doesn't have the `key` ability  
public struct Metadata has store, drop { name: String }  
  
/// Accessory that has the `key` and `store` abilities.  
public struct Accessory has key, store { id: UID }  
  
#[test]  
fun equip_accessory() {  
    let ctx = &mut tx_context::dummy();  
    let mut character = Character { id: object::new(ctx) };  
  
    // Create an accessory and attach it to the character  
    let hat = Accessory { id: object::new(ctx) };  
  
    // Add the hat to the character. Just like with `dynamic_fields`  
    dof::add(&mut character.id, b"hat_key", hat);  
  
    // However for non-key structs we can only use `dynamic_field`  
    df::add(&mut character.id, b"metadata_key", Metadata {  
        name: b"John".to_string()  
    });  
  
    // Borrow the hat from the character  
    let hat_id = dof::id(&character.id, b"hat_key").extract(); // Option<ID>  
    let hat_ref: &Accessory = dof::borrow(&character.id, b"hat_key");  
    let hat_mut: &mut Accessory = dof::borrow_mut(&mut character.id, b"hat_key");  
    let hat: Accessory = dof::remove(&mut character.id, b"hat_key");  
  
    // Clean up, Metadata is an orphan now.  
    std::unit_test::destroy(hat);  
    std::unit_test::destroy(character);  
}
```

## Pricing Differences[​](#pricing-differences "Direct link to Pricing Differences")

Dynamic Object Fields come a little more expensive than dynamic fields. Because of their internal
structure, they require 2 objects: the Wrapper for Name and the Value. Because of this, the cost of
adding and accessing object fields (loading 2 objects compared to 1 for dynamic fields) is higher.

## Next Steps[​](#next-steps "Direct link to Next Steps")

Both dynamic field and dynamic object fields are powerful features which allow for innovative
solutions in applications. However, they are relatively low-level and require careful handling to
avoid orphaned fields. In the next section, we will introduce a higher-level abstraction -
[Dynamic Collections](/programmability/dynamic-collections) - which can help with managing dynamic fields and
objects more effectively.

* [Definition](#definition)
* [Usage & Differences with Dynamic Fields](#usage--differences-with-dynamic-fields)
* [Pricing Differences](#pricing-differences)
* [Next Steps](#next-steps)
Dynamic Collections | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Dynamic Collections

[Sui Framework](/programmability/sui-framework) offers a variety of collection types that build on the
[dynamic fields](/programmability/dynamic-fields) and [dynamic object fields](/programmability/dynamic-object-fields) concepts.
These collections are designed to be a safer and more understandable way to store and manage dynamic
fields and objects.

For each collection type we will specify the primitive they use, and the specific features they
offer.

> Unlike dynamic (object) fields which operate on UID, collection types have their own type and
> allow calling [associated functions](/move-basics/struct-methods).

## Common Concepts[​](#common-concepts "Direct link to Common Concepts")

All of the collection types share the same set of methods, which are:

* add - adds a field to the collection
* remove - removes a field from the collection
* borrow - borrows a field from the collection
* borrow\_mut - borrows a mutable reference to a field from the collection
* contains - checks if a field exists in the collection
* length - returns the number of fields in the collection
* is\_empty - checks if the length is 0

All collection types support index syntax for borrow and borrow\_mut methods. If you see square
brackets in the examples, they are translated into borrow and borrow\_mut calls.

```move
let hat: &Hat = &bag[b"key"];  
let hat_mut: &mut Hat = &mut bag[b"key"];  
  
// is equivalent to  
let hat: &Hat = bag.borrow(b"key");  
let hat_mut: &mut Hat = bag.borrow_mut(b"key");
```

In the examples we won't focus on these functions, but rather on the differences between the
collection types.

## Bag[​](#bag "Direct link to Bag")

Bag, as the name suggests, acts as a "bag" of heterogeneous values. It is a simple, non-generic type
that can store any data. Bag will never allow orphaned fields, as it tracks the number of fields and
can't be destroyed if it's not empty.

```move
module sui::bag;  
  
public struct Bag has key, store {  
    /// the ID of this bag  
    id: UID,  
    /// the number of key-value pairs in the bag  
    size: u64,  
}
```

*See [full documentation for sui::bag](https://docs.sui.io/references/framework/sui/bag) module.*

Due to Bag storing any types, the extra methods it offers is:

* contains\_with\_type - checks if a field exists with a specific type

Used as a struct field:

```move
/// Imported from the `sui::bag` module.  
use sui::bag::{Self, Bag};  
  
/// An example of a `Bag` as a struct field.  
public struct Carrier has key {  
    id: UID,  
    bag: Bag  
}
```

Using the Bag:

```move
let mut bag = bag::new(ctx);  
  
// bag has the `length` function to get the number of elements  
assert_eq!(bag.length(), 0);  
  
bag.add(b"my_key", b"my_value".to_string());  
  
// length has changed to 1  
assert_eq!(bag.length(), 1);  
  
// in order: `borrow`, `borrow_mut` and `remove`  
// the value type must be specified  
let field_ref: &String = &bag[b"my_key"];  
let field_mut: &mut String = &mut bag[b"my_key"];  
let field: String = bag.remove(b"my_key");  
  
// length is back to 0 - we can unpack  
bag.destroy_empty();
```

## ObjectBag[​](#objectbag "Direct link to ObjectBag")

Defined in the sui::object\_bag module. Identical to [Bag](#bag), but uses
[dynamic object fields](/programmability/dynamic-object-fields) internally. Can only store objects as values.

*See [full documentation for sui::object\_bag](https://docs.sui.io/references/framework/sui/object_bag) module.*

## Table[​](#table "Direct link to Table")

Table is a typed dynamic collection that has a fixed type for keys and values. It is defined in the
sui::table module.

```move
module sui::table;  
  
public struct Table<phantom K: copy + drop + store, phantom V: store> has key, store {  
    /// the ID of this table  
    id: UID,  
    /// the number of key-value pairs in the table  
    size: u64,  
}
```

*See [full documentation for sui::table](https://docs.sui.io/references/framework/sui/table) module.*

Used as a struct field:

```move
/// Imported from the `sui::table` module.  
use sui::table::{Self, Table};  
  
/// Some record type with `store`  
public struct Record has store { /* ... */ }  
  
/// An example of a `Table` as a struct field.  
public struct UserRegistry has key {  
    id: UID,  
    table: Table<address, Record>  
}
```

Using the Table:

```move
// Table requires explicit type parameters for the key and value  
// ...but does it only once in initialization.  
let mut table = table::new<address, String>(ctx);  
  
// table has the `length` function to get the number of elements  
assert_eq!(table.length(), 0);  
  
table.add(@0xa11ce, b"my_value".to_string());  
table.add(@0xb0b, b"another_value".to_string());  
  
// length has changed to 2  
assert_eq!(table.length(), 2);  
  
// in order: `borrow`, `borrow_mut` and `remove`  
let value_ref = &table[@0xa11ce];  
let value_mut = &mut table[@0xa11ce];  
  
// removing both values  
let _value = table.remove(@0xa11ce);  
let _another_value = table.remove(@0xb0b);  
  
// length is back to 0 - we can unpack  
table.destroy_empty();
```

## ObjectTable[​](#objecttable "Direct link to ObjectTable")

Defined in the sui::object\_table module. Identical to [Table](#table), but uses
[dynamic object fields](/programmability/dynamic-object-fields) internally. Can only store objects as values.

*See [full documentation for sui::object\_table](https://docs.sui.io/references/framework/sui/object_table) module.*

## LinkedTable[​](#linkedtable "Direct link to LinkedTable")

It is defined in the sui::linked\_table module, similar to [Table](#table) but the values are linked together,
allowing for ordered insertion and removal.

```move
module sui::linked_table;  
  
public struct LinkedTable<K: copy + drop + store, phantom V: store> has key, store {  
    /// the ID of this table  
    id: UID,  
    /// the number of key-value pairs in the table  
    size: u64,  
    /// the front of the table, i.e. the key of the first entry  
    head: Option<K>,  
    /// the back of the table, i.e. the key of the last entry  
    tail: Option<K>,  
}
```

*See [full documentation for sui::linked\_table](https://docs.sui.io/references/framework/sui/linked_table) module.*

Since the values stored in LinkedTable are linked together, it has unique methods for adding and deleting.

* push\_front - inserts a key-value pair at the front of the table
* push\_back - inserts a key-value pair at the back of the table
* remove - removes a key-value pair by key and returns the value
* pop\_front - removes the front of the table, returns the key and value
* pop\_back - removes the back of the table, returns the key and value

Used as a struct field:

```move
/// Imported from the `sui::linked_table` module.  
use sui::linked_table::{Self, LinkedTable};  
  
/// Some record type with `store`  
public struct Permissions has store { /* ... */ }  
  
/// An example of a `LinkedTable` as a struct field.  
public struct AdminRegistry has key {  
    id: UID,  
    linked_table: LinkedTable<address, Permissions>  
}
```

Using the LinkedTable:

```move
// LinkedTable requires explicit type parameters for the key and value  
// ...but does it only once in initialization.  
let mut linked_table = linked_table::new<address, String>(ctx);  
  
// linked_table has the `length` function to get the number of elements  
assert_eq!(linked_table.length(), 0);  
  
linked_table.push_front(@0xa0a, b"first_value".to_string());  
linked_table.push_back(@0xb1b, b"second_value".to_string());  
linked_table.push_back(@0xc2c, b"third_value".to_string());  
  
// length has changed to 3  
assert_eq!(linked_table.length(), 3);  
  
// in order: `borrow`, `borrow_mut` and `remove`  
let first_value_ref = &linked_table[@0xa0a];  
let second_value_mut = &mut linked_table[@0xb1b];  
  
// remove by key, from the beginning or from the end  
let _second_value = linked_table.remove(@0xb1b);  
let (_first_addr, _first_value) = linked_table.pop_front();  
let (_third_addr, _third_value) = linked_table.pop_back();  
  
// length is back to 0 - we can unpack  
linked_table.destroy_empty();
```

## Summary[​](#summary "Direct link to Summary")

* [Bag](#bag) - a simple collection that can store any type of data.
* [ObjectBag](#objectbag) - a collection that can store only objects.
* [Table](#table) - a typed dynamic collection that has a fixed type for keys and values.
* [ObjectTable](#objecttable) - same as Table, but can only store objects.
* [LinkedTable](#linkedtable) - similar to Table but the values are linked together.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [sui::table](https://docs.sui.io/references/framework/sui/table) module documentation.
* [sui::object\_table](https://docs.sui.io/references/framework/sui/object_table) module documentation.
* [sui::linked\_table](https://docs.sui.io/references/framework/sui/linked_table) module documentation.
* [sui::bag](https://docs.sui.io/references/framework/sui/bag) module documentation.
* [sui::object\_bag](https://docs.sui.io/references/framework/sui/object_bag) module documentation.

* [Common Concepts](#common-concepts)
* [Bag](#bag)
* [ObjectBag](#objectbag)
* [Table](#table)
* [ObjectTable](#objecttable)
* [LinkedTable](#linkedtable)
* [Summary](#summary)
* [Further Reading](#further-reading)
Pattern: Witness | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Pattern: Witness

Witness is a pattern of proving an existence by constructing a proof. In the context of programming,
witness is a way to prove a certain property of a system by providing a value that can only be
constructed if the property holds.

## Witness in Move[​](#witness-in-move "Direct link to Witness in Move")

In the [Struct](/move-basics/struct) section we have shown that a struct can only be created -
or *packed* - by the module defining it. Hence, in Move, a module proves ownership of the type by
constructing it. This is one of the most important patterns in Move, and it is widely used for
generic type instantiation and authorization.

Practically speaking, for the witness to be used, there has to be a function that expects a witness
as an argument. In the example below it is the new function that expects a witness of the T type
to create a Instance<T> instance.

> It is often the case that the witness struct is not stored, and for that the function may require
> the [Drop](/move-basics/drop-ability) ability for the type.

```move
module book::witness;  
  
/// A struct that requires a witness to be created.  
public struct Instance<T> { t: T }  
  
/// Create a new instance of `Instance<T>` with the provided T.  
public fun new<T>(witness: T): Instance<T> {  
    Instance { t: witness }  
}
```

The only way to construct an Instance<T> is to call the new function with an instance of the
type T. This is a basic example of the witness pattern in Move. A module providing a witness often
has a matching implementation, like the module book::witness\_source below:

```move
module book::witness_source;  
  
use book::witness::{Self, Instance};  
  
/// A struct used as a witness.  
public struct W {}  
  
/// Create a new instance of `Instance<W>`.  
public fun new_instance(): Instance<W> {  
    witness::new(W {})  
}
```

The instance of the struct W is passed into the new\_instance function to create an
Instance<W>, thereby proving that the module book::witness\_source owns the type W.

## Instantiating a Generic Type[​](#instantiating-a-generic-type "Direct link to Instantiating a Generic Type")

Witness allows generic types to be instantiated with a concrete type. This is useful for inheriting
associated behaviors from the type with an option to extend them, if the module provides the ability
to do so.

```move
module sui::balance;  
  
/// A Supply of T. Used for minting and burning.  
public struct Supply<phantom T> has store {  
    value: u64,  
}  
  
/// Create a new supply for type T with the provided witness.  
public fun create_supply<T: drop>(_w: T): Supply<T> {  
    Supply { value: 0 }  
}  
  
/// Get the `Supply` value.  
public fun supply_value<T>(supply: &Supply<T>): u64 {  
    supply.value  
}
```

In the example above, which is borrowed from the [balance module](https://docs.sui.io/references/framework/sui/balance) of the
[Sui Framework](/programmability/sui-framework), the Supply is a generic struct that can be constructed only by
supplying a witness of the type T. The witness is taken by value and *discarded* - hence the T
must have the [drop](/move-basics/drop-ability) ability.

The instantiated Supply<T> can then be used to mint new Balance<T>'s, where T is the type of
the supply.

```move
module sui::balance;  
  
const EOverflow: u64 = 0;  
  
/// Storable balance.  
public struct Balance<phantom T> has store {  
    value: u64,  
}  
  
/// Increase supply by `value` and create a new `Balance<T>` with this value.  
public fun increase_supply<T>(self: &mut Supply<T>, value: u64): Balance<T> {  
    assert!(value < (std::u64::max_value!() - self.value), EOverflow);  
    self.value = self.value + value;  
    Balance { value }  
}
```

## One Time Witness[​](#one-time-witness "Direct link to One Time Witness")

While a struct can be created any number of times, there are cases where a struct should be
guaranteed to be created only once. For this purpose, Sui provides the "One-Time Witness" - a
special witness that can only be used once. We explain it in more detail in the
[next section](/programmability/one-time-witness).

## Summary[​](#summary "Direct link to Summary")

* Witness is a pattern of proving a certain property by constructing a proof.
* In Move, a module proves ownership of a type by constructing it.
* Witness is often used for generic type instantiation and authorization.

## Next Steps[​](#next-steps "Direct link to Next Steps")

In the next section, we will learn about the [One Time Witness](/programmability/one-time-witness) pattern.

* [Witness in Move](#witness-in-move)
* [Instantiating a Generic Type](#instantiating-a-generic-type)
* [One Time Witness](#one-time-witness)
* [Summary](#summary)
* [Next Steps](#next-steps)
One Time Witness | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# One Time Witness

While regular [Witness](/programmability/witness-pattern) is a great way to statically prove the ownership of a
type, there are cases where we need to ensure that a Witness is instantiated only once. And this is
the purpose of the One Time Witness (OTW).

## Definition[​](#definition "Direct link to Definition")

The OTW is a special type of Witness that can be used only once. It cannot be manually created and
it is guaranteed to be unique per module. Sui Adapter treats a type as an OTW if it follows these
rules:

1. Has only drop ability.
2. Has no fields.
3. Is not a generic type.
4. Named after the module with all uppercase letters.

Here is an example of an OTW:

```move
module book::one_time;  
  
/// The OTW for the `book::one_time` module.  
/// Only `drop`, no fields, no generics, all uppercase.  
public struct ONE_TIME has drop {}  
  
/// Receive the instance of `ONE_TIME` as the first argument.  
fun init(otw: ONE_TIME, ctx: &mut TxContext) {  
    // do something with the OTW  
}
```

The OTW cannot be constructed manually, and any code attempting to do so will result in a
compilation error. The OTW can be received as the first argument in the
[module initializer](/programmability/module-initializer). And because the init function is called only once per
module, the OTW is guaranteed to be instantiated only once.

## Enforcing the OTW[​](#enforcing-the-otw "Direct link to Enforcing the OTW")

To check if a type is an OTW, sui::types module of the [Sui Framework](/programmability/sui-framework) offers a
special function is\_one\_time\_witness that can be used to check if the type is an OTW.

```move
use sui::types;  
  
const ENotOneTimeWitness: u64 = 1;  
  
/// Takes an OTW as an argument, aborts if the type is not OTW.  
public fun takes_witness<T: drop>(otw: T) {  
    assert!(types::is_one_time_witness(&otw), ENotOneTimeWitness);  
}
```

## Summary[​](#summary "Direct link to Summary")

The OTW pattern is a great way to ensure that a type is used only once. Most of the developers
should understand how to define and receive the OTW, while the OTW checks and enforcement is mostly
needed in libraries and frameworks. For example, the sui::coin module requires an OTW in the
coin::create\_currency method, therefore enforcing that the coin::TreasuryCap is created only
once.

OTW is a powerful tool that lays the foundation for the [Publisher](/programmability/publisher) object, which we
will cover in the next section.

* [Definition](#definition)
* [Enforcing the OTW](#enforcing-the-otw)
* [Summary](#summary)
Publisher Authority | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Publisher Authority

In application design and development, it is often needed to prove publisher authority. This is
especially important in the context of digital assets, where the publisher may enable or disable
certain features for their assets. The Publisher Object is an object, defined in the
[Sui Framework](/programmability/sui-framework), that allows the publisher to prove their *authority over a type*.

## Definition[​](#definition "Direct link to Definition")

The Publisher object is defined in the sui::package module of the Sui Framework. It is a very
simple, non-generic object that can be initialized once per module (and multiple times per package)
and is used to prove the authority of the publisher over a type. To claim a Publisher object, the
publisher must present a [One Time Witness](/programmability/one-time-witness) to the package::claim function.

```move
module sui::package;  
  
public struct Publisher has key, store {  
    id: UID,  
    package: String,  
    module_name: String,  
}
```

> If you're not familiar with the One Time Witness, you can read more about it
> [here](/programmability/one-time-witness).

Here's a simple example of claiming a Publisher object in a module:

```move
module book::publisher;  
  
use sui::package::{Self, Publisher};  
  
/// Some type defined in the module.  
public struct Book {}  
  
/// The OTW for the module.  
public struct PUBLISHER has drop {}  
  
/// Uses the One Time Witness to claim the Publisher object.  
fun init(otw: PUBLISHER, ctx: &mut TxContext) {  
    // Claim the Publisher object.  
    let publisher: Publisher = sui::package::claim(otw, ctx);  
  
    // Usually it is transferred to the sender.  
    // It can also be stored in another object.  
    transfer::public_transfer(publisher, ctx.sender())  
}
```

## Usage[​](#usage "Direct link to Usage")

The Publisher object has two functions associated with it which are used to prove the publisher's
authority over a type:

```move
// Checks if the type is from the same module, hence the `Publisher` has the  
// authority over it.  
assert!(publisher.from_module<Book>());  
  
// Checks if the type is from the same package, hence the `Publisher` has the  
// authority over it.  
assert!(publisher.from_package<Book>());
```

## Publisher as Admin Role[​](#publisher-as-admin-role "Direct link to Publisher as Admin Role")

For small applications or simple use cases, the Publisher object can be used as an admin
[capability](/programmability/capability). While in the broader context, the Publisher object has control over
system configurations, it can also be used to manage the application's state.

```move
/// Some action in the application gated by the Publisher object.  
public fun admin_action(cap: &Publisher, /* app objects... */ param: u64) {  
    assert!(cap.from_module<Book>(), ENotAuthorized);  
  
    // perform application-specific action  
}
```

However, Publisher misses some native properties of [Capabilities](/programmability/capability), such as type
safety and expressiveness. The signature for the admin\_action is not very explicit, can be called
by anyone else. And due to Publisher object being standard, there is now a risk of unauthorized
access if the from\_module check is not performed. So it's important to be cautious when using the
Publisher object as an admin role.

## Role on Sui[​](#role-on-sui "Direct link to Role on Sui")

Publisher is required for certain features on Sui. [Object Display](/programmability/display) can be created only
by the Publisher, and TransferPolicy - an important component of the Kiosk system - also requires
the Publisher object to prove ownership of the type.

## Next Steps[​](#next-steps "Direct link to Next Steps")

In the next chapter we will cover the first feature that requires the Publisher object - Object
Display - a way to describe objects for clients, and standardize metadata. A must-have for
user-friendly applications.

* [Definition](#definition)
* [Usage](#usage)
* [Publisher as Admin Role](#publisher-as-admin-role)
* [Role on Sui](#role-on-sui)
* [Next Steps](#next-steps)
Object Display | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Object Display

Objects on Sui are explicit in their structure and behavior and can be displayed in an
understandable way. However, to support richer metadata for clients, there's a standard and
efficient way of "describing" them to the client - the Display object defined in the
[Sui Framework](/programmability/sui-framework).

## Background[​](#background "Direct link to Background")

Historically, there were different attempts to agree on a standard structure of an object so it can
be displayed in a user interface. One of the approaches was to define certain fields in the object
struct which, when present, would be used in the UI. This approach was not flexible enough and
required developers to define the same fields in every object, and sometimes the fields did not make
sense for the object.

```move
/// An attempt to standardize the object structure for display.  
public struct CounterWithDisplay has key {  
    id: UID,  
    /// If this field is present it will be displayed in the UI as `name`.  
    name: String,  
    /// If this field is present it will be displayed in the UI as `description`.  
    description: String,  
    // ...  
    image: String,  
    /// Actual fields of the object.  
    counter: u64,  
    // ...  
}
```

If any of the fields contained static data, it would be duplicated in every object. And, since Move
does not have interfaces, it is not possible to know if an object has a specific field without
"manually" checking the object's type, which makes the client fetching more complex.

## Object Display[​](#object-display-1 "Direct link to Object Display")

To address these issues, Sui introduces a standard way of describing an object for display. Instead
of defining fields in the object struct, the display metadata is stored in a separate object, which
is associated with the type. This way, the display metadata is not duplicated, and it is easy to
extend and maintain.

Another important feature of Sui Display is the ability to define templates and use object fields in
those templates. Not only it allows for a more flexible display, but it also frees the developer
from the need to define the same fields with the same names and types in every object.

> The Object Display is natively supported by the
> [Sui Full Node](https://docs.sui.io/guides/operator/sui-full-node), and the client can fetch the
> display metadata for any object if the object type has a Display associated with it.

```move
module book::arena;  
  
use std::string::String;  
use sui::package;  
use sui::display;  
  
/// The One Time Witness to claim the `Publisher` object.  
public struct ARENA has drop {}  
  
/// Some object which will be displayed.  
public struct Hero has key {  
    id: UID,  
    class: String,  
    level: u64,  
}  
  
/// In the module initializer we create the `Publisher` object, and then  
/// the Display for the `Hero` type.  
fun init(otw: ARENA, ctx: &mut TxContext) {  
    let publisher = package::claim(otw, ctx);  
    let mut display = display::new<Hero>(&publisher, ctx);  
  
    display.add(  
        b"name".to_string(),  
        b"{class} (lvl. {level})".to_string()  
    );  
  
    display.add(  
        b"description".to_string(),  
        b"One of the greatest heroes of all time. Join us!".to_string()  
    );  
  
    display.add(  
        b"link".to_string(),  
        b"https://example.com/hero/{id}".to_string()  
    );  
  
    display.add(  
        b"image_url".to_string(),  
        b"https://example.com/hero/{class}.jpg".to_string()  
    );  
  
    // Update the display with the new data.  
    // Must be called to apply changes.  
    display.update_version();  
  
    transfer::public_transfer(publisher, ctx.sender());  
    transfer::public_transfer(display, ctx.sender());  
}
```

## Creator Privilege[​](#creator-privilege "Direct link to Creator Privilege")

While the objects can be owned by accounts and may be a subject to
[True Ownership](/object/ownership#account-owner-or-single-owner), the Display can be owned by
the creator of the object. This way, the creator can update the display metadata and apply the
changes globally without the need to update every object. The creator can also transfer Display to
another account or even build an application around the object with custom functionality to manage
the metadata.

## Standard Fields[​](#standard-fields "Direct link to Standard Fields")

The fields that are supported most widely are:

* name - A name for the object. The name is displayed when users view the object.
* description - A description for the object. The description is displayed when users view the
  object.
* link - A link to the object to use in an application.
* image\_url - A URL or a blob with the image for the object.
* thumbnail\_url - A URL to a smaller image to use in wallets, explorers, and other products as a
  preview.
* project\_url - A link to a website associated with the object or creator.
* creator - A string that indicates the object creator.

> Please, refer to the [Sui Documentation](https://docs.sui.io/standards/display) for the most
> up-to-date list of supported fields.

While there's a standard set of fields, the Display object does not enforce them. The developer can
define any fields they need, and the client can use them as they see fit. Some applications may
require additional fields, and omit other, and the Display is flexible enough to support them.

## Working with Display[​](#working-with-display "Direct link to Working with Display")

The Display object is defined in the sui::display module. It is a generic struct that takes a
phantom type as a parameter. The phantom type is used to associate the Display object with the
type it describes. The fields of the Display object are a VecMap of key-value pairs, where the
key is the field name and the value is the field value. The version field is used to version the
display metadata, and is updated on the update\_display call.

```move
module sui::display;  
  
public struct Display<phantom T: key> has key, store {  
    id: UID,  
    /// Contains fields for display. Currently supported  
    /// fields are: name, link, image and description.  
    fields: VecMap<String, String>,  
    /// Version that can only be updated manually by the Publisher.  
    version: u16  
}
```

The [Publisher](/programmability/publisher) object is required to a new Display, since it serves as the proof of
ownership of type.

## Template Syntax[​](#template-syntax "Direct link to Template Syntax")

Currently, Display supports simple string interpolation and can use struct fields (and paths) in its
templates. The syntax is trivial - {path} is replaced with the value of the field at the path. The
path is a dot-separated list of field names, starting from the root object in case of nested fields.

```move
/// Some common metadata for objects.  
public struct Metadata has store {  
    name: String,  
    description: String,  
    published_at: u64  
}  
  
/// The type with nested Metadata field.  
public struct LittlePony has key, store {  
    id: UID,  
    image_url: String,  
    metadata: Metadata  
}
```

The Display for the type LittlePony above could be defined as follows:

```move
{  
  "name": "Just a pony",  
  "image_url": "{image_url}",  
  "description": "{metadata.description}"  
}
```

## Multiple Display Objects[​](#multiple-display-objects "Direct link to Multiple Display Objects")

There's no restriction to how many Display<T> objects can be created for a specific T. However,
the most recently updated Display<T> will be used by the full node.

## Further Reading[​](#further-reading "Direct link to Further Reading")

* [Sui Object Display](https://docs.sui.io/standards/display) is Sui Documentation
* [Publisher](/programmability/publisher) - the representation of the creator

* [Background](#background)
* [Object Display](#object-display-1)
* [Creator Privilege](#creator-privilege)
* [Standard Fields](#standard-fields)
* [Working with Display](#working-with-display)
* [Template Syntax](#template-syntax)
* [Multiple Display Objects](#multiple-display-objects)
* [Further Reading](#further-reading)
Events | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Events

Events are a way to notify off-chain listeners about on-chain events. They are used to emit
additional information about the transaction that is not stored - and, hence, can't be accessed -
on-chain. Events are emitted by the sui::event module located in the
[Sui Framework](/programmability/sui-framework).

> Any custom type with the [copy](/move-basics/copy-ability) and
> [drop](/move-basics/drop-ability) abilities can be emitted as an event. Sui Verifier requires
> the type to be internal to the module.

```move
module sui::event;  
  
/// Emit a custom Move event, sending the data off-chain.  
///  
/// Used for creating custom indexes and tracking on-chain  
/// activity in a way that suits a specific application the most.  
///  
/// The type `T` is the main way to index the event, and can contain  
/// phantom parameters, eg `emit(MyEvent<phantom T>)`.  
public native fun emit<T: copy + drop>(event: T);
```

## Emitting Events[​](#emitting-events "Direct link to Emitting Events")

Events are emitted using the emit function in the sui::event module. The function takes a single
argument - the event to be emitted. The event data is passed by value,

```move
module book::events;  
  
use sui::coin::Coin;  
use sui::sui::SUI;  
use sui::event;  
  
/// The item that can be purchased.  
public struct Item has key { id: UID }  
  
/// Event emitted when an item is purchased. Contains the ID of the item and  
/// the price for which it was purchased.  
public struct ItemPurchased has copy, drop {  
    item: ID,  
    price: u64  
}  
  
/// A marketplace function which performs the purchase of an item.  
public fun purchase(coin: Coin<SUI>, ctx: &mut TxContext) {  
    let item = Item { id: object::new(ctx) };  
  
    // Create an instance of `ItemPurchased` and pass it to `event::emit`.  
    event::emit(ItemPurchased {  
        item: object::id(&item),  
        price: coin.value()  
    });  
  
    // Omitting the rest of the implementation to keep the example simple.  
    abort  
}
```

The Sui Verifier requires the type passed to the emit function to be *internal to the module*. So
emitting a type from another module will result in a compilation error. Primitive types, although
they match the *copy* and *drop* requirement, are not allowed to be emitted as events.

## Event Structure[​](#event-structure "Direct link to Event Structure")

Events are a part of the transaction result and are stored in the *transaction effects*. As such,
they natively have the sender field which is the address which sent the transaction. So adding a
"sender" field to the event is not necessary. Similarly, event metadata contains the timestamp. But
it is important to note that the timestamp is relative to the node and may vary a little from node
to node.

* [Emitting Events](#emitting-events)
* [Event Structure](#event-structure)
Pattern: Hot Potato | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Pattern: Hot Potato

A case in the abilities system - a struct without any abilities - is called *hot potato*. It cannot
be stored (not as [an object](/storage/key-ability) nor as
[a field in another struct](/storage/store-ability)), it cannot be
[copied](/move-basics/copy-ability) or [discarded](/move-basics/drop-ability). Hence, once
constructed, it must be gracefully [unpacked by its module](/move-basics/struct), or the
transaction will abort due to unused value without drop.

> If you're familiar with languages that support *callbacks*, you can think of a hot potato as an
> obligation to call a callback function. If you don't call it, the transaction will abort.

The name comes from the children's game where a ball is passed quickly between players, and none of
the players want to be the last one holding it when the music stops, or they are out of the game.
This is the best illustration of the pattern - the instance of a hot-potato struct is passed between
calls, and none of the modules can keep it.

## Defining a Hot Potato[​](#defining-a-hot-potato "Direct link to Defining a Hot Potato")

A hot potato can be any struct with no abilities. For example, the following struct is a hot potato:

```move
public struct Request {}
```

Because the Request has no abilities and cannot be stored or ignored, the module must provide a
function to unpack it. For example:

```move
/// Constructs a new `Request`  
public fun new_request(): Request { Request {} }  
  
/// Unpacks the `Request`. Due to the nature of the hot potato, this function  
/// must be called to avoid aborting the transaction.  
public fun confirm_request(request: Request) {  
    let Request {} = request;  
}
```

## Example Usage[​](#example-usage "Direct link to Example Usage")

In the following example, the Promise hot potato is used to ensure that the borrowed value, when
taken from the container, is returned back to it. The Promise struct contains the ID of the
borrowed object, and the ID of the container, ensuring that the borrowed value was not swapped for
another and is returned to the correct container.

```move
/// Trying to return value to incorrect container.  
const ENotCorrectContainer: u64 = 0;  
/// Trying to return incorrect value.  
const ENotCorrectValue: u64 = 1;  
  
/// A generic container for any Object with `key + store`. The Option type  
/// is used to allow taking and putting the value back.  
public struct Container<T: key + store> has key {  
    id: UID,  
    value: Option<T>,  
}  
  
/// A Hot Potato struct that is used to ensure the borrowed value is returned.  
public struct Promise {  
    /// The ID of the borrowed object. Ensures that there wasn't a value swap.  
    id: ID,  
    /// The ID of the container. Ensures that the borrowed value is returned to  
    /// the correct container.  
    container_id: ID,  
}  
  
/// A function that allows borrowing the value from the container.  
public fun borrow_val<T: key + store>(container: &mut Container<T>): (T, Promise) {  
    let value = container.value.extract();  
    let id = object::id(&value);  
    (value, Promise { id, container_id: object::id(container) })  
}  
  
/// Put the taken item back into the container.  
public fun return_val<T: key + store>(  
    container: &mut Container<T>, value: T, promise: Promise  
) {  
    let Promise { id, container_id } = promise;  
    assert!(object::id(container) == container_id, ENotCorrectContainer);  
    assert!(object::id(&value) == id, ENotCorrectValue);  
    container.value.fill(value);  
}
```

## Applications[​](#applications "Direct link to Applications")

Below we list some of the common use cases for the hot potato pattern.

### Borrowing[​](#borrowing "Direct link to Borrowing")

As shown in the [example above](#example-usage), the hot potato is very effective for borrowing with
a guarantee that the borrowed value is returned to the correct container. While the example focuses
on a value stored inside an Option, the same pattern can be applied to any other storage type, say
a [dynamic field](/programmability/dynamic-fields).

### Flash Loans[​](#flash-loans "Direct link to Flash Loans")

Canonical example of the hot potato pattern is flash loans. A flash loan is a loan that is borrowed
and repaid in the same transaction. The borrowed funds are used to perform some operations, and the
repaid funds are returned to the lender. The hot potato pattern ensures that the borrowed funds are
returned to the lender.

An example usage of this pattern may look like this:

```move
// Borrow the funds from the lender.  
let (asset_a, potato) = lender.borrow(amount);  
  
// Perform some operations with the borrowed funds.  
let asset_b = dex.trade(loan);  
let proceeds = another_contract::do_something(asset_b);  
  
// Keep the commission and return the rest to the lender.  
let pay_back = proceeds.split(amount, ctx);  
lender.repay(pay_back, potato);  
transfer::public_transfer(proceeds, ctx.sender());
```

### Variable-path Execution[​](#variable-path-execution "Direct link to Variable-path Execution")

The hot potato pattern can be used to introduce variation in the execution path. For example, if
there is a module which allows purchasing a Phone for some "Bonus Points" or for USD, the hot
potato can be used to decouple the purchase from the payment. The approach is very similar to how
some shops work - you take the item from the shelf, and then you go to the cashier to pay for it.

```move
/// Trying to purchase `Phone` with incorrect price of `BonusPoints` or `USD`.  
const ENotCorrectPrice: u64 = 0;  
  
/// A `Phone`. Can be purchased in a store.  
public struct Phone has key, store { id: UID }  
  
/// A ticket that must be paid to purchase the `Phone`.  
public struct Ticket { amount: u64 }  
  
/// Return the `Phone` and the `Ticket` that must be paid to purchase it.  
public fun purchase_phone(ctx: &mut TxContext): (Phone, Ticket) {  
    (  
        Phone { id: object::new(ctx) },  
        Ticket { amount: 100 }  
    )  
}  
  
/// The customer may pay for the `Phone` with `BonusPoints`.  
public fun pay_in_bonus_points(ticket: Ticket, payment: Coin<BONUS>) {  
    let Ticket { amount } = ticket;  
    assert!(payment.value() == amount, ENotCorrectPrice);  
    abort // omitting the rest of the function  
}  
  
/// The customer may pay for the `Phone` with `USD`.  
public fun pay_in_usd(ticket: Ticket, payment: Coin<USD>) {  
    let Ticket { amount } = ticket;  
    assert!(payment.value() == amount, ENotCorrectPrice);  
    abort // omitting the rest of the function  
}
```

This decoupling technique allows separating the purchase logic from the payment logic, making the
code more modular and easier to maintain. The Ticket could be split into its own module, providing
a basic interface for the payment, and the shop implementation could be extended to support other
goods without changing the payment logic.

### Compositional Patterns[​](#compositional-patterns "Direct link to Compositional Patterns")

Hot potato can be used to link together different modules in a compositional way. Its module may
define ways to interact with the hot potato, for example, stamp it with a type signature, or to
extract some information from it. This way, the hot potato can be passed between different modules,
and even different packages within the same transaction.

### Usage in the Sui Framework[​](#usage-in-the-sui-framework "Direct link to Usage in the Sui Framework")

The pattern is used in various forms in the Sui Framework. Here are some examples:

* [sui::borrow](https://docs.sui.io/references/framework/sui-framework/borrow) - uses hot potato to ensure that the borrowed value is returned to
  the correct container.
* [sui::transfer\_policy](https://docs.sui.io/references/framework/sui-framework/transfer_policy) - defines a TransferRequest - a hot potato
  which can only be consumed if all conditions are met.
* [sui::token](https://docs.sui.io/references/framework/sui-framework/token) - in the Closed Loop Token system, an ActionRequest carries the
  information about the performed action and collects approvals similarly to TransferRequest.

## Summary[​](#summary "Direct link to Summary")

* A hot potato is a struct without abilities, it must come with a way to create and destroy it.
* Hot potatoes are used to ensure that some action is taken before the transaction ends, similar to
  a callback.
* Most common use cases for hot potato are borrowing, flash loans, variable-path execution, and
  compositional patterns.

* [Defining a Hot Potato](#defining-a-hot-potato)
* [Example Usage](#example-usage)
* [Applications](#applications)
  + [Borrowing](#borrowing)
  + [Flash Loans](#flash-loans)
  + [Variable-path Execution](#variable-path-execution)
  + [Compositional Patterns](#compositional-patterns)
  + [Usage in the Sui Framework](#usage-in-the-sui-framework)
* [Summary](#summary)
Binary Canonical Serialization | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Binary Canonical Serialization

Binary Canonical Serialization (BCS) is a binary encoding format for structured data. It was
originally designed in Diem, and became the standard serialization format for Move. BCS is simple,
efficient, deterministic, and easy to implement in any programming language.

> The full format specification is available in the
> [BCS repository](https://github.com/zefchain/bcs).

## Format[​](#format "Direct link to Format")

BCS is a binary format that supports unsigned integers up to 256 bits, options, booleans, unit
(empty value), fixed and variable-length sequences, and maps. The format is designed to be
deterministic, meaning that the same data will always be serialized to the same bytes.

> "BCS is not a self-describing format. As such, in order to deserialize a message, one must know
> the message type and layout ahead of time" from the [README](https://github.com/zefchain/bcs)

Integers are stored in little-endian format, and variable-length integers are encoded using a
variable-length encoding scheme. Sequences are prefixed with their length as ULEB128, enumerations
are stored as the index of the variant followed by the data, and maps are stored as an ordered
sequence of key-value pairs.

Structs are treated as a sequence of fields, and the fields are serialized in the order they are
defined in the struct. The fields are serialized using the same rules as the top-level data.

## Using BCS[​](#using-bcs "Direct link to Using BCS")

The [Sui Framework](/programmability/sui-framework) includes the [sui::bcs](https://docs.sui.io/references/framework/sui_sui/bcs) module for encoding and
decoding data. Encoding functions are native to the VM, and decoding functions are implemented in
Move.

## Encoding[​](#encoding "Direct link to Encoding")

To encode data, use the bcs::to\_bytes function, which converts data references into byte vectors.
This function supports encoding any types, including structs.

```move
module std::bcs;  
  
public native fun to_bytes<T>(t: &T): vector<u8>;
```

The following example shows how to encode a struct using BCS. The to\_bytes function can take any
value and encode it as a vector of bytes.

```move
use sui::bcs;  
  
// 0x01 - a single byte with value 1 (or 0 for false)  
let bool_bytes = bcs::to_bytes(&true);  
assert_eq!(bool_bytes, x"01");  
  
// 0x2a - just a single byte  
let u8_bytes = bcs::to_bytes(&42u8);  
assert_eq!(u8_bytes, x"2A");  
  
// 0x2a00000000000000 - 8 bytes  
let u64_bytes = bcs::to_bytes(&42u64);  
assert_eq!(u64_bytes, x"2A00000000000000");  
  
// address is a fixed sequence of 32 bytes  
// 0x0000000000000000000000000000000000000000000000000000000000000002  
let addr = bcs::to_bytes(&@sui);  
assert_eq!(addr, x"0000000000000000000000000000000000000000000000000000000000000002");
```

### Encoding a Struct[​](#encoding-a-struct "Direct link to Encoding a Struct")

Structs encode similarly to simple types. Here is how to encode a struct using BCS:

```move
let data = CustomData {  
    num: 42,  
    string: b"hello, world!".to_string(),  
    value: true  
};  
  
let struct_bytes = bcs::to_bytes(&data);  
  
let mut custom_bytes = vector[];  
custom_bytes.append(bcs::to_bytes(&42u8));  
custom_bytes.append(bcs::to_bytes(&b"hello, world!".to_string()));  
custom_bytes.append(bcs::to_bytes(&true));  
  
// struct is just a sequence of fields, so the bytes should be the same!  
assert_eq!(struct_bytes, custom_bytes);
```

## Decoding[​](#decoding "Direct link to Decoding")

Because BCS is not a self-describing format, decoding requires prior knowledge of the data type. The
[sui::bcs](https://docs.sui.io/references/framework/sui_sui/bcs) module provides various functions to assist with this process.

### Wrapper API[​](#wrapper-api "Direct link to Wrapper API")

BCS is implemented as a wrapper in Move. The decoder takes the bytes by value, and then allows the
caller to *peel off* the data by calling different decoding functions, prefixed with peel\_\*. The
data is extracted from the bytes, and the remaining bytes are kept in the wrapper until the
into\_remainder\_bytes function is called.

```move
use sui::bcs;  
  
// BCS instance should always be declared as mutable  
let mut bcs = bcs::new(x"010000000000000000");  
  
// Same bytes can be read differently, for example: Option<u64>  
let value: Option<u64> = bcs.peel_option_u64();  
  
assert_eq!(value.is_some(), true);  
assert_eq!(*value.borrow(), 0);  
  
let remainder = bcs.into_remainder_bytes();  
  
assert_eq!(remainder.length(), 0);
```

There is a common practice to use multiple variables in a single let statement during decoding. It
makes code a little bit more readable and helps to avoid unnecessary copying of the data.

```move
let mut bcs = bcs::new(x"0101010F0000000000F00000000000");  
  
// mind the order!!!  
// handy way to peel multiple values  
let (bool_value, u8_value, u64_value) = (  
    bcs.peel_bool(),  
    bcs.peel_u8(),  
    bcs.peel_u64()  
);
```

### Decoding Vectors[​](#decoding-vectors "Direct link to Decoding Vectors")

While most of the primitive types have a dedicated decoding function, vectors need special handling,
which depends on the type of the elements. For vectors, first you need to decode the length of the
vector, and then decode each element in a loop.

```move
let mut bcs = bcs::new(x"0101010F0000000000F00000000000");  
  
// bcs.peel_vec_length() peels the length of the vector :)  
let mut len = bcs.peel_vec_length();  
let mut vec = vector[];  
  
// then iterate depending on the data type  
while (len > 0) {  
    vec.push_back(bcs.peel_u64()); // or any other type  
    len = len - 1;  
};  
  
assert_eq!(vec.length(), 1);  
  
// The above `while` can be simplified and made more readable using a `macro`.  
// bcs.peel_vec!(|bcs| bcs.peel_u64()) is equivalent to the above `while` loop.
```

This functionality is provided by the library as a macro peel\_vec!. It calls the inner expression
as many times as the vector length and aggregates the result into a single vector.

```move
let u64_vec = bcs.peel_vec!(|bcs| bcs.peel_u64());  
let address_vec = bcs.peel_vec!(|bcs| bcs.peel_address());  
  
// Caution: this is only possible if `MyStruct` is defined in the current module!  
let my_struct = bcs.peel_vec!(|bcs| MyStruct {  
    user_addr: bcs.peel_address(),  
    age: bcs.peel_u8(),  
});
```

### Decoding Option[​](#decoding-option "Direct link to Decoding Option")

[Option](/move-basics/option) in Move is represented as a vector of either 0 or 1 element. To
read an option, you would treat it like a vector and check its length (first byte - either 1 or 0).

```move
let mut bcs = bcs::new(x"00");  
let is_some = bcs.peel_bool();  
  
assert_eq!(is_some, false);  
  
let mut bcs = bcs::new(x"0101");  
let is_some = bcs.peel_bool();  
let value = bcs.peel_u8();  
  
assert_eq!(is_some, true);  
assert_eq!(value, 1);
```

Like with [vector](#decoding-vectors), there is a wrapper macro peel\_option! which checks the
variant index and evaluates the expression if the underlying value is *some*.

```move
let u8_opt = bcs.peel_option!(|bcs| bcs.peel_u8());  
let bool_opt = bcs.peel_option!(|bcs| bcs.peel_bool());
```

### Decoding Structs[​](#decoding-structs "Direct link to Decoding Structs")

Structs are decoded field by field, and there is no way to automatically decode bytes into a Move
struct. To parse bytes into a struct, you need to decode each field and instantiate the type.

```move
let mut bcs = bcs::new(x"0101010F0000000000F00000000000");  
  
// Note: order matters!  
let user = User {  
    age: bcs.peel_u8(),  
    is_active: bcs.peel_bool(),  
    name: bcs.peel_vec_u8().to_string()  
};
```

## Summary[​](#summary "Direct link to Summary")

Binary Canonical Serialization is an efficient binary format for structured data, ensuring
consistent serialization across platforms. The Sui Framework provides comprehensive tools for
working with BCS, allowing extensive functionality through built-in functions.

* [Format](#format)
* [Using BCS](#using-bcs)
* [Encoding](#encoding)
  + [Encoding a Struct](#encoding-a-struct)
* [Decoding](#decoding)
  + [Wrapper API](#wrapper-api)
  + [Decoding Vectors](#decoding-vectors)
  + [Decoding Option](#decoding-option)
  + [Decoding Structs](#decoding-structs)
* [Summary](#summary)
Advanced Move Usage | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Advanced Move Usage

This chapter covers advanced features of the Move language, including various extended behaviors for
advanced programming. This includes advanced usage of the language itself, plus the package and
build system.
Modes | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Modes

Modes let you include **unpublishable** code only when you explicitly opt into a named build mode.
Think of them as generalizations of the #[test\_only] [test annotation](/move-basics/testing) for
any purpose you choose (e.g. debug, benchmark, spec, or any other feature).

Modes at a glance:

* Annotate items with #[mode(name, ...)] or use the shorthand #[test\_only] for the built-in
  test mode.
  + The #[test\_only] attribute is syntactic sugar for #[mode(test)].
* Build with --mode <name> (or --test for unit testing). Items whose mode list contains a name
  you enabled are compiled in. Items whose mode list does **not** match are compiled **out**.
* Code compiled with any mode enabled is **not publishable**. This keeps debug/test scaffolding from
  ever making it on-chain.
* Items with **no** #[mode(...)]/#[test\_only] annotation are always included.

> Tip: Modes are filters enforced at compile-time—they don’t affect bytecode at runtime. Use them
> for helpers, simulators, and other mock types and functions that should never be published.

## Syntax[​](#syntax "Direct link to Syntax")

Like #[test\_only], You can attach a mode attribute to modules and to individual members:

```move
// Entire module is included only when a matching mode is enabled  
#[mode(debug)]  
module my_pkg::debug_tools {  
    public fun dump_state() { /* ... */ }  
}  
  
module my_pkg::library {  
    // This function exists only in `debug` or `test` builds  
    #[mode(debug, test)]  
    public fun assert_invariants() { /* ... */ }  
  
    // Test-only helper; equivalent to #[mode(test)]  
    #[test_only]  
    fun mk_fake() { /* ... */ }  
}
```

As we can see here, multiple modes can be listed in a single attribute: #[mode(name1,name2,...)].
This item will be included during compilation if **any** of the listed names is enabled. In
addition, any definition without a mode annotation is always included.

> Tip: The annotation #[mode(test)] is equivalent to #[test\_only].

## Building with modes[​](#building-with-modes "Direct link to Building with modes")

Use the Sui CLI to opt into a mode when building or testing:

```move
# Build with a custom mode enabled  
sui move build --mode debug  
  
# Run tests; includes #[test_only] automatically  
sui move test --test  
  
# Combine: run unit tests with extra debug helpers  
sui move test --test --mode debug
```

Items annotated with a mode you enabled are compiled **in**; items annotated with a different,
non-enabled mode are compiled **out**. Unannotated items are always compiled in.

> **Publish safety**: Any artifact produced while a mode is enabled (including --test) is non-publishable. Always run a clean build **without** --mode/--test before sui client publish.

### Example — test mode (unit tests)[​](#example--test-mode-unit-tests "Direct link to example--test-mode-unit-tests")

#[test\_only] is the built-in mode for unit testing. It works exactly like a mode named test.

```move
#[mode(test)]  
module my_pkg::math_tests {  
    use my_pkg::math;  
  
    #[modetest]  
    fun add_basic() { /* ... */ }  
  
    // Private test helper  
    fun mk_case() { /* ... */ }  
}
```

To build and run:

```move
# Includes modules and members marked #[test_only]  
sui move test --test
```

As described in the [testing](/move-basics/testing) documentation, this is a great way to
keep test helpers and test-only public functions out of published packages.

### Example 2: Debug testing[​](#example-2-debug-testing "Direct link to Example 2: Debug testing")

Suppose you have a bank module with a transfer function. You want to add debug logging in test
runs where you can see internal state, but you only want to run that test with those logs during
development (e.g., not during CI, etc). You can use a debug mode for this.

```move
module my_pkg::bank {  
    use std::error;  
  
    public fun transfer(from: &signer, to: address, amount: u64) {  
        // ... production logic ...  
    }  
}  
  
// Debug-only wrappers & helpers  
#[mode(debug)]  
module my_pkg::bank_debug {  
    use std::debug;  
    use my_pkg::bank;  
  
    public fun transfer_debug(from: &signer, to: address, amount: u64) {  
        // Perform debugging prints before the real call  
        debug::print(&b"[DEBUG] transfer begin".to_vector());  
        debug::print(&amount);  
        debug::print(&to);  
        // Main Call  
        bank::transfer(from, to, amount);  
        // More debugging prints  
        debug::print(&b"[DEBUG] transfer end".to_vector());  
    }  
}
```

Here, bank::transfer is the **only** production entry point, with not printing. The
#[mode(debug)] exposes bank\_debug::{transfer\_debug, dump\_account, ...}, however, which will
**only** be included in debug-mode builds. Now, we can write tests that use this extra visibility
without affecting production code or other tests:

```move
#[test_only]  
module my_pkg::bank_tests {  
    use my_pkg::bank;  
  
    // Runs in all builds (no mode needed)  
    #[test]  
    fun transfer_basic() {  
        // create signers, call bank::transfer(...)  
    }  
  
    // Runs only with `--test --mode debug`  
    #[mode(debug)]  
    #[test]  
    fun transfer_with_logs() {  
        use my_pkg::bank_debug; // only exists in debug builds  
        // create signers, then:  
        bank_debug::transfer_debug(&signer, @bob, 100);  
        // assertions same as normal test; plus you see prints  
    }  
}
```

Now we can execute this test with extra logging by enabling the debug mode:

```move
# Standard tests (no debug helpers compiled in)  
sui move test  
  
# Debug tests with extra logging  
sui move test --mode debug
```

This allows us to produce production bytecode, continuous integration tests, and debug logging
tests, each at different times, without code duplication or complex branching.

## Publication[​](#publication "Direct link to Publication")

Code built with any mode enabled is non-publishable. Always do a clean build without --mode or
--test before publishing:

```move
sui move build   # no --mode, no --test
```

## See also[​](#see-also "Direct link to See also")

* [Testing basics](/move-basics/testing) in the Move Book.
* [Modes](/reference/modes) in the Move Reference.

* [Syntax](#syntax)
* [Building with modes](#building-with-modes)
  + [Example — `test` mode (unit tests)](#example--test-mode-unit-tests)
  + [Example 2: Debug testing](#example-2-debug-testing)
* [Publication](#publication)
* [See also](#see-also)
Move 2024 Migration Guide | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Move 2024 Migration Guide

Move 2024 is the new edition of the Move language that is maintained by Mysten Labs. This guide is
intended to help you understand the differences between the 2024 edition and the previous version of
the Move language.

> This guide provides a high-level overview of the changes in the new edition. For a more detailed
> and exhaustive list of changes, refer to the
> [Sui Documentation](https://docs.sui.io/guides/developer/advanced/move-2024-migration).

## Using the New Edition[​](#using-the-new-edition "Direct link to Using the New Edition")

To use the new edition, you need to specify the edition in the move file. The edition is specified
in the move file using the edition keyword. Currently, the only available edition is
2024.beta.

```move
edition = "2024"  
# alternatively, for new features:  
edition = "2024.beta"
```

## Migration Tool[​](#migration-tool "Direct link to Migration Tool")

The Move CLI has a migration tool that updates the code to the new edition. To use the migration
tool, run the following command:

```move
$ sui move migrate
```

The migration tool will update the code to use the let mut syntax, the new public modifier for
structs, and the public(package) function visibility instead of friend declarations.

## Mutable Bindings with let mut[​](#mutable-bindings-with-let-mut "Direct link to mutable-bindings-with-let-mut")

Move 2024 introduces let mut syntax to declare mutable variables. The let mut syntax is used to
declare a mutable variable that can be changed after it is declared.

> let mut declaration is now required for mutable variables. Compiler will emit an error if you
> try to reassign a variable without the mut keyword.

```move
// Move 2020  
let x: u64 = 10;  
x = 20;  
  
// Move 2024  
let mut x: u64 = 10;  
x = 20;
```

Additionally, the mut keyword is used in tuple destructuring and function arguments to declare
mutable variables.

```move
// takes by value and mutates  
fun takes_by_value_and_mutates(mut v: Value): Value {  
    v.field = 10;  
    v  
}  
  
// `mut` should be placed before the variable name  
fun destruct() {  
    let (x, y) = point::get_point();  
    let (mut x, y) = point::get_point();  
    let (mut x, mut y) = point::get_point();  
}  
  
// in struct unpack  
fun unpack() {  
    let Point { x, mut y } = point::get_point();  
    let Point { mut x, mut y } = point::get_point();  
}
```

## Friends are Deprecated[​](#friends-are-deprecated "Direct link to Friends are Deprecated")

In Move 2024, the friend keyword is deprecated. Instead, you can use the public(package)
visibility modifier to make functions visible to other modules in the same package.

```move
// Move 2020  
friend book::friend_module;  
public(friend) fun protected_function() {}  
  
// Move 2024  
public(package) fun protected_function_2024() {}
```

## Struct Visibility[​](#struct-visibility "Direct link to Struct Visibility")

In Move 2024, structs get a visibility modifier. Currently, the only available visibility modifier
is public.

```move
// Move 2020  
struct Book {}  
  
// Move 2024  
public struct Book {}
```

## Method Syntax[​](#method-syntax "Direct link to Method Syntax")

In the new edition, functions which have a struct as the first argument are associated with the
struct. This means that the function can be called using the dot notation. Methods defined in the
same module with the type are automatically exported.

> Methods are automatically exported if the type is defined in the same module as the method. It is
> impossible to export methods for types defined in other modules. However, you can create
> [custom aliases](#method-aliases) for methods in the module scope.

```move
public fun count(c: &Counter): u64 { /* ... */ }  
  
fun use_counter() {  
    // move 2020  
    let count = counter::count(&c);  
  
    // move 2024  
    let count = c.count();  
}
```

## Methods for Built-in Types[​](#methods-for-built-in-types "Direct link to Methods for Built-in Types")

In Move 2024, some of the native and standard types received associated methods. For example, the
vector type has a to\_string method that converts the vector into a UTF8 string.

```move
fun aliases() {  
    // vector to string and ascii string  
    let str: String = b"Hello, World!".to_string();  
    let ascii: ascii::String = b"Hello, World!".to_ascii_string();  
  
    // address to bytes  
    let bytes = @0xa11ce.to_bytes();  
}
```

For the full list of built-in aliases, refer to the
[Standard Library](/move-basics/standard-library#source-code) and
[Sui Framework](/programmability/sui-framework#source-code) source code.

## Borrowing Operator[​](#borrowing-operator "Direct link to Borrowing Operator")

Some of the built-in types support borrowing operators. The borrowing operator is used to get a
reference to the element at the specified index. The borrowing operator is defined as [].

```move
fun play_vec() {  
    let v = vector[1,2,3,4];  
    let first = &v[0];         // calls vector::borrow(v, 0)  
    let first_mut = &mut v[0]; // calls vector::borrow_mut(v, 0)  
    let first_copy = v[0];     // calls *vector::borrow(v, 0)  
}
```

Types that support the borrowing operator are:

* vector
* sui::vec\_map::VecMap
* sui::table::Table
* sui::bag::Bag
* sui::object\_table::ObjectTable
* sui::object\_bag::ObjectBag
* sui::linked\_table::LinkedTable

To implement the borrowing operator for a custom type, you need to add a #[syntax(index)]
attribute to the methods.

```move
#[syntax(index)]  
public fun borrow(c: &List<T>, key: String): &T { /* ... */ }  
  
#[syntax(index)]  
public fun borrow_mut(c: &mut List<T>, key: String): &mut T { /* ... */ }
```

## Method Aliases[​](#method-aliases "Direct link to Method Aliases")

In Move 2024, methods can be associated with types. The alias can be defined for any type locally to
the module; or publicly, if the type is defined in the same module.

```move
// my_module.move  
// Local: type is foreign to the module  
use fun my_custom_function as vector.do_magic;  
  
// sui-framework/kiosk/kiosk.move  
// Exported: type is defined in the same module  
public use fun kiosk_owner_cap_for as KioskOwnerCap.kiosk;
```

* [Using the New Edition](#using-the-new-edition)
* [Migration Tool](#migration-tool)
* [Mutable Bindings with `let mut`](#mutable-bindings-with-let-mut)
* [Friends are Deprecated](#friends-are-deprecated)
* [Struct Visibility](#struct-visibility)
* [Method Syntax](#method-syntax)
* [Methods for Built-in Types](#methods-for-built-in-types)
* [Borrowing Operator](#borrowing-operator)
* [Method Aliases](#method-aliases)
Upgradeability Practices | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Upgradeability Practices

To talk about best practices for upgradeability, we need to first understand what can be upgraded in
a package. The base premise of upgradeability is that an upgrade should not break public
compatibility with the previous version. The parts of the module which can be used in dependent
packages should not change their static signature. This applies to modules - a module can not be
removed from a package, public structs - they can be used in function signatures and public
functions - they can be called from other packages.

```move
// module can not be removed from the package  
module book::upgradable;  
  
// dependencies can be changed (if they are not used in public signatures)  
use std::string::String;  
use sui::event; // can be removed  
  
// public structs can not be removed and can't be changed  
public struct Book has key {  
    id: UID,  
    title: String,  
}  
  
// public structs can not be removed and can't be changed  
public struct BookCreated has copy, drop {  
    /* ... */  
}  
  
// public functions can not be removed and their signature can never change  
// but the implementation can be changed  
public fun create_book(ctx: &mut TxContext): Book {  
    create_book_internal(ctx)  
  
    // can be removed and changed  
    event::emit(BookCreated {  
        /* ... */  
    })  
}  
  
// package-visibility functions can be removed and changed  
public(package) fun create_book_package(ctx: &mut TxContext): Book {  
    create_book_internal(ctx)  
}  
  
// entry functions can be removed and changed as long as they're not public  
entry fun create_book_entry(ctx: &mut TxContext): Book {  
    create_book_internal(ctx)  
}  
  
// private functions can be removed and changed  
fun create_book_internal(ctx: &mut TxContext): Book {  
    abort  
}
```

## Versioning objects[​](#versioning-objects "Direct link to Versioning objects")

To discard previous versions of the package, the objects can be versioned. As long as the object
contains a version field, and the code which uses the object expects and asserts a specific version,
the code can be force-migrated to the new version. Normally, after an upgrade, admin functions can
be used to update the version of the shared state, so that the new version of code can be used, and
the old version aborts with a version mismatch.

```move
module book::versioned_state;  
  
const EVersionMismatch: u64 = 0;  
  
const VERSION: u8 = 1;  
  
/// The shared state (can be owned too)  
public struct SharedState has key {  
    id: UID,  
    version: u8,  
    /* ... */  
}  
  
public fun mutate(state: &mut SharedState) {  
    assert!(state.version == VERSION, EVersionMismatch);  
    // ...  
}
```

## Versioning configuration with dynamic fields[​](#versioning-configuration-with-dynamic-fields "Direct link to Versioning configuration with dynamic fields")

There's a common pattern in Sui which allows changing the stored configuration of an object while
retaining the same object signature. This is done by keeping the base object simple and versioned
and adding an actual configuration object as a dynamic field. Using this *anchor* pattern, the
configuration can be changed with package upgrades while keeping the same base object signature.

```move
module book::versioned_config;  
  
use sui::vec_map::VecMap;  
use std::string::String;  
  
/// The base object  
public struct Config has key {  
    id: UID,  
    version: u16  
}  
  
/// The actual configuration  
public struct ConfigV1 has store {  
    data: Bag,  
    metadata: VecMap<String, String>  
}  
  
// ...
```

* [Versioning objects](#versioning-objects)
* [Versioning configuration with dynamic fields](#versioning-configuration-with-dynamic-fields)
Building Against Limits | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Building Against Limits

To guarantee the safety and security of the network, Sui has certain limits and restrictions. These
limits are in place to prevent abuse and to ensure that the network remains stable and efficient.
This guide provides an overview of these limits and restrictions, and how to build your application
to work within them.

The limits are defined in the protocol configuration and are enforced by the network. If any of the
limits are exceeded, the transaction will either be rejected or aborted. The limits, being a part of
the protocol, can only be changed through a network upgrade.

## Transaction Size[​](#transaction-size "Direct link to Transaction Size")

The size of a transaction is limited to 128KB. This includes the size of the transaction payload,
the size of the transaction signature, and the size of the transaction metadata. If a transaction
exceeds this limit, it will be rejected by the network.

## Object Size[​](#object-size "Direct link to Object Size")

The size of an object is limited to 256KB. This includes the size of the object data. If an object
exceeds this limit, it will be rejected by the network. While a single object cannot bypass this
limit, for more extensive storage options, one could use a combination of a base object with other
attached to it using dynamic fields (eg Bag).

## Single Pure Argument Size[​](#single-pure-argument-size "Direct link to Single Pure Argument Size")

The size of a single pure argument is limited to 16KB. A transaction argument bigger than this limit
will result in execution failure. So in order to create a vector of more than ~500 addresses (given
that a single address is 32 bytes), it needs to be joined dynamically either in Transaction Block or
in a Move function. Standard functions like vector::append() can join two vectors of ~16KB
resulting in a ~32KB of data as a single value.

## Maximum Number of Objects (and Dynamic Fields) Created[​](#maximum-number-of-objects-and-dynamic-fields-created "Direct link to Maximum Number of Objects (and Dynamic Fields) Created")

The maximum number of objects that can be created in a single transaction is 2048. If a transaction
attempts to create more than 2048 objects, it will be rejected by the network. This also affects
[dynamic fields](/programmability/dynamic-fields), as both the key and the value are objects.
So the maximum number of [dynamic fields](/programmability/dynamic-fields) that can be
created in a single transaction is 1000. The limitation applies to dynamic object fields as well.

## Maximum Number of Dynamic Fields Accessed[​](#maximum-number-of-dynamic-fields-accessed "Direct link to Maximum Number of Dynamic Fields Accessed")

The maximum number of dynamic fields that can be accessed in a single transaction is 1000. If a
transaction attempts to access more than 1000 dynamic fields, it will be rejected by the network.

## Maximum Number of Events[​](#maximum-number-of-events "Direct link to Maximum Number of Events")

The maximum number of events that can be emitted in a single transaction is 1024. If a transaction
attempts to emit more than 1024 events, it will be aborted.

* [Transaction Size](#transaction-size)
* [Object Size](#object-size)
* [Single Pure Argument Size](#single-pure-argument-size)
* [Maximum Number of Objects (and Dynamic Fields) Created](#maximum-number-of-objects-and-dynamic-fields-created)
* [Maximum Number of Dynamic Fields Accessed](#maximum-number-of-dynamic-fields-accessed)
* [Maximum Number of Events](#maximum-number-of-events)
Better Error Handling | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Better Error Handling

Whenever execution encounters an abort, transaction fails and abort code is returned to the caller.
Move VM returns the module name that aborted the transaction and the abort code. This behavior is
not fully transparent to the caller of the transaction, especially when a single function contains
multiple calls to the same function which may abort. In this case, the caller will not know which
call aborted the transaction, and it will be hard to debug the issue or provide meaningful error
message to the user.

```move
module book::module_a;  
  
use book::module_b;  
  
public fun do_something() {  
    let field_1 = module_b::get_field(1); // may abort with 0  
    /* ... a lot of logic ... */  
    let field_2 = module_b::get_field(2); // may abort with 0  
    /* ... some more logic ... */  
    let field_3 = module_b::get_field(3); // may abort with 0  
}
```

The example above illustrates the case when a single function contains multiple calls which may
abort. If the caller of the do\_something function receives an abort code 0, it will be hard to
understand which call to module\_b::get\_field aborted the transaction. To address this problem,
there are common patterns that can be used to improve error handling.

## Rule 1: Handle All Possible Scenarios[​](#rule-1-handle-all-possible-scenarios "Direct link to Rule 1: Handle All Possible Scenarios")

It is considered a good practice to provide a safe "check" function that returns a boolean value
indicating whether an operation can be performed safely. If the module\_b provides a function
has\_field that returns a boolean value indicating whether a field exists, the do\_something
function can be rewritten as follows:

```move
module book::module_a;  
  
use book::module_b;  
  
const ENoField: u64 = 0;  
  
public fun do_something() {  
    assert!(module_b::has_field(1), ENoField);  
    let field_1 = module_b::get_field(1);  
    /* ... */  
    assert!(module_b::has_field(2), ENoField);  
    let field_2 = module_b::get_field(2);  
    /* ... */  
    assert!(module_b::has_field(3), ENoField);  
    let field_3 = module_b::get_field(3);  
}
```

By adding custom checks before each call to module\_b::get\_field, the developer of the module\_a
takes control over the error handling. And it allows implementing the second rule.

## Rule 2: Abort with Different Codes[​](#rule-2-abort-with-different-codes "Direct link to Rule 2: Abort with Different Codes")

The second trick, once the abort codes are handled by the caller module, is to use different abort
codes for different scenarios. This way, the caller module can provide a meaningful error message to
the user. The module\_a can be rewritten as follows:

```move
module book::module_a;  
  
use book::module_b;  
  
const ENoFieldA: u64 = 0;  
const ENoFieldB: u64 = 1;  
const ENoFieldC: u64 = 2;  
  
public fun do_something() {  
    assert!(module_b::has_field(1), ENoFieldA);  
    let field_1 = module_b::get_field(1);  
    /* ... */  
    assert!(module_b::has_field(2), ENoFieldB);  
    let field_2 = module_b::get_field(2);  
    /* ... */  
    assert!(module_b::has_field(3), ENoFieldC);  
    let field_3 = module_b::get_field(3);  
}
```

Now, the caller module can provide a meaningful error message to the user. If the caller receives an
abort code 0, it can be translated to "Field 1 does not exist". If the caller receives an abort
code 1, it can be translated to "Field 2 does not exist". And so on.

## Rule 3: Return bool Instead of assert[​](#rule-3-return-bool-instead-of-assert "Direct link to rule-3-return-bool-instead-of-assert")

A developer is often tempted to add a public function that would assert all the conditions and abort
the execution. However, it is a better practice to create a function that returns a boolean value
instead. This way, the caller module can handle the error and provide a meaningful error message to
the user.

```move
module book::some_app_assert;  
  
const ENotAuthorized: u64 = 0;  
  
public fun do_a() {  
    assert_is_authorized();  
    // ...  
}  
  
public fun do_b() {  
    assert_is_authorized();  
    // ...  
}  
  
/// Don't do this  
public fun assert_is_authorized() {  
    assert!(/* some condition */ true, ENotAuthorized);  
}
```

This module can be rewritten as follows:

```move
module book::some_app;  
  
const ENotAuthorized: u64 = 0;  
  
public fun do_a() {  
    assert!(is_authorized(), ENotAuthorized);  
    // ...  
}  
  
public fun do_b() {  
    assert!(is_authorized(), ENotAuthorized);  
    // ...  
}  
  
public fun is_authorized(): bool {  
    /* some condition */ true  
}  
  
// a private function can still be used to avoid code duplication for a case  
// when the same condition with the same abort code is used in multiple places  
fun assert_is_authorized() {  
    assert!(is_authorized(), ENotAuthorized);  
}
```

Utilizing these three rules will make the error handling more transparent to the caller of the
transaction, and it will allow other developers to use custom abort codes in their modules.

* [Rule 1: Handle All Possible Scenarios](#rule-1-handle-all-possible-scenarios)
* [Rule 2: Abort with Different Codes](#rule-2-abort-with-different-codes)
* [Rule 3: Return `bool` Instead of `assert`](#rule-3-return-bool-instead-of-assert)
Code Quality Checklist | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Code Quality Checklist

The rapid evolution of the Move language and its ecosystem has rendered many older practices
outdated. This guide serves as a checklist for developers to review their code and ensure it aligns
with current best practices in Move development. Please read carefully and apply as many
recommendations as possible to your code.

## Code Organization[​](#code-organization "Direct link to Code Organization")

Some of the issues mentioned in this guide can be fixed by using
[Move Formatter](https://www.npmjs.com/package/@mysten/prettier-plugin-move) either as a CLI tool,
or [as a CI check](https://github.com/marketplace/actions/move-formatter), or
[as a plugin for VSCode (Cursor)](https://marketplace.visualstudio.com/items?itemName=mysten.prettier-move).

## Package Manifest[​](#package-manifest "Direct link to Package Manifest")

### Use Right Edition[​](#use-right-edition "Direct link to Use Right Edition")

All of the features in this guide require Move 2024 Edition, and it has to be specified in the
package manifest.

```move
[package]  
name = "my_package"  
edition = "2024.beta" # or (just) "2024"
```

### Implicit Framework Dependency[​](#implicit-framework-dependency "Direct link to Implicit Framework Dependency")

Starting with Sui 1.45 you no longer need to specify framework dependency in the Move.toml:

```move
# old, pre 1.45  
[dependencies]  
Sui = { ... }  
  
# modern day, Sui, Bridge, MoveStdlib and SuiSystem are imported implicitly!  
[dependencies]
```

### Prefix Named Addresses[​](#prefix-named-addresses "Direct link to Prefix Named Addresses")

If your package has a generic name (e.g., token) – especially if your project includes multiple
packages – make sure to add a prefix to the named address:

```move
# bad! not indicative of anything, and can conflict  
[addresses]  
math = "0x0"  
  
# good! clearly states project, unlikely to conflict  
[addresses]  
my_protocol_math = "0x0"
```

## Imports, Module and Constants[​](#imports-module-and-constants "Direct link to Imports, Module and Constants")

### Using Module Label[​](#using-module-label "Direct link to Using Module Label")

```move
// bad: increases indentation, legacy style  
module my_package::my_module {  
    public struct A {}  
}  
  
// good!  
module my_package::my_module;  
  
public struct A {}
```

### No Single Self in use Statements[​](#no-single-self-in-use-statements "Direct link to no-single-self-in-use-statements")

```move
// correct, member + self import  
use my_package::other::{Self, OtherMember};  
  
// bad! `{Self}` is redundant  
use my_package::my_module::{Self};  
  
// good!  
use my_package::my_module;
```

### Group use Statements with Self[​](#group-use-statements-with-self "Direct link to group-use-statements-with-self")

```move
// bad!  
use my_package::my_module;  
use my_package::my_module::OtherMember;  
  
// good!  
use my_package::my_module::{Self, OtherMember};
```

### Error Constants are in EPascalCase[​](#error-constants-are-in-epascalcase "Direct link to error-constants-are-in-epascalcase")

```move
// bad! all-caps are used for regular constants  
const NOT_AUTHORIZED: u64 = 0;  
  
// good! clear indication it's an error constant  
const ENotAuthorized: u64 = 0;
```

### Regular Constant are ALL\_CAPS[​](#regular-constant-are-all_caps "Direct link to regular-constant-are-all_caps")

```move
// bad! PascalCase is associated with error consts  
const MyConstant: vector<u8> = b"my const";  
  
// good! clear indication that it's a constant value  
const MY_CONSTANT: vector<u8> = b"my const";
```

## Structs[​](#structs "Direct link to Structs")

### Capabilities are Suffixed with Cap[​](#capabilities-are-suffixed-with-cap "Direct link to capabilities-are-suffixed-with-cap")

```move
// bad! if it's a capability, add a `Cap` suffix  
public struct Admin has key, store {  
    id: UID,  
}  
  
// good! reviewer knows what to expect from type  
public struct AdminCap has key, store {  
    id: UID,  
}
```

### No Potato in Names[​](#no-potato-in-names "Direct link to no-potato-in-names")

```move
// bad! it has no abilities, we already know it's a Hot-Potato type  
public struct PromisePotato {}  
  
// good!  
public struct Promise {}
```

### Events Should Be Named in Past Tense[​](#events-should-be-named-in-past-tense "Direct link to Events Should Be Named in Past Tense")

```move
// bad! not clear what this struct does  
public struct RegisterUser has copy, drop { user: address }  
  
// good! clear, it's an event  
public struct UserRegistered has copy, drop { user: address }
```

### Use Positional Structs for Dynamic Field Keys + Key Suffix[​](#use-positional-structs-for-dynamic-field-keys--key-suffix "Direct link to use-positional-structs-for-dynamic-field-keys--key-suffix")

```move
// not as bad, but goes against canonical style  
public struct DynamicField has copy, drop, store {}  
  
// good! canonical style, Key suffix  
public struct DynamicFieldKey() has copy, drop, store;
```

## Functions[​](#functions "Direct link to Functions")

### No public entry, Only public or entry[​](#no-public-entry-only-public-or-entry "Direct link to no-public-entry-only-public-or-entry")

```move
// bad! entry is not required for a function to be callable in a transaction  
public entry fun do_something() { /* ... */ }  
  
// good! public functions are more permissive, can return value  
public fun do_something_2(): T { /* ... */ }
```

### Write Composable Functions for PTBs[​](#write-composable-functions-for-ptbs "Direct link to Write Composable Functions for PTBs")

```move
// bad! not composable, harder to test!  
public fun mint_and_transfer(ctx: &mut TxContext) {  
    /* ... */  
    transfer::transfer(nft, ctx.sender());  
}  
  
// good! composable!  
public fun mint(ctx: &mut TxContext): NFT { /* ... */ }  
  
// good! intentionally not composable  
entry fun mint_and_keep(ctx: &mut TxContext) { /* ... */ }
```

### Objects Go First (Except for Clock)[​](#objects-go-first-except-for-clock "Direct link to Objects Go First (Except for Clock)")

```move
// bad! hard to read!  
public fun call_app(  
    value: u8,  
    app: &mut App,  
    is_smth: bool,  
    cap: &AppCap,  
    clock: &Clock,  
    ctx: &mut TxContext,  
) { /* ... */ }  
  
// good!  
public fun call_app(  
    app: &mut App,  
    cap: &AppCap,  
    value: u8,  
    is_smth: bool,  
    clock: &Clock,  
    ctx: &mut TxContext,  
) { /* ... */ }
```

### Capabilities Go Second[​](#capabilities-go-second "Direct link to Capabilities Go Second")

```move
// bad! breaks method associativity  
public fun authorize_action(cap: &AdminCap, app: &mut App) { /* ... */ }  
  
// good! keeps Cap visible in the signature and maintains `.calls()`  
public fun authorize_action(app: &mut App, cap: &AdminCap) { /* ... */ }
```

### Getters Named After Field + \_mut[​](#getters-named-after-field--_mut "Direct link to getters-named-after-field--_mut")

```move
// bad! unnecessary `get_`  
public fun get_name(u: &User): String { /* ... */ }  
  
// good! clear that it accesses field `name`  
public fun name(u: &User): String { /* ... */ }  
  
// good! for mutable references use `_mut`  
public fun details_mut(u: &mut User): &mut Details { /* ... */ }
```

## Function Body: Struct Methods[​](#function-body-struct-methods "Direct link to Function Body: Struct Methods")

### Common Coin Operations[​](#common-coin-operations "Direct link to Common Coin Operations")

```move
// bad! legacy code, hard to read!  
let paid = coin::split(&mut payment, amount, ctx);  
let balance = coin::into_balance(paid);  
  
// good! struct methods make it easier!  
let balance = payment.split(amount, ctx).into_balance();  
  
// even better (in this example - no need to create temporary coin)  
let balance = payment.balance_mut().split(amount);  
  
// also can do this!  
let coin = balance.into_coin(ctx);
```

### Do Not Import std::string::utf8[​](#do-not-import-stdstringutf8 "Direct link to do-not-import-stdstringutf8")

```move
// bad! unfortunately, very common!  
use std::string::utf8;  
  
let str = utf8(b"hello, world!");  
  
// good!  
let str = b"hello, world!".to_string();  
  
// also, for ASCII string  
let ascii = b"hello, world!".to_ascii_string();
```

### UID has delete[​](#uid-has-delete "Direct link to uid-has-delete")

```move
// bad!  
object::delete(id);  
  
// good!  
id.delete();
```

### ctx has sender()[​](#ctx-has-sender "Direct link to ctx-has-sender")

```move
// bad!  
tx_context::sender(ctx);  
  
// good!  
ctx.sender()
```

### Vector Has a Literal. And Associated Functions[​](#vector-has-a-literal-and-associated-functions "Direct link to Vector Has a Literal. And Associated Functions")

```move
// bad!  
let mut my_vec = vector::empty();  
vector::push_back(&mut my_vec, 10);  
let first_el = vector::borrow(&my_vec);  
assert!(vector::length(&my_vec) == 1);  
  
// good!  
let mut my_vec = vector[10];  
let first_el = my_vec[0];  
assert!(my_vec.length() == 1);
```

### Collections Support Index Syntax[​](#collections-support-index-syntax "Direct link to Collections Support Index Syntax")

```move
let x: VecMap<u8, String> = /* ... */;  
  
// bad!  
x.get(&10);  
x.get_mut(&10);  
  
// good!  
&x[&10];  
&mut x[&10];
```

## Option -> Macros[​](#option---macros "Direct link to Option -> Macros")

### Destroy And Call Function[​](#destroy-and-call-function "Direct link to Destroy And Call Function")

```move
// bad!  
if (opt.is_some()) {  
    let inner = opt.destroy_some();  
    call_function(inner);  
};  
  
// good! there's a macro for it!  
opt.do!(|value| call_function(value));
```

### Destroy Some With Default[​](#destroy-some-with-default "Direct link to Destroy Some With Default")

```move
let opt = option::none();  
  
// bad!  
let value = if (opt.is_some()) {  
    opt.destroy_some()  
} else {  
    abort EError  
};  
  
// good! there's a macro!  
let value = opt.destroy_or!(default_value);  
  
// you can even do abort on `none`  
let value = opt.destroy_or!(abort ECannotBeEmpty);
```

## Loops -> Macros[​](#loops---macros "Direct link to Loops -> Macros")

### Do Operation N Times[​](#do-operation-n-times "Direct link to Do Operation N Times")

```move
// bad! hard to read!  
let mut i = 0;  
while (i < 32) {  
    do_action();  
    i = i + 1;  
};  
  
// good! any uint has this macro!  
32u8.do!(|_| do_action());
```

### New Vector From Iteration[​](#new-vector-from-iteration "Direct link to New Vector From Iteration")

```move
// harder to read!  
let mut i = 0;  
let mut elements = vector[];  
while (i < 32) {  
    elements.push_back(i);  
    i = i + 1;  
};  
  
// easy to read!  
vector::tabulate!(32, |i| i);
```

### Do Operation on Every Element of a Vector[​](#do-operation-on-every-element-of-a-vector "Direct link to Do Operation on Every Element of a Vector")

```move
// bad!  
let mut i = 0;  
while (i < vec.length()) {  
    call_function(&vec[i]);  
    i = i + 1;  
};  
  
// good!  
vec.do_ref!(|e| call_function(e));
```

### Destroy a Vector and Call a Function on Each Element[​](#destroy-a-vector-and-call-a-function-on-each-element "Direct link to Destroy a Vector and Call a Function on Each Element")

```move
// bad!  
while (!vec.is_empty()) {  
    call(vec.pop_back());  
};  
  
// good!  
vec.destroy!(|e| call(e));
```

### Fold Vector Into a Single Value[​](#fold-vector-into-a-single-value "Direct link to Fold Vector Into a Single Value")

```move
// bad!  
let mut aggregate = 0;  
let mut i = 0;  
  
while (i < source.length()) {  
    aggregate = aggregate + source[i];  
    i = i + 1;  
};  
  
// good!  
let aggregate = source.fold!(0, |acc, v| {  
    acc + v  
});
```

### Filter Elements of the Vector[​](#filter-elements-of-the-vector "Direct link to Filter Elements of the Vector")

> Note: T: drop in the source vector

```move
// bad!  
let mut filtered = [];  
let mut i = 0;  
while (i < source.length()) {  
    if (source[i] > 10) {  
        filtered.push_back(source[i]);  
    };  
    i = i + 1;  
};  
  
// good!  
let filtered = source.filter!(|e| e > 10);
```

## Other[​](#other "Direct link to Other")

### Ignored Values In Unpack Can Be Ignored Altogether[​](#ignored-values-in-unpack-can-be-ignored-altogether "Direct link to Ignored Values In Unpack Can Be Ignored Altogether")

```move
// bad! very sparse!  
let MyStruct { id, field_1: _, field_2: _, field_3: _ } = value;  
id.delete();  
  
// good! 2024 syntax  
let MyStruct { id, .. } = value;  
id.delete();
```

## Testing[​](#testing "Direct link to Testing")

### Merge #[test] and #[expected\_failure(...)][​](#merge-test-and-expected_failure "Direct link to merge-test-and-expected_failure")

```move
// bad!  
#[test]  
#[expected_failure]  
fun value_passes_check() {  
    abort  
}  
  
// good!  
#[test, expected_failure]  
fun value_passes_check() {  
    abort  
}
```

### Do Not Clean Up expected\_failure Tests[​](#do-not-clean-up-expected_failure-tests "Direct link to do-not-clean-up-expected_failure-tests")

```move
// bad! clean up is not necessary  
#[test, expected_failure(abort_code = my_app::EIncorrectValue)]  
fun try_take_missing_object_fail() {  
    let mut test = test_scenario::begin(@0);  
    my_app::call_function(test.ctx());  
    test.end();  
}  
  
// good! easy to see where test is expected to fail  
#[test, expected_failure(abort_code = my_app::EIncorrectValue)]  
fun try_take_missing_object_fail() {  
    let mut test = test_scenario::begin(@0);  
    my_app::call_function(test.ctx());  
  
    abort // will differ from EIncorrectValue  
}
```

### Do Not Prefix Tests With test\_ in Testing Modules[​](#do-not-prefix-tests-with-test_-in-testing-modules "Direct link to do-not-prefix-tests-with-test_-in-testing-modules")

```move
// bad! the module is already called _tests  
module my_package::my_module_tests;  
  
#[test]  
fun test_this_feature() { /* ... */ }  
  
// good! better function name as the result  
#[test]  
fun this_feature_works() { /* ... */ }
```

### Do Not Use TestScenario Where Not Necessary[​](#do-not-use-testscenario-where-not-necessary "Direct link to do-not-use-testscenario-where-not-necessary")

```move
// bad! no need, only using ctx  
let mut test = test_scenario::begin(@0);  
let nft = app::mint(test.ctx());  
app::destroy(nft);  
test.end();  
  
// good! there's a dummy context for simple cases  
let ctx = &mut tx_context::dummy();  
app::mint(ctx).destroy();
```

### Do Not Use Abort Codes in assert! in Tests[​](#do-not-use-abort-codes-in-assert-in-tests "Direct link to do-not-use-abort-codes-in-assert-in-tests")

```move
// bad! may match application error codes by accident  
assert!(is_success, 0);  
  
// good!  
assert!(is_success);
```

### Use assert\_eq! Whenever Possible[​](#use-assert_eq-whenever-possible "Direct link to use-assert_eq-whenever-possible")

```move
// bad! old-style code  
assert!(result == b"expected_value", 0);  
  
// good! will print both values if fails  
use std::unit_test::assert_eq;  
  
assert_eq!(result, expected_value);
```

### Use "Black Hole" destroy Function[​](#use-black-hole-destroy-function "Direct link to use-black-hole-destroy-function")

```move
// bad!  
nft.destroy_for_testing();  
app.destroy_for_testing();  
  
// good! - no need to define special functions for cleanup  
use sui::test_utils::destroy;  
  
destroy(nft);  
destroy(app);
```

## Comments[​](#comments "Direct link to Comments")

### Doc Comments Start With ///[​](#doc-comments-start-with- "Direct link to doc-comments-start-with-")

```move
// bad! tooling doesn't support JavaDoc-style comments  
/**  
 * Cool method  
 * @param ...  
 */  
public fun do_something() { /* ... */ }  
  
// good! will be rendered as a doc comment in docgen and IDE's  
/// Cool method!  
public fun do_something() { /* ... */ }
```

### Complex Logic? Leave a Comment //[​](#complex-logic-leave-a-comment- "Direct link to complex-logic-leave-a-comment-")

Being friendly and helping reviewers understand the code!

```move
// good!  
// Note: can underflow if a value is smaller than 10.  
// TODO: add an `assert!` here  
let value = external_call(value, ctx);
```

* [Code Organization](#code-organization)
* [Package Manifest](#package-manifest)
  + [Use Right Edition](#use-right-edition)
  + [Implicit Framework Dependency](#implicit-framework-dependency)
  + [Prefix Named Addresses](#prefix-named-addresses)
* [Imports, Module and Constants](#imports-module-and-constants)
  + [Using Module Label](#using-module-label)
  + [No Single `Self` in `use` Statements](#no-single-self-in-use-statements)
  + [Group `use` Statements with `Self`](#group-use-statements-with-self)
  + [Error Constants are in `EPascalCase`](#error-constants-are-in-epascalcase)
  + [Regular Constant are `ALL_CAPS`](#regular-constant-are-all_caps)
* [Structs](#structs)
  + [Capabilities are Suffixed with `Cap`](#capabilities-are-suffixed-with-cap)
  + [No `Potato` in Names](#no-potato-in-names)
  + [Events Should Be Named in Past Tense](#events-should-be-named-in-past-tense)
  + [Use Positional Structs for Dynamic Field Keys + `Key` Suffix](#use-positional-structs-for-dynamic-field-keys--key-suffix)
* [Functions](#functions)
  + [No `public entry`, Only `public` or `entry`](#no-public-entry-only-public-or-entry)
  + [Write Composable Functions for PTBs](#write-composable-functions-for-ptbs)
  + [Objects Go First (Except for Clock)](#objects-go-first-except-for-clock)
  + [Capabilities Go Second](#capabilities-go-second)
  + [Getters Named After Field + `_mut`](#getters-named-after-field--_mut)
* [Function Body: Struct Methods](#function-body-struct-methods)
  + [Common Coin Operations](#common-coin-operations)
  + [Do Not Import `std::string::utf8`](#do-not-import-stdstringutf8)
  + [UID has `delete`](#uid-has-delete)
  + [`ctx` has `sender()`](#ctx-has-sender)
  + [Vector Has a Literal. And Associated Functions](#vector-has-a-literal-and-associated-functions)
  + [Collections Support Index Syntax](#collections-support-index-syntax)
* [Option -> Macros](#option---macros)
  + [Destroy And Call Function](#destroy-and-call-function)
  + [Destroy Some With Default](#destroy-some-with-default)
* [Loops -> Macros](#loops---macros)
  + [Do Operation N Times](#do-operation-n-times)
  + [New Vector From Iteration](#new-vector-from-iteration)
  + [Do Operation on Every Element of a Vector](#do-operation-on-every-element-of-a-vector)
  + [Destroy a Vector and Call a Function on Each Element](#destroy-a-vector-and-call-a-function-on-each-element)
  + [Fold Vector Into a Single Value](#fold-vector-into-a-single-value)
  + [Filter Elements of the Vector](#filter-elements-of-the-vector)
* [Other](#other)
  + [Ignored Values In Unpack Can Be Ignored Altogether](#ignored-values-in-unpack-can-be-ignored-altogether)
* [Testing](#testing)
  + [Merge `#[test]` and `#[expected_failure(...)]`](#merge-test-and-expected_failure)
  + [Do Not Clean Up `expected_failure` Tests](#do-not-clean-up-expected_failure-tests)
  + [Do Not Prefix Tests With `test_` in Testing Modules](#do-not-prefix-tests-with-test_-in-testing-modules)
  + [Do Not Use `TestScenario` Where Not Necessary](#do-not-use-testscenario-where-not-necessary)
  + [Do Not Use Abort Codes in `assert!` in Tests](#do-not-use-abort-codes-in-assert-in-tests)
  + [Use `assert_eq!` Whenever Possible](#use-assert_eq-whenever-possible)
  + [Use "Black Hole" `destroy` Function](#use-black-hole-destroy-function)
* [Comments](#comments)
  + [Doc Comments Start With `///`](#doc-comments-start-with-)
  + [Complex Logic? Leave a Comment `//`](#complex-logic-leave-a-comment-)
Appendix A: Glossary | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Appendix A: Glossary

* Fast Path - term used to describe a transaction that does not involve shared objects, and can be
  executed without the need for consensus.
* Parallel Execution - term used to describe the ability of the Sui runtime to execute transactions
  in parallel, including the ones that involve shared objects.
* Internal Type - type that is defined within the module. Fields of this type can not be accessed
  from outside the module, and, in case of "key"-only abilities, can not be used in public\_\*
  transfer functions.

## Abilities[​](#abilities "Direct link to Abilities")

* key - ability that allows the struct to be used as a key in the storage. On Sui, the key ability
  marks an object and requires the first field to be a id: UID.
* store - ability that allows the struct to be stored inside other objects. This ability relaxes
  restrictions applied to internal structs, allowing public\_\* transfer functions to accept them as
  arguments. It also enables the object to be stored as a dynamic field.
* copy - ability that allows the struct to be copied. On Sui, the copy ability conflicts with the
  key ability, and can not be used together with it.
* drop - ability that allows the struct to be ignored or discarded. On Sui, the drop ability
  cannot be used together with the key ability, as objects are not allowed to be ignored.

* [Abilities](#abilities)
Appendix B: Reserved Addresses | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Appendix B: Reserved Addresses

Reserved addresses are special addresses that have a specific purpose on Sui. They stay the same
between environments and are used for specific native operations.

* 0x1 - address of the [Standard Library](/move-basics/standard-library) (alias std)
* 0x2 - address of the [Sui Framework](/programmability/sui-framework) (alias sui)
* 0x5 - address of the SuiSystem object
* 0x6 - address of the system [Clock object](/programmability/epoch-and-time)
* 0x8 - address of the system Random object
* 0xc - address of the system CoinRegistry object
* 0x403 - address of the DenyList system object
Appendix C: Transfer Functions | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

On this page

# Appendix C: Transfer Functions

## Transfer Functions Comparison[​](#transfer-functions-comparison "Direct link to Transfer Functions Comparison")

| Function | Public Function | End State | Permissions |
| --- | --- | --- | --- |
| [transfer](https://docs.sui.io/references/framework/sui_sui/transfer#sui_transfer_transfer) | public\_transfer | Address Owned | Full |
| [share\_object](https://docs.sui.io/references/framework/sui_sui/transfer#sui_transfer_share_object) | public\_share\_object | Shared | Ref, Mut Ref, Delete |
| [freeze\_object](https://docs.sui.io/references/framework/sui_sui/transfer#sui_transfer_freeze_object) | public\_freeze\_object | Frozen | Ref |
| [party\_transfer](https://docs.sui.io/references/framework/sui_sui/transfer#sui_transfer_party_transfer) | public\_party\_transfer | Party | [See Party table](#party) |

## States Comparison[​](#states-comparison "Direct link to States Comparison")

| State | Description |
| --- | --- |
| Address Owned | Object can be accessed fully by an address (or an object) |
| Shared | Object can be referenced and deleted by anyone |
| Frozen | Object can be accessed via immutable reference |
| Party | Depends on the Party settings ([see Party table](#party)) |

## Party[​](#party "Direct link to Party")

| Function | Description |
| --- | --- |
| single\_owner | Object has same permissions as Address Owned |

* [Transfer Functions Comparison](#transfer-functions-comparison)
* [States Comparison](#states-comparison)
* [Party](#party)
Appendix D: Publications | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Appendix D: Publications

This section lists publications related to Move and Sui.

* [The Move Borrow Checker](https://arxiv.org/abs/2205.05181) by Sam Blackshear, John Mitchell, Todd
  Nowacki, Shaz Qadeer.
* [Resources: A Safe Language Abstraction for Money](https://arxiv.org/abs/2004.05106) by Sam
  Blackshear, David L. Dill, Shaz Qadeer, Clark W. Barrett, John C. Mitchell, Oded Padon, Yoni
  Zohar.
* [Robust Safety for Move](https://arxiv.org/abs/2110.05043) by Marco Patrignani, Sam Blackshear
Appendix E: Contributing | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Appendix E: Contributing

To contribute to this book, please, submit a pull request to the
[GitHub repository](https://github.com/MystenLabs/move-book). The repository contains the source
files for the book, written in mdBook format.
Appendix F: Acknowledgements | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Appendix F: Acknowledgements

[The Rust Book](https://doc.rust-lang.org/book) has been a great inspiration for this book. I am
personally grateful to the authors of the book, Steve Klabnik and Carol Nichols, for their work, as
I have learned a lot from it. This book is a small tribute to their work and an attempt to bring a
similar learning experience to the Move community.
GitHub - MystenLabs/move-book: The Move Book and The Move Reference



[Skip to content](#start-of-content)








## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FMystenLabs%2Fmove-book)

Appearance settings

Search or jump to...


# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.


Include my email address so I can be contacted

Cancel
 Submit feedback





# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

Cancel
 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FMystenLabs%2Fmove-book)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=MystenLabs%2Fmove-book)

Appearance settings

Resetting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.
 


Dismiss alert

{{ message }}

[MystenLabs](/MystenLabs) 
/
**[move-book](/MystenLabs/move-book)**
Public

* [Notifications](/login?return_to=%2FMystenLabs%2Fmove-book) You must be signed in to change notification settings
* [Fork
  146](/login?return_to=%2FMystenLabs%2Fmove-book)
* [Star
   255](/login?return_to=%2FMystenLabs%2Fmove-book)

The Move Book and The Move Reference

[move-book.com](https://move-book.com "https://move-book.com")

### License

[Apache-2.0 license](/MystenLabs/move-book/blob/main/LICENSE)

[255
stars](/MystenLabs/move-book/stargazers) [146
forks](/MystenLabs/move-book/forks) [Branches](/MystenLabs/move-book/branches) [Tags](/MystenLabs/move-book/tags) [Activity](/MystenLabs/move-book/activity)

[Star](/login?return_to=%2FMystenLabs%2Fmove-book)

[Notifications](/login?return_to=%2FMystenLabs%2Fmove-book) You must be signed in to change notification settings

# MystenLabs/move-book

main

[Branches](/MystenLabs/move-book/branches)[Tags](/MystenLabs/move-book/tags)

Go to file

Code

Open more actions menu

## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit   History[147 Commits](/MystenLabs/move-book/commits/main/) | | |
| [.github](/MystenLabs/move-book/tree/main/.github ".github") | | [.github](/MystenLabs/move-book/tree/main/.github ".github") |  |  |
| [book](/MystenLabs/move-book/tree/main/book "book") | | [book](/MystenLabs/move-book/tree/main/book "book") |  |  |
| [packages](/MystenLabs/move-book/tree/main/packages "packages") | | [packages](/MystenLabs/move-book/tree/main/packages "packages") |  |  |
| [reference](/MystenLabs/move-book/tree/main/reference "reference") | | [reference](/MystenLabs/move-book/tree/main/reference "reference") |  |  |
| [site](/MystenLabs/move-book/tree/main/site "site") | | [site](/MystenLabs/move-book/tree/main/site "site") |  |  |
| [.gitignore](/MystenLabs/move-book/blob/main/.gitignore ".gitignore") | | [.gitignore](/MystenLabs/move-book/blob/main/.gitignore ".gitignore") |  |  |
| [.prettierrc](/MystenLabs/move-book/blob/main/.prettierrc ".prettierrc") | | [.prettierrc](/MystenLabs/move-book/blob/main/.prettierrc ".prettierrc") |  |  |
| [CNAME](/MystenLabs/move-book/blob/main/CNAME "CNAME") | | [CNAME](/MystenLabs/move-book/blob/main/CNAME "CNAME") |  |  |
| [LICENSE](/MystenLabs/move-book/blob/main/LICENSE "LICENSE") | | [LICENSE](/MystenLabs/move-book/blob/main/LICENSE "LICENSE") |  |  |
| [README.md](/MystenLabs/move-book/blob/main/README.md "README.md") | | [README.md](/MystenLabs/move-book/blob/main/README.md "README.md") |  |  |
| [package.json](/MystenLabs/move-book/blob/main/package.json "package.json") | | [package.json](/MystenLabs/move-book/blob/main/package.json "package.json") |  |  |
| View all files | | |

## Repository files navigation

# The Move Book

This is the repository for [the Move Book](https://move-book.com) and
[Move Language Reference](https://move-book.com/reference).

## Structure

* Two books are placed in the `book` and `reference` directories. The `book` directory contains the
  main book, and the `reference` directory contains the reference book.
* The `packages` directory contains the code samples used in both books.
* The `site` directory contains [docusaurus](/MystenLabs/move-book/blob/main/docusaurus.io) configuration and custom plugins for it.

## Running the Books Locally

### Prerequisites

* NodeJS
* `pnpm` (installation is: `npm i -g pnpm`)

### Local Server

> All commands can be run from the root.

```move
pnpm start
```

*The book will be available at `http://localhost:3000`.*

### Production Build Test

```move
pnpm build
pnpm serve
```

## Archive

For the archive of the old version of the book, see the `archive` branch.

## About

The Move Book and The Move Reference

[move-book.com](https://move-book.com "https://move-book.com")

### Topics

[move](/topics/move "Topic: move")
[sui](/topics/sui "Topic: sui")

### Resources

[Readme](#readme-ov-file)

### License

[Apache-2.0 license](#Apache-2.0-1-ov-file)

### Uh oh!

There was an error while loading. Please reload this page.

[Activity](/MystenLabs/move-book/activity)

[Custom properties](/MystenLabs/move-book/custom-properties)

### Stars

[**255**
stars](/MystenLabs/move-book/stargazers)

### Watchers

[**8**
watching](/MystenLabs/move-book/watchers)

### Forks

[**146**
forks](/MystenLabs/move-book/forks)

[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2FMystenLabs%2Fmove-book&report=MystenLabs+%28user%29)

### Uh oh!

There was an error while loading. Please reload this page.

## [Contributors 49](/MystenLabs/move-book/graphs/contributors)

* [![@damirka](https://avatars.githubusercontent.com/u/8008055?s=64&v=4)](https://github.com/damirka)
* [![@zcy1024](https://avatars.githubusercontent.com/u/44721066?s=64&v=4)](https://github.com/zcy1024)
* [![@ronny-mysten](https://avatars.githubusercontent.com/u/118224482?s=64&v=4)](https://github.com/ronny-mysten)
* [![@tzakian](https://avatars.githubusercontent.com/u/2895723?s=64&v=4)](https://github.com/tzakian)
* [![@cgswords](https://avatars.githubusercontent.com/u/1130991?s=64&v=4)](https://github.com/cgswords)
* [![@yjshi2015](https://avatars.githubusercontent.com/u/27291507?s=64&v=4)](https://github.com/yjshi2015)
* [![@tnowacki](https://avatars.githubusercontent.com/u/1753366?s=64&v=4)](https://github.com/tnowacki)
* [![@mdgeorge4153](https://avatars.githubusercontent.com/u/1286449?s=64&v=4)](https://github.com/mdgeorge4153)
* [![@campgurus](https://avatars.githubusercontent.com/u/1260659?s=64&v=4)](https://github.com/campgurus)
* [![@Danny-Devs](https://avatars.githubusercontent.com/u/38071276?s=64&v=4)](https://github.com/Danny-Devs)
* [![@yanganto](https://avatars.githubusercontent.com/u/10803111?s=64&v=4)](https://github.com/yanganto)
* [![@josemvcerqueira](https://avatars.githubusercontent.com/u/41003724?s=64&v=4)](https://github.com/josemvcerqueira)
* [![@vuvoth](https://avatars.githubusercontent.com/u/45826131?s=64&v=4)](https://github.com/vuvoth)
* [![@nikos-terzo](https://avatars.githubusercontent.com/u/139557324?s=64&v=4)](https://github.com/nikos-terzo)

[+ 35 contributors](/MystenLabs/move-book/graphs/contributors)

## Languages

* [Move
  45.5%](/MystenLabs/move-book/search?l=move)
* [JavaScript
  32.0%](/MystenLabs/move-book/search?l=javascript)
* [TypeScript
  16.4%](/MystenLabs/move-book/search?l=typescript)
* [CSS
  6.1%](/MystenLabs/move-book/search?l=css)

You can’t perform that action at this time.
The Move Reference | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# The Move Reference

Welcome to Move, a next generation language for secure asset programming. Its primary use case is in
blockchain environments, where Move programs are used to construct state changes. Move allows
developers to write programs that flexibly manage and transfer assets, while providing the security
and protections against attacks on those assets. However, Move has been developed with use cases in
mind outside a blockchain context as well.

Move takes its cue from [Rust](https://www.rust-lang.org/) by using resource types with move (hence
the name) semantics as an explicit representation of digital assets, such as currency.
Foreword | The Move Book






[Skip to main content](#__docusaurus_skipToContent_fallback)

# Foreword

This book is dedicated to Move, a smart contract language that captures the essence of safe
programming with digital assets. Move is designed around the following values:

1. **Secure by default:** Insecure languages are a serious barrier both to accessible smart contract
   development and to mainstream adoption of digital assets. The first duty of a smart contract
   language is to prevent as many potential safety issues as possible (e.g. re-entrancy, missing
   access control checks, arithmetic overflow, ...) by construction. Any changes to Move should
   preserve or enhance its existing security guarantees.
2. **Expressive by nature:** Move must enable programmers to write any smart contract they can
   imagine. But we care as much about the way it *feels* to write Move as we do about what Move
   allows you to do - the language should be rich enough that the features needed for a task are
   available, and minimal enough that the choice is obvious. The Move toolchain should be a
   productivity enhancer and a thought partner.
3. **Intuitive for all:** Smart contracts are only one part of a useful application. Move should
   understand the broader context of its usage and design with both the smart contract developer and
   the application developer in mind. It should be easy for developers to learn how to read
   Move-managed state, build Move powered transactions, and write new Move code.

The core technical elements of Move are:

* Safe, familiar, and flexible abstractions for digital assets via programmable *objects*.
* A rich *ability* system (inspired by linear types) that gives programmers extreme control of how
  values are created, destroyed, stored, copied, and transferred.
* A *module* system with strong encapsulation features to enable code reuse while maintaining this
  control.
* *Dynamic fields* for creating hierarchical relationships between objects.
* *Programmable transaction blocks* (PTBs) to enable atomic client-side composition of Move-powered
  APIs.

Move was born in 2018 as part of Facebook's Libra project. It was publicly revealed in 2019, the
first Move-powered network launched in 2020. As of April 2024, there are numerous Move-powered
chains in production with several more in the works. Move is an embedded language with a
platform-agnostic core, which means it takes on a slightly different personality in each chain that
uses it.

Creating a new programming language and bootstrapping a community around it is an ambitious, long
term project. A language has to be an order of magnitude better than alternatives in relevant ways
to have a chance, but even then the quality of the community matters more than the technical
fundamentals. Move is a young language, but it's off to a good start in terms of both
differentiation and community. A small, but fanatical group of smart contract programmers and core
contributors united by the Move values are pushing the boundaries of what smart contracts can do,
the applications they can enable, and who can (safely) write them. If that inspires you, read on!

— Sam Blackshear, creator of Move
